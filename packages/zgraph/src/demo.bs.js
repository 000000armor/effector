// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var Rtl = /* module */[];

var Base = /* module */[];

function member(x, _btree) {
  while(true) {
    var btree = _btree;
    if (btree) {
      var y = btree[0];
      if (Caml_obj.caml_equal(x, y)) {
        return /* true */1;
      } else if (Caml_obj.caml_lessthan(x, y)) {
        _btree = btree[1];
        continue ;
        
      } else {
        _btree = btree[2];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function insert(x, btree) {
  if (btree) {
    var right = btree[2];
    var left = btree[1];
    var y = btree[0];
    if (Caml_obj.caml_lessequal(x, y)) {
      return /* Node */[
              y,
              insert(x, left),
              right
            ];
    } else {
      return /* Node */[
              y,
              left,
              insert(x, right)
            ];
    }
  } else {
    return /* Node */[
            x,
            /* Empty */0,
            /* Empty */0
          ];
  }
}

var Unbound_variable = Caml_exceptions.create("Demo.Unbound_variable");

function $$eval(env, exp) {
  switch (exp.tag | 0) {
    case 0 : 
        return exp[0];
    case 1 : 
        var v = exp[0];
        try {
          return List.assoc(v, env);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            throw [
                  Unbound_variable,
                  v
                ];
          } else {
            throw exn;
          }
        }
        break;
    case 2 : 
        return $$eval(env, exp[0]) + $$eval(env, exp[1]);
    case 3 : 
        return $$eval(env, exp[0]) - $$eval(env, exp[1]);
    case 4 : 
        return $$eval(env, exp[0]) * $$eval(env, exp[1]);
    case 5 : 
        return $$eval(env, exp[0]) / $$eval(env, exp[1]);
    
  }
}

function deriv(exp, dv) {
  switch (exp.tag | 0) {
    case 0 : 
        return /* Const */Block.__(0, [0.0]);
    case 1 : 
        if (exp[0] === dv) {
          return /* Const */Block.__(0, [1.0]);
        } else {
          return /* Const */Block.__(0, [0.0]);
        }
    case 2 : 
        return /* Sum */Block.__(2, [
                  deriv(exp[0], dv),
                  deriv(exp[1], dv)
                ]);
    case 3 : 
        return /* Diff */Block.__(3, [
                  deriv(exp[0], dv),
                  deriv(exp[1], dv)
                ]);
    case 4 : 
        var g = exp[1];
        var f = exp[0];
        return /* Sum */Block.__(2, [
                  /* Prod */Block.__(4, [
                      f,
                      deriv(g, dv)
                    ]),
                  /* Prod */Block.__(4, [
                      deriv(f, dv),
                      g
                    ])
                ]);
    case 5 : 
        var g$1 = exp[1];
        var f$1 = exp[0];
        return /* Quot */Block.__(5, [
                  /* Diff */Block.__(3, [
                      /* Prod */Block.__(4, [
                          deriv(f$1, dv),
                          g$1
                        ]),
                      /* Prod */Block.__(4, [
                          f$1,
                          deriv(g$1, dv)
                        ])
                    ]),
                  /* Prod */Block.__(4, [
                      g$1,
                      g$1
                    ])
                ]);
    
  }
}

var compare = Caml_primitive.caml_int_compare;

var IntMap = $$Map.Make(/* module */[/* compare */compare]);

function test() {
  var m = IntMap[/* empty */0];
  for(var i = 0; i <= 1000000; ++i){
    m = Curry._3(IntMap[/* add */3], i, i, m);
  }
  for(var i$1 = 0; i$1 <= 1000000; ++i$1){
    Curry._2(IntMap[/* find */21], i$1, m);
  }
  return /* () */0;
}

test(/* () */0);

console.log("Hello, BuckleScript");

var mm = "";

var lb = /* tuple */[
  0,
  "lb"
];

exports.Rtl = Rtl;
exports.Base = Base;
exports.member = member;
exports.insert = insert;
exports.Unbound_variable = Unbound_variable;
exports.$$eval = $$eval;
exports.deriv = deriv;
exports.IntMap = IntMap;
exports.test = test;
exports.mm = mm;
exports.lb = lb;
/* IntMap Not a pure module */
