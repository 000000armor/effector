/**
 * Flowtype definitions for ast-types
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.9.2
 * @flow
 */

import type {Omit} from '../types'
import type {Type} from '../lib/types'
import * as K from './kinds'

declare export var namedTypes: typeof npm$namespace$namedTypes

declare var npm$namespace$namedTypes: {
  Printable: typeof namedTypes$Printable,
  SourceLocation: typeof namedTypes$SourceLocation,
  Node: typeof namedTypes$Node,
  Comment: typeof namedTypes$Comment,
  Position: typeof namedTypes$Position,
  File: typeof namedTypes$File,
  Program: typeof namedTypes$Program,
  Statement: typeof namedTypes$Statement,
  Function: typeof namedTypes$Function,
  Expression: typeof namedTypes$Expression,
  Pattern: typeof namedTypes$Pattern,
  Identifier: typeof namedTypes$Identifier,
  BlockStatement: typeof namedTypes$BlockStatement,
  EmptyStatement: typeof namedTypes$EmptyStatement,
  ExpressionStatement: typeof namedTypes$ExpressionStatement,
  IfStatement: typeof namedTypes$IfStatement,
  LabeledStatement: typeof namedTypes$LabeledStatement,
  BreakStatement: typeof namedTypes$BreakStatement,
  ContinueStatement: typeof namedTypes$ContinueStatement,
  WithStatement: typeof namedTypes$WithStatement,
  SwitchStatement: typeof namedTypes$SwitchStatement,
  SwitchCase: typeof namedTypes$SwitchCase,
  ReturnStatement: typeof namedTypes$ReturnStatement,
  ThrowStatement: typeof namedTypes$ThrowStatement,
  TryStatement: typeof namedTypes$TryStatement,
  CatchClause: typeof namedTypes$CatchClause,
  WhileStatement: typeof namedTypes$WhileStatement,
  DoWhileStatement: typeof namedTypes$DoWhileStatement,
  ForStatement: typeof namedTypes$ForStatement,
  Declaration: typeof namedTypes$Declaration,
  VariableDeclaration: typeof namedTypes$VariableDeclaration,
  ForInStatement: typeof namedTypes$ForInStatement,
  DebuggerStatement: typeof namedTypes$DebuggerStatement,
  FunctionDeclaration: typeof namedTypes$FunctionDeclaration,
  FunctionExpression: typeof namedTypes$FunctionExpression,
  VariableDeclarator: typeof namedTypes$VariableDeclarator,
  ThisExpression: typeof namedTypes$ThisExpression,
  ArrayExpression: typeof namedTypes$ArrayExpression,
  ObjectExpression: typeof namedTypes$ObjectExpression,
  Property: typeof namedTypes$Property,
  Literal: typeof namedTypes$Literal,
  SequenceExpression: typeof namedTypes$SequenceExpression,
  UnaryExpression: typeof namedTypes$UnaryExpression,
  BinaryExpression: typeof namedTypes$BinaryExpression,
  AssignmentExpression: typeof namedTypes$AssignmentExpression,
  MemberExpression: typeof namedTypes$MemberExpression,
  UpdateExpression: typeof namedTypes$UpdateExpression,
  LogicalExpression: typeof namedTypes$LogicalExpression,
  ConditionalExpression: typeof namedTypes$ConditionalExpression,
  NewExpression: typeof namedTypes$NewExpression,
  CallExpression: typeof namedTypes$CallExpression,
  RestElement: typeof namedTypes$RestElement,
  TypeAnnotation: typeof namedTypes$TypeAnnotation,
  TSTypeAnnotation: typeof namedTypes$TSTypeAnnotation,
  SpreadElementPattern: typeof namedTypes$SpreadElementPattern,
  ArrowFunctionExpression: typeof namedTypes$ArrowFunctionExpression,
  ForOfStatement: typeof namedTypes$ForOfStatement,
  YieldExpression: typeof namedTypes$YieldExpression,
  GeneratorExpression: typeof namedTypes$GeneratorExpression,
  ComprehensionBlock: typeof namedTypes$ComprehensionBlock,
  ComprehensionExpression: typeof namedTypes$ComprehensionExpression,
  ObjectProperty: typeof namedTypes$ObjectProperty,
  PropertyPattern: typeof namedTypes$PropertyPattern,
  ObjectPattern: typeof namedTypes$ObjectPattern,
  ArrayPattern: typeof namedTypes$ArrayPattern,
  MethodDefinition: typeof namedTypes$MethodDefinition,
  SpreadElement: typeof namedTypes$SpreadElement,
  AssignmentPattern: typeof namedTypes$AssignmentPattern,
  ClassPropertyDefinition: typeof namedTypes$ClassPropertyDefinition,
  ClassProperty: typeof namedTypes$ClassProperty,
  ClassBody: typeof namedTypes$ClassBody,
  ClassDeclaration: typeof namedTypes$ClassDeclaration,
  ClassExpression: typeof namedTypes$ClassExpression,
  Specifier: typeof namedTypes$Specifier,
  ModuleSpecifier: typeof namedTypes$ModuleSpecifier,
  ImportSpecifier: typeof namedTypes$ImportSpecifier,
  ImportNamespaceSpecifier: typeof namedTypes$ImportNamespaceSpecifier,
  ImportDefaultSpecifier: typeof namedTypes$ImportDefaultSpecifier,
  ImportDeclaration: typeof namedTypes$ImportDeclaration,
  TaggedTemplateExpression: typeof namedTypes$TaggedTemplateExpression,
  TemplateLiteral: typeof namedTypes$TemplateLiteral,
  TemplateElement: typeof namedTypes$TemplateElement,
  SpreadProperty: typeof namedTypes$SpreadProperty,
  SpreadPropertyPattern: typeof namedTypes$SpreadPropertyPattern,
  AwaitExpression: typeof namedTypes$AwaitExpression,
  JSXAttribute: typeof namedTypes$JSXAttribute,
  JSXIdentifier: typeof namedTypes$JSXIdentifier,
  JSXNamespacedName: typeof namedTypes$JSXNamespacedName,
  JSXExpressionContainer: typeof namedTypes$JSXExpressionContainer,
  JSXMemberExpression: typeof namedTypes$JSXMemberExpression,
  JSXSpreadAttribute: typeof namedTypes$JSXSpreadAttribute,
  JSXElement: typeof namedTypes$JSXElement,
  JSXOpeningElement: typeof namedTypes$JSXOpeningElement,
  JSXClosingElement: typeof namedTypes$JSXClosingElement,
  JSXFragment: typeof namedTypes$JSXFragment,
  JSXText: typeof namedTypes$JSXText,
  JSXOpeningFragment: typeof namedTypes$JSXOpeningFragment,
  JSXClosingFragment: typeof namedTypes$JSXClosingFragment,
  JSXEmptyExpression: typeof namedTypes$JSXEmptyExpression,
  JSXSpreadChild: typeof namedTypes$JSXSpreadChild,
  TypeParameterDeclaration: typeof namedTypes$TypeParameterDeclaration,
  TSTypeParameterDeclaration: typeof namedTypes$TSTypeParameterDeclaration,
  TypeParameterInstantiation: typeof namedTypes$TypeParameterInstantiation,
  TSTypeParameterInstantiation: typeof namedTypes$TSTypeParameterInstantiation,
  ClassImplements: typeof namedTypes$ClassImplements,
  TSType: typeof namedTypes$TSType,
  TSHasOptionalTypeParameterInstantiation: typeof namedTypes$TSHasOptionalTypeParameterInstantiation,
  TSExpressionWithTypeArguments: typeof namedTypes$TSExpressionWithTypeArguments,
  Flow: typeof namedTypes$Flow,
  FlowType: typeof namedTypes$FlowType,
  AnyTypeAnnotation: typeof namedTypes$AnyTypeAnnotation,
  EmptyTypeAnnotation: typeof namedTypes$EmptyTypeAnnotation,
  MixedTypeAnnotation: typeof namedTypes$MixedTypeAnnotation,
  VoidTypeAnnotation: typeof namedTypes$VoidTypeAnnotation,
  NumberTypeAnnotation: typeof namedTypes$NumberTypeAnnotation,
  NumberLiteralTypeAnnotation: typeof namedTypes$NumberLiteralTypeAnnotation,
  NumericLiteralTypeAnnotation: typeof namedTypes$NumericLiteralTypeAnnotation,
  StringTypeAnnotation: typeof namedTypes$StringTypeAnnotation,
  StringLiteralTypeAnnotation: typeof namedTypes$StringLiteralTypeAnnotation,
  BooleanTypeAnnotation: typeof namedTypes$BooleanTypeAnnotation,
  BooleanLiteralTypeAnnotation: typeof namedTypes$BooleanLiteralTypeAnnotation,
  NullableTypeAnnotation: typeof namedTypes$NullableTypeAnnotation,
  NullLiteralTypeAnnotation: typeof namedTypes$NullLiteralTypeAnnotation,
  NullTypeAnnotation: typeof namedTypes$NullTypeAnnotation,
  ThisTypeAnnotation: typeof namedTypes$ThisTypeAnnotation,
  ExistsTypeAnnotation: typeof namedTypes$ExistsTypeAnnotation,
  ExistentialTypeParam: typeof namedTypes$ExistentialTypeParam,
  FunctionTypeAnnotation: typeof namedTypes$FunctionTypeAnnotation,
  FunctionTypeParam: typeof namedTypes$FunctionTypeParam,
  ArrayTypeAnnotation: typeof namedTypes$ArrayTypeAnnotation,
  ObjectTypeAnnotation: typeof namedTypes$ObjectTypeAnnotation,
  ObjectTypeProperty: typeof namedTypes$ObjectTypeProperty,
  ObjectTypeSpreadProperty: typeof namedTypes$ObjectTypeSpreadProperty,
  ObjectTypeIndexer: typeof namedTypes$ObjectTypeIndexer,
  ObjectTypeCallProperty: typeof namedTypes$ObjectTypeCallProperty,
  ObjectTypeInternalSlot: typeof namedTypes$ObjectTypeInternalSlot,
  Variance: typeof namedTypes$Variance,
  QualifiedTypeIdentifier: typeof namedTypes$QualifiedTypeIdentifier,
  GenericTypeAnnotation: typeof namedTypes$GenericTypeAnnotation,
  MemberTypeAnnotation: typeof namedTypes$MemberTypeAnnotation,
  UnionTypeAnnotation: typeof namedTypes$UnionTypeAnnotation,
  IntersectionTypeAnnotation: typeof namedTypes$IntersectionTypeAnnotation,
  TypeofTypeAnnotation: typeof namedTypes$TypeofTypeAnnotation,
  TypeParameter: typeof namedTypes$TypeParameter,
  InterfaceTypeAnnotation: typeof namedTypes$InterfaceTypeAnnotation,
  InterfaceExtends: typeof namedTypes$InterfaceExtends,
  InterfaceDeclaration: typeof namedTypes$InterfaceDeclaration,
  DeclareInterface: typeof namedTypes$DeclareInterface,
  TypeAlias: typeof namedTypes$TypeAlias,
  OpaqueType: typeof namedTypes$OpaqueType,
  DeclareTypeAlias: typeof namedTypes$DeclareTypeAlias,
  DeclareOpaqueType: typeof namedTypes$DeclareOpaqueType,
  TypeCastExpression: typeof namedTypes$TypeCastExpression,
  TupleTypeAnnotation: typeof namedTypes$TupleTypeAnnotation,
  DeclareVariable: typeof namedTypes$DeclareVariable,
  DeclareFunction: typeof namedTypes$DeclareFunction,
  DeclareClass: typeof namedTypes$DeclareClass,
  DeclareModule: typeof namedTypes$DeclareModule,
  DeclareModuleExports: typeof namedTypes$DeclareModuleExports,
  DeclareExportDeclaration: typeof namedTypes$DeclareExportDeclaration,
  ExportSpecifier: typeof namedTypes$ExportSpecifier,
  ExportBatchSpecifier: typeof namedTypes$ExportBatchSpecifier,
  DeclareExportAllDeclaration: typeof namedTypes$DeclareExportAllDeclaration,
  FlowPredicate: typeof namedTypes$FlowPredicate,
  InferredPredicate: typeof namedTypes$InferredPredicate,
  DeclaredPredicate: typeof namedTypes$DeclaredPredicate,
  ExportDeclaration: typeof namedTypes$ExportDeclaration,
  Block: typeof namedTypes$Block,
  Line: typeof namedTypes$Line,
  Noop: typeof namedTypes$Noop,
  DoExpression: typeof namedTypes$DoExpression,
  Super: typeof namedTypes$Super,
  BindExpression: typeof namedTypes$BindExpression,
  Decorator: typeof namedTypes$Decorator,
  MetaProperty: typeof namedTypes$MetaProperty,
  ParenthesizedExpression: typeof namedTypes$ParenthesizedExpression,
  ExportDefaultDeclaration: typeof namedTypes$ExportDefaultDeclaration,
  ExportNamedDeclaration: typeof namedTypes$ExportNamedDeclaration,
  ExportNamespaceSpecifier: typeof namedTypes$ExportNamespaceSpecifier,
  ExportDefaultSpecifier: typeof namedTypes$ExportDefaultSpecifier,
  ExportAllDeclaration: typeof namedTypes$ExportAllDeclaration,
  CommentBlock: typeof namedTypes$CommentBlock,
  CommentLine: typeof namedTypes$CommentLine,
  Directive: typeof namedTypes$Directive,
  DirectiveLiteral: typeof namedTypes$DirectiveLiteral,
  InterpreterDirective: typeof namedTypes$InterpreterDirective,
  StringLiteral: typeof namedTypes$StringLiteral,
  NumericLiteral: typeof namedTypes$NumericLiteral,
  BigIntLiteral: typeof namedTypes$BigIntLiteral,
  NullLiteral: typeof namedTypes$NullLiteral,
  BooleanLiteral: typeof namedTypes$BooleanLiteral,
  RegExpLiteral: typeof namedTypes$RegExpLiteral,
  ObjectMethod: typeof namedTypes$ObjectMethod,
  ClassPrivateProperty: typeof namedTypes$ClassPrivateProperty,
  ClassMethod: typeof namedTypes$ClassMethod,
  ClassPrivateMethod: typeof namedTypes$ClassPrivateMethod,
  PrivateName: typeof namedTypes$PrivateName,
  RestProperty: typeof namedTypes$RestProperty,
  ForAwaitStatement: typeof namedTypes$ForAwaitStatement,
  Import: typeof namedTypes$Import,
  TSQualifiedName: typeof namedTypes$TSQualifiedName,
  TSTypeReference: typeof namedTypes$TSTypeReference,
  TSHasOptionalTypeParameters: typeof namedTypes$TSHasOptionalTypeParameters,
  TSHasOptionalTypeAnnotation: typeof namedTypes$TSHasOptionalTypeAnnotation,
  TSAsExpression: typeof namedTypes$TSAsExpression,
  TSNonNullExpression: typeof namedTypes$TSNonNullExpression,
  TSAnyKeyword: typeof namedTypes$TSAnyKeyword,
  TSBigIntKeyword: typeof namedTypes$TSBigIntKeyword,
  TSBooleanKeyword: typeof namedTypes$TSBooleanKeyword,
  TSNeverKeyword: typeof namedTypes$TSNeverKeyword,
  TSNullKeyword: typeof namedTypes$TSNullKeyword,
  TSNumberKeyword: typeof namedTypes$TSNumberKeyword,
  TSObjectKeyword: typeof namedTypes$TSObjectKeyword,
  TSStringKeyword: typeof namedTypes$TSStringKeyword,
  TSSymbolKeyword: typeof namedTypes$TSSymbolKeyword,
  TSUndefinedKeyword: typeof namedTypes$TSUndefinedKeyword,
  TSUnknownKeyword: typeof namedTypes$TSUnknownKeyword,
  TSVoidKeyword: typeof namedTypes$TSVoidKeyword,
  TSThisType: typeof namedTypes$TSThisType,
  TSArrayType: typeof namedTypes$TSArrayType,
  TSLiteralType: typeof namedTypes$TSLiteralType,
  TSUnionType: typeof namedTypes$TSUnionType,
  TSIntersectionType: typeof namedTypes$TSIntersectionType,
  TSConditionalType: typeof namedTypes$TSConditionalType,
  TSInferType: typeof namedTypes$TSInferType,
  TSTypeParameter: typeof namedTypes$TSTypeParameter,
  TSParenthesizedType: typeof namedTypes$TSParenthesizedType,
  TSFunctionType: typeof namedTypes$TSFunctionType,
  TSConstructorType: typeof namedTypes$TSConstructorType,
  TSDeclareFunction: typeof namedTypes$TSDeclareFunction,
  TSDeclareMethod: typeof namedTypes$TSDeclareMethod,
  TSMappedType: typeof namedTypes$TSMappedType,
  TSTupleType: typeof namedTypes$TSTupleType,
  TSRestType: typeof namedTypes$TSRestType,
  TSOptionalType: typeof namedTypes$TSOptionalType,
  TSIndexedAccessType: typeof namedTypes$TSIndexedAccessType,
  TSTypeOperator: typeof namedTypes$TSTypeOperator,
  TSIndexSignature: typeof namedTypes$TSIndexSignature,
  TSPropertySignature: typeof namedTypes$TSPropertySignature,
  TSMethodSignature: typeof namedTypes$TSMethodSignature,
  TSTypePredicate: typeof namedTypes$TSTypePredicate,
  TSCallSignatureDeclaration: typeof namedTypes$TSCallSignatureDeclaration,
  TSConstructSignatureDeclaration: typeof namedTypes$TSConstructSignatureDeclaration,
  TSEnumMember: typeof namedTypes$TSEnumMember,
  TSTypeQuery: typeof namedTypes$TSTypeQuery,
  TSImportType: typeof namedTypes$TSImportType,
  TSTypeLiteral: typeof namedTypes$TSTypeLiteral,
  TSTypeAssertion: typeof namedTypes$TSTypeAssertion,
  TSEnumDeclaration: typeof namedTypes$TSEnumDeclaration,
  TSTypeAliasDeclaration: typeof namedTypes$TSTypeAliasDeclaration,
  TSModuleBlock: typeof namedTypes$TSModuleBlock,
  TSModuleDeclaration: typeof namedTypes$TSModuleDeclaration,
  TSImportEqualsDeclaration: typeof namedTypes$TSImportEqualsDeclaration,
  TSExternalModuleReference: typeof namedTypes$TSExternalModuleReference,
  TSExportAssignment: typeof namedTypes$TSExportAssignment,
  TSNamespaceExportDeclaration: typeof namedTypes$TSNamespaceExportDeclaration,
  TSInterfaceBody: typeof namedTypes$TSInterfaceBody,
  TSInterfaceDeclaration: typeof namedTypes$TSInterfaceDeclaration,
  TSParameterProperty: typeof namedTypes$TSParameterProperty,
  OptionalMemberExpression: typeof namedTypes$OptionalMemberExpression,
  OptionalCallExpression: typeof namedTypes$OptionalCallExpression,
  ...
}

export interface Printable {
  loc?: K.SourceLocationKind | null;
}

export interface SourceLocation {
  start: K.PositionKind;
  end: K.PositionKind;
  source?: string | null;
}

export type Node = {
  type: string,
  comments?: K.CommentKind[] | null,
  ...
} & Printable

export type Comment = {
  value: string,
  leading?: boolean,
  trailing?: boolean,
  ...
} & Printable

export interface Position {
  line: number;
  column: number;
}

export type File = {
  type: 'File',
  program: K.ProgramKind,
  name?: string | null,
  ...
} & Omit<Node, 'type'>

export type Program = {
  type: 'Program',
  body: K.StatementKind[],
  directives?: K.DirectiveKind[],
  interpreter?: K.InterpreterDirectiveKind | null,
  ...
} & Omit<Node, 'type'>

export type Statement = {...} & Node

export type Function = {
  id?: K.IdentifierKind | null,
  params: K.PatternKind[],
  body: K.BlockStatementKind,
  generator?: boolean,
  async?: boolean,
  expression?: boolean,
  defaults?: (K.ExpressionKind | null)[],
  rest?: K.IdentifierKind | null,
  returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null,
  typeParameters?:
    | K.TypeParameterDeclarationKind
    | K.TSTypeParameterDeclarationKind
    | null,
  ...
} & Node

export type Expression = {...} & Node

export type Pattern = {...} & Node

export type Identifier = {
  type: 'Identifier',
  name: string,
  optional?: boolean,
  typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null,
  ...
} & Omit<Expression, 'type'> &
  Omit<Pattern, 'type'>

export type BlockStatement = {
  type: 'BlockStatement',
  body: K.StatementKind[],
  directives?: K.DirectiveKind[],
  ...
} & Omit<Statement, 'type'>

export type EmptyStatement = {
  type: 'EmptyStatement',
  ...
} & Omit<Statement, 'type'>

export type ExpressionStatement = {
  type: 'ExpressionStatement',
  expression: K.ExpressionKind,
  ...
} & Omit<Statement, 'type'>

export type IfStatement = {
  type: 'IfStatement',
  test: K.ExpressionKind,
  consequent: K.StatementKind,
  alternate?: K.StatementKind | null,
  ...
} & Omit<Statement, 'type'>

export type LabeledStatement = {
  type: 'LabeledStatement',
  label: K.IdentifierKind,
  body: K.StatementKind,
  ...
} & Omit<Statement, 'type'>

export type BreakStatement = {
  type: 'BreakStatement',
  label?: K.IdentifierKind | null,
  ...
} & Omit<Statement, 'type'>

export type ContinueStatement = {
  type: 'ContinueStatement',
  label?: K.IdentifierKind | null,
  ...
} & Omit<Statement, 'type'>

export type WithStatement = {
  type: 'WithStatement',
  object: K.ExpressionKind,
  body: K.StatementKind,
  ...
} & Omit<Statement, 'type'>

export type SwitchStatement = {
  type: 'SwitchStatement',
  discriminant: K.ExpressionKind,
  cases: K.SwitchCaseKind[],
  lexical?: boolean,
  ...
} & Omit<Statement, 'type'>

export type SwitchCase = {
  type: 'SwitchCase',
  test: K.ExpressionKind | null,
  consequent: K.StatementKind[],
  ...
} & Omit<Node, 'type'>

export type ReturnStatement = {
  type: 'ReturnStatement',
  argument: K.ExpressionKind | null,
  ...
} & Omit<Statement, 'type'>

export type ThrowStatement = {
  type: 'ThrowStatement',
  argument: K.ExpressionKind,
  ...
} & Omit<Statement, 'type'>

export type TryStatement = {
  type: 'TryStatement',
  block: K.BlockStatementKind,
  handler?: K.CatchClauseKind | null,
  handlers?: K.CatchClauseKind[],
  guardedHandlers?: K.CatchClauseKind[],
  finalizer?: K.BlockStatementKind | null,
  ...
} & Omit<Statement, 'type'>

export type CatchClause = {
  type: 'CatchClause',
  param?: K.PatternKind | null,
  guard?: K.ExpressionKind | null,
  body: K.BlockStatementKind,
  ...
} & Omit<Node, 'type'>

export type WhileStatement = {
  type: 'WhileStatement',
  test: K.ExpressionKind,
  body: K.StatementKind,
  ...
} & Omit<Statement, 'type'>

export type DoWhileStatement = {
  type: 'DoWhileStatement',
  body: K.StatementKind,
  test: K.ExpressionKind,
  ...
} & Omit<Statement, 'type'>

export type ForStatement = {
  type: 'ForStatement',
  init: K.VariableDeclarationKind | K.ExpressionKind | null,
  test: K.ExpressionKind | null,
  update: K.ExpressionKind | null,
  body: K.StatementKind,
  ...
} & Omit<Statement, 'type'>

export type Declaration = {...} & Statement

export type VariableDeclaration = {
  type: 'VariableDeclaration',
  kind: 'var' | 'let' | 'const',
  declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[],
  ...
} & Omit<Declaration, 'type'>

export type ForInStatement = {
  type: 'ForInStatement',
  left: K.VariableDeclarationKind | K.ExpressionKind,
  right: K.ExpressionKind,
  body: K.StatementKind,
  ...
} & Omit<Statement, 'type'>

export type DebuggerStatement = {
  type: 'DebuggerStatement',
  ...
} & Omit<Statement, 'type'>

export type FunctionDeclaration = {
  type: 'FunctionDeclaration',
  id: K.IdentifierKind,
  ...
} & Omit<Function, 'type' | 'id'> &
  Omit<Declaration, 'type'>

export type FunctionExpression = {
  type: 'FunctionExpression',
  ...
} & Omit<Function, 'type'> &
  Omit<Expression, 'type'>

export type VariableDeclarator = {
  type: 'VariableDeclarator',
  id: K.PatternKind,
  init?: K.ExpressionKind | null,
  ...
} & Omit<Node, 'type'>

export type ThisExpression = {
  type: 'ThisExpression',
  ...
} & Omit<Expression, 'type'>

export type ArrayExpression = {
  type: 'ArrayExpression',
  elements: (
    | K.ExpressionKind
    | K.SpreadElementKind
    | K.RestElementKind
    | null
  )[],
  ...
} & Omit<Expression, 'type'>

export type ObjectExpression = {
  type: 'ObjectExpression',
  properties: (
    | K.PropertyKind
    | K.ObjectMethodKind
    | K.ObjectPropertyKind
    | K.SpreadPropertyKind
    | K.SpreadElementKind
  )[],
  ...
} & Omit<Expression, 'type'>

export type Property = {
  type: 'Property',
  kind: 'init' | 'get' | 'set',
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
  value: K.ExpressionKind | K.PatternKind,
  method?: boolean,
  shorthand?: boolean,
  computed?: boolean,
  decorators?: K.DecoratorKind[] | null,
  ...
} & Omit<Node, 'type'>

export type Literal = {
  type: 'Literal',
  value: string | boolean | null | number | RegExp,
  regex?: {
    pattern: string,
    flags: string,
    ...
  } | null,
  ...
} & Omit<Expression, 'type'>

export type SequenceExpression = {
  type: 'SequenceExpression',
  expressions: K.ExpressionKind[],
  ...
} & Omit<Expression, 'type'>

export type UnaryExpression = {
  type: 'UnaryExpression',
  operator: '-' | '+' | '!' | '~' | 'typeof' | 'void' | 'delete',
  argument: K.ExpressionKind,
  prefix?: boolean,
  ...
} & Omit<Expression, 'type'>

export type BinaryExpression = {
  type: 'BinaryExpression',
  operator:
    | '=='
    | '!='
    | '==='
    | '!=='
    | '<'
    | '<='
    | '>'
    | '>='
    | '<<'
    | '>>'
    | '>>>'
    | '+'
    | '-'
    | '*'
    | '/'
    | '%'
    | '**'
    | '&'
    | '|'
    | '^'
    | 'in'
    | 'instanceof',
  left: K.ExpressionKind,
  right: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>

export type AssignmentExpression = {
  type: 'AssignmentExpression',
  operator:
    | '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '<<='
    | '>>='
    | '>>>='
    | '|='
    | '^='
    | '&=',
  left: K.PatternKind | K.MemberExpressionKind,
  right: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>

export type MemberExpression = {
  type: 'MemberExpression',
  object: K.ExpressionKind,
  property: K.IdentifierKind | K.ExpressionKind,
  computed?: boolean,
  ...
} & Omit<Expression, 'type'>

export type UpdateExpression = {
  type: 'UpdateExpression',
  operator: '++' | '--',
  argument: K.ExpressionKind,
  prefix: boolean,
  ...
} & Omit<Expression, 'type'>

export type LogicalExpression = {
  type: 'LogicalExpression',
  operator: '||' | '&&' | '??',
  left: K.ExpressionKind,
  right: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>

export type ConditionalExpression = {
  type: 'ConditionalExpression',
  test: K.ExpressionKind,
  consequent: K.ExpressionKind,
  alternate: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>

export type NewExpression = {
  type: 'NewExpression',
  callee: K.ExpressionKind,
  arguments: (K.ExpressionKind | K.SpreadElementKind)[],
  ...
} & Omit<Expression, 'type'>

export type CallExpression = {
  type: 'CallExpression',
  callee: K.ExpressionKind,
  arguments: (K.ExpressionKind | K.SpreadElementKind)[],
  ...
} & Omit<Expression, 'type'>

export type RestElement = {
  type: 'RestElement',
  argument: K.PatternKind,
  typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null,
  ...
} & Omit<Pattern, 'type'>

export type TypeAnnotation = {
  type: 'TypeAnnotation',
  typeAnnotation: K.FlowTypeKind,
  ...
} & Omit<Node, 'type'>

export type TSTypeAnnotation = {
  type: 'TSTypeAnnotation',
  typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind,
  ...
} & Omit<Node, 'type'>

export type SpreadElementPattern = {
  type: 'SpreadElementPattern',
  argument: K.PatternKind,
  ...
} & Omit<Pattern, 'type'>

export type ArrowFunctionExpression = {
  type: 'ArrowFunctionExpression',
  id?: null,
  body: K.BlockStatementKind | K.ExpressionKind,
  generator?: false,
  ...
} & Omit<Function, 'type' | 'id' | 'body' | 'generator'> &
  Omit<Expression, 'type'>

export type ForOfStatement = {
  type: 'ForOfStatement',
  left: K.VariableDeclarationKind | K.PatternKind,
  right: K.ExpressionKind,
  body: K.StatementKind,
  ...
} & Omit<Statement, 'type'>

export type YieldExpression = {
  type: 'YieldExpression',
  argument: K.ExpressionKind | null,
  delegate?: boolean,
  ...
} & Omit<Expression, 'type'>

export type GeneratorExpression = {
  type: 'GeneratorExpression',
  body: K.ExpressionKind,
  blocks: K.ComprehensionBlockKind[],
  filter: K.ExpressionKind | null,
  ...
} & Omit<Expression, 'type'>

export type ComprehensionBlock = {
  type: 'ComprehensionBlock',
  left: K.PatternKind,
  right: K.ExpressionKind,
  each: boolean,
  ...
} & Omit<Node, 'type'>

export type ComprehensionExpression = {
  type: 'ComprehensionExpression',
  body: K.ExpressionKind,
  blocks: K.ComprehensionBlockKind[],
  filter: K.ExpressionKind | null,
  ...
} & Omit<Expression, 'type'>

export type ObjectProperty = {
  shorthand?: boolean,
  type: 'ObjectProperty',
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
  value: K.ExpressionKind | K.PatternKind,
  accessibility?: K.LiteralKind | null,
  computed?: boolean,
  ...
} & Omit<Node, 'type'>

export type PropertyPattern = {
  type: 'PropertyPattern',
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
  pattern: K.PatternKind,
  computed?: boolean,
  ...
} & Omit<Pattern, 'type'>

export type ObjectPattern = {
  type: 'ObjectPattern',
  properties: (
    | K.PropertyKind
    | K.PropertyPatternKind
    | K.SpreadPropertyPatternKind
    | K.SpreadPropertyKind
    | K.ObjectPropertyKind
    | K.RestPropertyKind
  )[],
  typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null,
  decorators?: K.DecoratorKind[] | null,
  ...
} & Omit<Pattern, 'type'>

export type ArrayPattern = {
  type: 'ArrayPattern',
  elements: (K.PatternKind | K.SpreadElementKind | null)[],
  ...
} & Omit<Pattern, 'type'>

export type MethodDefinition = {
  type: 'MethodDefinition',
  kind: 'constructor' | 'method' | 'get' | 'set',
  key: K.ExpressionKind,
  value: K.FunctionKind,
  computed?: boolean,
  static?: boolean,
  decorators?: K.DecoratorKind[] | null,
  ...
} & Omit<Declaration, 'type'>

export type SpreadElement = {
  type: 'SpreadElement',
  argument: K.ExpressionKind,
  ...
} & Omit<Node, 'type'>

export type AssignmentPattern = {
  type: 'AssignmentPattern',
  left: K.PatternKind,
  right: K.ExpressionKind,
  ...
} & Omit<Pattern, 'type'>

export type ClassPropertyDefinition = {
  type: 'ClassPropertyDefinition',
  definition:
    | K.MethodDefinitionKind
    | K.VariableDeclaratorKind
    | K.ClassPropertyDefinitionKind
    | K.ClassPropertyKind,
  ...
} & Omit<Declaration, 'type'>

export type ClassProperty = {
  type: 'ClassProperty',
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
  computed?: boolean,
  value: K.ExpressionKind | null,
  static?: boolean,
  typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null,
  variance?: K.VarianceKind | 'plus' | 'minus' | null,
  access?: 'public' | 'private' | 'protected' | void,
  ...
} & Omit<Declaration, 'type'>

export type ClassBody = {
  type: 'ClassBody',
  body: (
    | K.MethodDefinitionKind
    | K.VariableDeclaratorKind
    | K.ClassPropertyDefinitionKind
    | K.ClassPropertyKind
    | K.ClassPrivatePropertyKind
    | K.ClassMethodKind
    | K.ClassPrivateMethodKind
    | K.TSDeclareMethodKind
    | K.TSCallSignatureDeclarationKind
    | K.TSConstructSignatureDeclarationKind
    | K.TSIndexSignatureKind
    | K.TSMethodSignatureKind
    | K.TSPropertySignatureKind
  )[],
  ...
} & Omit<Declaration, 'type'>

export type ClassDeclaration = {
  type: 'ClassDeclaration',
  id: K.IdentifierKind | null,
  body: K.ClassBodyKind,
  superClass?: K.ExpressionKind | null,
  typeParameters?:
    | K.TypeParameterDeclarationKind
    | K.TSTypeParameterDeclarationKind
    | null,
  superTypeParameters?:
    | K.TypeParameterInstantiationKind
    | K.TSTypeParameterInstantiationKind
    | null,
  implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[],
  ...
} & Omit<Declaration, 'type'>

export type ClassExpression = {
  type: 'ClassExpression',
  id?: K.IdentifierKind | null,
  body: K.ClassBodyKind,
  superClass?: K.ExpressionKind | null,
  typeParameters?:
    | K.TypeParameterDeclarationKind
    | K.TSTypeParameterDeclarationKind
    | null,
  superTypeParameters?:
    | K.TypeParameterInstantiationKind
    | K.TSTypeParameterInstantiationKind
    | null,
  implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[],
  ...
} & Omit<Expression, 'type'>

export type Specifier = {...} & Node

export type ModuleSpecifier = {
  local?: K.IdentifierKind | null,
  id?: K.IdentifierKind | null,
  name?: K.IdentifierKind | null,
  ...
} & Specifier

export type ImportSpecifier = {
  type: 'ImportSpecifier',
  imported: K.IdentifierKind,
  ...
} & Omit<ModuleSpecifier, 'type'>

export type ImportNamespaceSpecifier = {
  type: 'ImportNamespaceSpecifier',
  ...
} & Omit<ModuleSpecifier, 'type'>

export type ImportDefaultSpecifier = {
  type: 'ImportDefaultSpecifier',
  ...
} & Omit<ModuleSpecifier, 'type'>

export type ImportDeclaration = {
  type: 'ImportDeclaration',
  specifiers?: (
    | K.ImportSpecifierKind
    | K.ImportNamespaceSpecifierKind
    | K.ImportDefaultSpecifierKind
  )[],
  source: K.LiteralKind,
  importKind?: 'value' | 'type',
  ...
} & Omit<Declaration, 'type'>

export type TaggedTemplateExpression = {
  type: 'TaggedTemplateExpression',
  tag: K.ExpressionKind,
  quasi: K.TemplateLiteralKind,
  ...
} & Omit<Expression, 'type'>

export type TemplateLiteral = {
  type: 'TemplateLiteral',
  quasis: K.TemplateElementKind[],
  expressions: K.ExpressionKind[],
  ...
} & Omit<Expression, 'type'>

export type TemplateElement = {
  type: 'TemplateElement',
  value: {
    cooked: string,
    raw: string,
    ...
  },
  tail: boolean,
  ...
} & Omit<Node, 'type'>

export type SpreadProperty = {
  type: 'SpreadProperty',
  argument: K.ExpressionKind,
  ...
} & Omit<Node, 'type'>

export type SpreadPropertyPattern = {
  type: 'SpreadPropertyPattern',
  argument: K.PatternKind,
  ...
} & Omit<Pattern, 'type'>

export type AwaitExpression = {
  type: 'AwaitExpression',
  argument: K.ExpressionKind | null,
  all?: boolean,
  ...
} & Omit<Expression, 'type'>

export type JSXAttribute = {
  type: 'JSXAttribute',
  name: K.JSXIdentifierKind | K.JSXNamespacedNameKind,
  value?: K.LiteralKind | K.JSXExpressionContainerKind | null,
  ...
} & Omit<Node, 'type'>

export type JSXIdentifier = {
  type: 'JSXIdentifier',
  name: string,
  ...
} & Omit<Identifier, 'type' | 'name'>

export type JSXNamespacedName = {
  type: 'JSXNamespacedName',
  namespace: K.JSXIdentifierKind,
  name: K.JSXIdentifierKind,
  ...
} & Omit<Node, 'type'>

export type JSXExpressionContainer = {
  type: 'JSXExpressionContainer',
  expression: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>

export type JSXMemberExpression = {
  type: 'JSXMemberExpression',
  object: K.JSXIdentifierKind | K.JSXMemberExpressionKind,
  property: K.JSXIdentifierKind,
  computed?: boolean,
  ...
} & Omit<
  MemberExpression,
  'type' | 'object' | 'property' | 'computed',
>

export type JSXSpreadAttribute = {
  type: 'JSXSpreadAttribute',
  argument: K.ExpressionKind,
  ...
} & Omit<Node, 'type'>

export type JSXElement = {
  type: 'JSXElement',
  openingElement: K.JSXOpeningElementKind,
  closingElement?: K.JSXClosingElementKind | null,
  children?: (
    | K.JSXElementKind
    | K.JSXExpressionContainerKind
    | K.JSXFragmentKind
    | K.JSXTextKind
    | K.LiteralKind
  )[],
  name?:
    | K.JSXIdentifierKind
    | K.JSXNamespacedNameKind
    | K.JSXMemberExpressionKind,
  selfClosing?: boolean,
  attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[],
  ...
} & Omit<Expression, 'type'>

export type JSXOpeningElement = {
  type: 'JSXOpeningElement',
  name:
    | K.JSXIdentifierKind
    | K.JSXNamespacedNameKind
    | K.JSXMemberExpressionKind,
  attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[],
  selfClosing?: boolean,
  ...
} & Omit<Node, 'type'>

export type JSXClosingElement = {
  type: 'JSXClosingElement',
  name:
    | K.JSXIdentifierKind
    | K.JSXNamespacedNameKind
    | K.JSXMemberExpressionKind,
  ...
} & Omit<Node, 'type'>

export type JSXFragment = {
  type: 'JSXFragment',
  openingElement: K.JSXOpeningFragmentKind,
  closingElement: K.JSXClosingFragmentKind,
  children?: (
    | K.JSXElementKind
    | K.JSXExpressionContainerKind
    | K.JSXFragmentKind
    | K.JSXTextKind
    | K.LiteralKind
  )[],
  ...
} & Omit<Expression, 'type'>

export type JSXText = {
  type: 'JSXText',
  value: string,
  ...
} & Omit<Literal, 'type' | 'value'>

export type JSXOpeningFragment = {
  type: 'JSXOpeningFragment',
  ...
} & Omit<Node, 'type'>

export type JSXClosingFragment = {
  type: 'JSXClosingFragment',
  ...
} & Omit<Node, 'type'>

export type JSXEmptyExpression = {
  type: 'JSXEmptyExpression',
  ...
} & Omit<Expression, 'type'>

export type JSXSpreadChild = {
  type: 'JSXSpreadChild',
  expression: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>

export type TypeParameterDeclaration = {
  type: 'TypeParameterDeclaration',
  params: K.TypeParameterKind[],
  ...
} & Omit<Node, 'type'>

export type TSTypeParameterDeclaration = {
  type: 'TSTypeParameterDeclaration',
  params: K.TSTypeParameterKind[],
  ...
} & Omit<Declaration, 'type'>

export type TypeParameterInstantiation = {
  type: 'TypeParameterInstantiation',
  params: K.FlowTypeKind[],
  ...
} & Omit<Node, 'type'>

export type TSTypeParameterInstantiation = {
  type: 'TSTypeParameterInstantiation',
  params: K.TSTypeKind[],
  ...
} & Omit<Node, 'type'>

export type ClassImplements = {
  type: 'ClassImplements',
  id: K.IdentifierKind,
  superClass?: K.ExpressionKind | null,
  typeParameters?: K.TypeParameterInstantiationKind | null,
  ...
} & Omit<Node, 'type'>

export type TSType = {...} & Node

export interface TSHasOptionalTypeParameterInstantiation {
  typeParameters?: K.TSTypeParameterInstantiationKind | null;
}

export type TSExpressionWithTypeArguments = {
  type: 'TSExpressionWithTypeArguments',
  expression: K.IdentifierKind | K.TSQualifiedNameKind,
  ...
} & Omit<TSType, 'type'> &
  TSHasOptionalTypeParameterInstantiation

export type Flow = {...} & Node

export type FlowType = {...} & Flow

export type AnyTypeAnnotation = {
  type: 'AnyTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>

export type EmptyTypeAnnotation = {
  type: 'EmptyTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>

export type MixedTypeAnnotation = {
  type: 'MixedTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>

export type VoidTypeAnnotation = {
  type: 'VoidTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>

export type NumberTypeAnnotation = {
  type: 'NumberTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>

export type NumberLiteralTypeAnnotation = {
  type: 'NumberLiteralTypeAnnotation',
  value: number,
  raw: string,
  ...
} & Omit<FlowType, 'type'>

export type NumericLiteralTypeAnnotation = {
  type: 'NumericLiteralTypeAnnotation',
  value: number,
  raw: string,
  ...
} & Omit<FlowType, 'type'>

export type StringTypeAnnotation = {
  type: 'StringTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>

export type StringLiteralTypeAnnotation = {
  type: 'StringLiteralTypeAnnotation',
  value: string,
  raw: string,
  ...
} & Omit<FlowType, 'type'>

export type BooleanTypeAnnotation = {
  type: 'BooleanTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>

export type BooleanLiteralTypeAnnotation = {
  type: 'BooleanLiteralTypeAnnotation',
  value: boolean,
  raw: string,
  ...
} & Omit<FlowType, 'type'>

export type NullableTypeAnnotation = {
  type: 'NullableTypeAnnotation',
  typeAnnotation: K.FlowTypeKind,
  ...
} & Omit<FlowType, 'type'>

export type NullLiteralTypeAnnotation = {
  type: 'NullLiteralTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>

export type NullTypeAnnotation = {
  type: 'NullTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>

export type ThisTypeAnnotation = {
  type: 'ThisTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>

export type ExistsTypeAnnotation = {
  type: 'ExistsTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>

export type ExistentialTypeParam = {
  type: 'ExistentialTypeParam',
  ...
} & Omit<FlowType, 'type'>

export type FunctionTypeAnnotation = {
  type: 'FunctionTypeAnnotation',
  params: K.FunctionTypeParamKind[],
  returnType: K.FlowTypeKind,
  rest: K.FunctionTypeParamKind | null,
  typeParameters: K.TypeParameterDeclarationKind | null,
  ...
} & Omit<FlowType, 'type'>

export type FunctionTypeParam = {
  type: 'FunctionTypeParam',
  name: K.IdentifierKind,
  typeAnnotation: K.FlowTypeKind,
  optional: boolean,
  ...
} & Omit<Node, 'type'>

export type ArrayTypeAnnotation = {
  type: 'ArrayTypeAnnotation',
  elementType: K.FlowTypeKind,
  ...
} & Omit<FlowType, 'type'>

export type ObjectTypeAnnotation = {
  type: 'ObjectTypeAnnotation',
  properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[],
  indexers?: K.ObjectTypeIndexerKind[],
  callProperties?: K.ObjectTypeCallPropertyKind[],
  inexact?: boolean | void,
  exact?: boolean,
  internalSlots?: K.ObjectTypeInternalSlotKind[],
  ...
} & Omit<FlowType, 'type'>

export type ObjectTypeProperty = {
  type: 'ObjectTypeProperty',
  key: K.LiteralKind | K.IdentifierKind,
  value: K.FlowTypeKind,
  optional: boolean,
  variance?: K.VarianceKind | 'plus' | 'minus' | null,
  ...
} & Omit<Node, 'type'>

export type ObjectTypeSpreadProperty = {
  type: 'ObjectTypeSpreadProperty',
  argument: K.FlowTypeKind,
  ...
} & Omit<Node, 'type'>

export type ObjectTypeIndexer = {
  type: 'ObjectTypeIndexer',
  id: K.IdentifierKind,
  key: K.FlowTypeKind,
  value: K.FlowTypeKind,
  variance?: K.VarianceKind | 'plus' | 'minus' | null,
  ...
} & Omit<Node, 'type'>

export type ObjectTypeCallProperty = {
  type: 'ObjectTypeCallProperty',
  value: K.FunctionTypeAnnotationKind,
  static?: boolean,
  ...
} & Omit<Node, 'type'>

export type ObjectTypeInternalSlot = {
  type: 'ObjectTypeInternalSlot',
  id: K.IdentifierKind,
  value: K.FlowTypeKind,
  optional: boolean,
  static: boolean,
  method: boolean,
  ...
} & Omit<Node, 'type'>

export type Variance = {
  type: 'Variance',
  kind: 'plus' | 'minus',
  ...
} & Omit<Node, 'type'>

export type QualifiedTypeIdentifier = {
  type: 'QualifiedTypeIdentifier',
  qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind,
  id: K.IdentifierKind,
  ...
} & Omit<Node, 'type'>

export type GenericTypeAnnotation = {
  type: 'GenericTypeAnnotation',
  id: K.IdentifierKind | K.QualifiedTypeIdentifierKind,
  typeParameters: K.TypeParameterInstantiationKind | null,
  ...
} & Omit<FlowType, 'type'>

export type MemberTypeAnnotation = {
  type: 'MemberTypeAnnotation',
  object: K.IdentifierKind,
  property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind,
  ...
} & Omit<FlowType, 'type'>

export type UnionTypeAnnotation = {
  type: 'UnionTypeAnnotation',
  types: K.FlowTypeKind[],
  ...
} & Omit<FlowType, 'type'>

export type IntersectionTypeAnnotation = {
  type: 'IntersectionTypeAnnotation',
  types: K.FlowTypeKind[],
  ...
} & Omit<FlowType, 'type'>

export type TypeofTypeAnnotation = {
  type: 'TypeofTypeAnnotation',
  argument: K.FlowTypeKind,
  ...
} & Omit<FlowType, 'type'>

export type TypeParameter = {
  type: 'TypeParameter',
  name: string,
  variance?: K.VarianceKind | 'plus' | 'minus' | null,
  bound?: K.TypeAnnotationKind | null,
  ...
} & Omit<FlowType, 'type'>

export type InterfaceTypeAnnotation = {
  type: 'InterfaceTypeAnnotation',
  body: K.ObjectTypeAnnotationKind,
  extends?: K.InterfaceExtendsKind[] | null,
  ...
} & Omit<FlowType, 'type'>

export type InterfaceExtends = {
  type: 'InterfaceExtends',
  id: K.IdentifierKind,
  typeParameters?: K.TypeParameterInstantiationKind | null,
  ...
} & Omit<Node, 'type'>

export type InterfaceDeclaration = {
  type: 'InterfaceDeclaration',
  id: K.IdentifierKind,
  typeParameters?: K.TypeParameterDeclarationKind | null,
  body: K.ObjectTypeAnnotationKind,
  extends: K.InterfaceExtendsKind[],
  ...
} & Omit<Declaration, 'type'>

export type DeclareInterface = {
  type: 'DeclareInterface',
  ...
} & Omit<InterfaceDeclaration, 'type'>

export type TypeAlias = {
  type: 'TypeAlias',
  id: K.IdentifierKind,
  typeParameters: K.TypeParameterDeclarationKind | null,
  right: K.FlowTypeKind,
  ...
} & Omit<Declaration, 'type'>

export type OpaqueType = {
  type: 'OpaqueType',
  id: K.IdentifierKind,
  typeParameters: K.TypeParameterDeclarationKind | null,
  impltype: K.FlowTypeKind,
  supertype: K.FlowTypeKind,
  ...
} & Omit<Declaration, 'type'>

export type DeclareTypeAlias = {
  type: 'DeclareTypeAlias',
  ...
} & Omit<TypeAlias, 'type'>

export type DeclareOpaqueType = {
  type: 'DeclareOpaqueType',
  ...
} & Omit<TypeAlias, 'type'>

export type TypeCastExpression = {
  type: 'TypeCastExpression',
  expression: K.ExpressionKind,
  typeAnnotation: K.TypeAnnotationKind,
  ...
} & Omit<Expression, 'type'>

export type TupleTypeAnnotation = {
  type: 'TupleTypeAnnotation',
  types: K.FlowTypeKind[],
  ...
} & Omit<FlowType, 'type'>

export type DeclareVariable = {
  type: 'DeclareVariable',
  id: K.IdentifierKind,
  ...
} & Omit<Statement, 'type'>

export type DeclareFunction = {
  type: 'DeclareFunction',
  id: K.IdentifierKind,
  ...
} & Omit<Statement, 'type'>

export type DeclareClass = {
  type: 'DeclareClass',
  ...
} & Omit<InterfaceDeclaration, 'type'>

export type DeclareModule = {
  type: 'DeclareModule',
  id: K.IdentifierKind | K.LiteralKind,
  body: K.BlockStatementKind,
  ...
} & Omit<Statement, 'type'>

export type DeclareModuleExports = {
  type: 'DeclareModuleExports',
  typeAnnotation: K.TypeAnnotationKind,
  ...
} & Omit<Statement, 'type'>

export type DeclareExportDeclaration = {
  type: 'DeclareExportDeclaration',
  default: boolean,
  declaration:
    | K.DeclareVariableKind
    | K.DeclareFunctionKind
    | K.DeclareClassKind
    | K.FlowTypeKind
    | null,
  specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[],
  source?: K.LiteralKind | null,
  ...
} & Omit<Declaration, 'type'>

export type ExportSpecifier = {
  type: 'ExportSpecifier',
  exported: K.IdentifierKind,
  ...
} & Omit<ModuleSpecifier, 'type'>

export type ExportBatchSpecifier = {
  type: 'ExportBatchSpecifier',
  ...
} & Omit<Specifier, 'type'>

export type DeclareExportAllDeclaration = {
  type: 'DeclareExportAllDeclaration',
  source?: K.LiteralKind | null,
  ...
} & Omit<Declaration, 'type'>

export type FlowPredicate = {...} & Flow

export type InferredPredicate = {
  type: 'InferredPredicate',
  ...
} & Omit<FlowPredicate, 'type'>

export type DeclaredPredicate = {
  type: 'DeclaredPredicate',
  value: K.ExpressionKind,
  ...
} & Omit<FlowPredicate, 'type'>

export type ExportDeclaration = {
  type: 'ExportDeclaration',
  default: boolean,
  declaration: K.DeclarationKind | K.ExpressionKind | null,
  specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[],
  source?: K.LiteralKind | null,
  ...
} & Omit<Declaration, 'type'>

export type Block = {
  type: 'Block',
  ...
} & Comment

export type Line = {
  type: 'Line',
  ...
} & Comment

export type Noop = {
  type: 'Noop',
  ...
} & Omit<Statement, 'type'>

export type DoExpression = {
  type: 'DoExpression',
  body: K.StatementKind[],
  ...
} & Omit<Expression, 'type'>

export type Super = {
  type: 'Super',
  ...
} & Omit<Expression, 'type'>

export type BindExpression = {
  type: 'BindExpression',
  object: K.ExpressionKind | null,
  callee: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>

export type Decorator = {
  type: 'Decorator',
  expression: K.ExpressionKind,
  ...
} & Omit<Node, 'type'>

export type MetaProperty = {
  type: 'MetaProperty',
  meta: K.IdentifierKind,
  property: K.IdentifierKind,
  ...
} & Omit<Expression, 'type'>

export type ParenthesizedExpression = {
  type: 'ParenthesizedExpression',
  expression: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>

export type ExportDefaultDeclaration = {
  type: 'ExportDefaultDeclaration',
  declaration: K.DeclarationKind | K.ExpressionKind,
  ...
} & Omit<Declaration, 'type'>

export type ExportNamedDeclaration = {
  type: 'ExportNamedDeclaration',
  declaration: K.DeclarationKind | null,
  specifiers?: K.ExportSpecifierKind[],
  source?: K.LiteralKind | null,
  ...
} & Omit<Declaration, 'type'>

export type ExportNamespaceSpecifier = {
  type: 'ExportNamespaceSpecifier',
  exported: K.IdentifierKind,
  ...
} & Omit<Specifier, 'type'>

export type ExportDefaultSpecifier = {
  type: 'ExportDefaultSpecifier',
  exported: K.IdentifierKind,
  ...
} & Omit<Specifier, 'type'>

export type ExportAllDeclaration = {
  type: 'ExportAllDeclaration',
  exported: K.IdentifierKind | null,
  source: K.LiteralKind,
  ...
} & Omit<Declaration, 'type'>

export type CommentBlock = {
  type: 'CommentBlock',
  ...
} & Comment

export type CommentLine = {
  type: 'CommentLine',
  ...
} & Comment

export type Directive = {
  type: 'Directive',
  value: K.DirectiveLiteralKind,
  ...
} & Omit<Node, 'type'>

export type DirectiveLiteral = {
  type: 'DirectiveLiteral',
  value?: string,
  ...
} & Omit<Node, 'type'> &
  Omit<Expression, 'type'>

export type InterpreterDirective = {
  type: 'InterpreterDirective',
  value: string,
  ...
} & Omit<Node, 'type'>

export type StringLiteral = {
  type: 'StringLiteral',
  value: string,
  ...
} & Omit<Literal, 'type' | 'value'>

export type NumericLiteral = {
  type: 'NumericLiteral',
  value: number,
  raw?: string | null,
  extra?: {
    rawValue: number,
    raw: string,
    ...
  },
  ...
} & Omit<Literal, 'type' | 'value'>

export type BigIntLiteral = {
  type: 'BigIntLiteral',
  value: string | number,
  extra?: {
    rawValue: string,
    raw: string,
    ...
  },
  ...
} & Omit<Literal, 'type' | 'value'>

export type NullLiteral = {
  type: 'NullLiteral',
  value?: null,
  ...
} & Omit<Literal, 'type' | 'value'>

export type BooleanLiteral = {
  type: 'BooleanLiteral',
  value: boolean,
  ...
} & Omit<Literal, 'type' | 'value'>

export type RegExpLiteral = {
  type: 'RegExpLiteral',
  pattern: string,
  flags: string,
  value?: RegExp,
  ...
} & Omit<Literal, 'type' | 'value'>

export type ObjectMethod = {
  type: 'ObjectMethod',
  kind: 'method' | 'get' | 'set',
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
  params: K.PatternKind[],
  body: K.BlockStatementKind,
  computed?: boolean,
  generator?: boolean,
  async?: boolean,
  accessibility?: K.LiteralKind | null,
  decorators?: K.DecoratorKind[] | null,
  ...
} & Omit<Node, 'type'> &
  Omit<Function, 'type' | 'params' | 'body' | 'generator' | 'async'>

export type ClassPrivateProperty = {
  type: 'ClassPrivateProperty',
  key: K.PrivateNameKind,
  value?: K.ExpressionKind | null,
  ...
} & Omit<ClassProperty, 'type' | 'key' | 'value'>

export type ClassMethod = {
  type: 'ClassMethod',
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
  kind?: 'get' | 'set' | 'method' | 'constructor',
  body: K.BlockStatementKind,
  computed?: boolean,
  static?: boolean | null,
  abstract?: boolean | null,
  access?: 'public' | 'private' | 'protected' | null,
  accessibility?: 'public' | 'private' | 'protected' | null,
  decorators?: K.DecoratorKind[] | null,
  optional?: boolean | null,
  ...
} & Omit<Declaration, 'type'> &
  Omit<Function, 'type' | 'body'>

export type ClassPrivateMethod = {
  type: 'ClassPrivateMethod',
  key: K.PrivateNameKind,
  kind?: 'get' | 'set' | 'method' | 'constructor',
  body: K.BlockStatementKind,
  computed?: boolean,
  static?: boolean | null,
  abstract?: boolean | null,
  access?: 'public' | 'private' | 'protected' | null,
  accessibility?: 'public' | 'private' | 'protected' | null,
  decorators?: K.DecoratorKind[] | null,
  optional?: boolean | null,
  ...
} & Omit<Declaration, 'type'> &
  Omit<Function, 'type' | 'body'>

export type PrivateName = {
  type: 'PrivateName',
  id: K.IdentifierKind,
  ...
} & Omit<Expression, 'type'> &
  Omit<Pattern, 'type'>

export type RestProperty = {
  type: 'RestProperty',
  argument: K.ExpressionKind,
  ...
} & Omit<Node, 'type'>

export type ForAwaitStatement = {
  type: 'ForAwaitStatement',
  left: K.VariableDeclarationKind | K.ExpressionKind,
  right: K.ExpressionKind,
  body: K.StatementKind,
  ...
} & Omit<Statement, 'type'>

export type Import = {
  type: 'Import',
  ...
} & Omit<Expression, 'type'>

export type TSQualifiedName = {
  type: 'TSQualifiedName',
  left: K.IdentifierKind | K.TSQualifiedNameKind,
  right: K.IdentifierKind | K.TSQualifiedNameKind,
  ...
} & Omit<Node, 'type'>

export type TSTypeReference = {
  type: 'TSTypeReference',
  typeName: K.IdentifierKind | K.TSQualifiedNameKind,
  ...
} & Omit<TSType, 'type'> &
  TSHasOptionalTypeParameterInstantiation

export interface TSHasOptionalTypeParameters {
  typeParameters?: K.TSTypeParameterDeclarationKind | null | void;
}

export interface TSHasOptionalTypeAnnotation {
  typeAnnotation?: K.TSTypeAnnotationKind | null;
}

export type TSAsExpression = {
  type: 'TSAsExpression',
  expression: K.ExpressionKind,
  typeAnnotation: K.TSTypeKind,
  extra?: {
    parenthesized: boolean,
    ...
  } | null,
  ...
} & Omit<Expression, 'type'> &
  Omit<Pattern, 'type'>

export type TSNonNullExpression = {
  type: 'TSNonNullExpression',
  expression: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'> &
  Omit<Pattern, 'type'>

export type TSAnyKeyword = {
  type: 'TSAnyKeyword',
  ...
} & Omit<TSType, 'type'>

export type TSBigIntKeyword = {
  type: 'TSBigIntKeyword',
  ...
} & Omit<TSType, 'type'>

export type TSBooleanKeyword = {
  type: 'TSBooleanKeyword',
  ...
} & Omit<TSType, 'type'>

export type TSNeverKeyword = {
  type: 'TSNeverKeyword',
  ...
} & Omit<TSType, 'type'>

export type TSNullKeyword = {
  type: 'TSNullKeyword',
  ...
} & Omit<TSType, 'type'>

export type TSNumberKeyword = {
  type: 'TSNumberKeyword',
  ...
} & Omit<TSType, 'type'>

export type TSObjectKeyword = {
  type: 'TSObjectKeyword',
  ...
} & Omit<TSType, 'type'>

export type TSStringKeyword = {
  type: 'TSStringKeyword',
  ...
} & Omit<TSType, 'type'>

export type TSSymbolKeyword = {
  type: 'TSSymbolKeyword',
  ...
} & Omit<TSType, 'type'>

export type TSUndefinedKeyword = {
  type: 'TSUndefinedKeyword',
  ...
} & Omit<TSType, 'type'>

export type TSUnknownKeyword = {
  type: 'TSUnknownKeyword',
  ...
} & Omit<TSType, 'type'>

export type TSVoidKeyword = {
  type: 'TSVoidKeyword',
  ...
} & Omit<TSType, 'type'>

export type TSThisType = {
  type: 'TSThisType',
  ...
} & Omit<TSType, 'type'>

export type TSArrayType = {
  type: 'TSArrayType',
  elementType: K.TSTypeKind,
  ...
} & Omit<TSType, 'type'>

export type TSLiteralType = {
  type: 'TSLiteralType',
  literal:
    | K.NumericLiteralKind
    | K.StringLiteralKind
    | K.BooleanLiteralKind
    | K.TemplateLiteralKind
    | K.UnaryExpressionKind,
  ...
} & Omit<TSType, 'type'>

export type TSUnionType = {
  type: 'TSUnionType',
  types: K.TSTypeKind[],
  ...
} & Omit<TSType, 'type'>

export type TSIntersectionType = {
  type: 'TSIntersectionType',
  types: K.TSTypeKind[],
  ...
} & Omit<TSType, 'type'>

export type TSConditionalType = {
  type: 'TSConditionalType',
  checkType: K.TSTypeKind,
  extendsType: K.TSTypeKind,
  trueType: K.TSTypeKind,
  falseType: K.TSTypeKind,
  ...
} & Omit<TSType, 'type'>

export type TSInferType = {
  type: 'TSInferType',
  typeParameter: K.TSTypeParameterKind,
  ...
} & Omit<TSType, 'type'>

export type TSTypeParameter = {
  type: 'TSTypeParameter',
  name: string,
  constraint?: K.TSTypeKind | void,
  default?: K.TSTypeKind | void,
  ...
} & Omit<Identifier, 'type' | 'name'>

export type TSParenthesizedType = {
  type: 'TSParenthesizedType',
  typeAnnotation: K.TSTypeKind,
  ...
} & Omit<TSType, 'type'>

export type TSFunctionType = {
  type: 'TSFunctionType',
  parameters: (
    | K.IdentifierKind
    | K.RestElementKind
    | K.ArrayPatternKind
    | K.ObjectPatternKind
  )[],
  ...
} & Omit<TSType, 'type'> &
  TSHasOptionalTypeParameters &
  TSHasOptionalTypeAnnotation

export type TSConstructorType = {
  type: 'TSConstructorType',
  parameters: (
    | K.IdentifierKind
    | K.RestElementKind
    | K.ArrayPatternKind
    | K.ObjectPatternKind
  )[],
  ...
} & Omit<TSType, 'type'> &
  TSHasOptionalTypeParameters &
  TSHasOptionalTypeAnnotation

export type TSDeclareFunction = {
  type: 'TSDeclareFunction',
  declare?: boolean,
  async?: boolean,
  generator?: boolean,
  id?: K.IdentifierKind | null,
  params: K.PatternKind[],
  returnType?: K.TSTypeAnnotationKind | K.NoopKind | null,
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeParameters

export type TSDeclareMethod = {
  type: 'TSDeclareMethod',
  async?: boolean,
  generator?: boolean,
  params: K.PatternKind[],
  abstract?: boolean,
  accessibility?: 'public' | 'private' | 'protected' | void,
  static?: boolean,
  computed?: boolean,
  optional?: boolean,
  key:
    | K.IdentifierKind
    | K.StringLiteralKind
    | K.NumericLiteralKind
    | K.ExpressionKind,
  kind?: 'get' | 'set' | 'method' | 'constructor',
  access?: 'public' | 'private' | 'protected' | void,
  decorators?: K.DecoratorKind[] | null,
  returnType?: K.TSTypeAnnotationKind | K.NoopKind | null,
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeParameters

export type TSMappedType = {
  type: 'TSMappedType',
  readonly?: boolean | '+' | '-',
  typeParameter: K.TSTypeParameterKind,
  optional?: boolean | '+' | '-',
  typeAnnotation?: K.TSTypeKind | null,
  ...
} & Omit<TSType, 'type'>

export type TSTupleType = {
  type: 'TSTupleType',
  elementTypes: K.TSTypeKind[],
  ...
} & Omit<TSType, 'type'>

export type TSRestType = {
  type: 'TSRestType',
  typeAnnotation: K.TSTypeKind,
  ...
} & Omit<TSType, 'type'>

export type TSOptionalType = {
  type: 'TSOptionalType',
  typeAnnotation: K.TSTypeKind,
  ...
} & Omit<TSType, 'type'>

export type TSIndexedAccessType = {
  type: 'TSIndexedAccessType',
  objectType: K.TSTypeKind,
  indexType: K.TSTypeKind,
  ...
} & Omit<TSType, 'type'>

export type TSTypeOperator = {
  type: 'TSTypeOperator',
  operator: string,
  typeAnnotation: K.TSTypeKind,
  ...
} & Omit<TSType, 'type'>

export type TSIndexSignature = {
  type: 'TSIndexSignature',
  parameters: K.IdentifierKind[],
  readonly?: boolean,
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeAnnotation

export type TSPropertySignature = {
  type: 'TSPropertySignature',
  key: K.ExpressionKind,
  computed?: boolean,
  readonly?: boolean,
  optional?: boolean,
  initializer?: K.ExpressionKind | null,
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeAnnotation

export type TSMethodSignature = {
  type: 'TSMethodSignature',
  key: K.ExpressionKind,
  computed?: boolean,
  optional?: boolean,
  parameters: (
    | K.IdentifierKind
    | K.RestElementKind
    | K.ArrayPatternKind
    | K.ObjectPatternKind
  )[],
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeParameters &
  TSHasOptionalTypeAnnotation

export type TSTypePredicate = {
  type: 'TSTypePredicate',
  parameterName: K.IdentifierKind | K.TSThisTypeKind,
  typeAnnotation: K.TSTypeAnnotationKind,
  ...
} & Omit<TSTypeAnnotation, 'type' | 'typeAnnotation'>

export type TSCallSignatureDeclaration = {
  type: 'TSCallSignatureDeclaration',
  parameters: (
    | K.IdentifierKind
    | K.RestElementKind
    | K.ArrayPatternKind
    | K.ObjectPatternKind
  )[],
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeParameters &
  TSHasOptionalTypeAnnotation

export type TSConstructSignatureDeclaration = {
  type: 'TSConstructSignatureDeclaration',
  parameters: (
    | K.IdentifierKind
    | K.RestElementKind
    | K.ArrayPatternKind
    | K.ObjectPatternKind
  )[],
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeParameters &
  TSHasOptionalTypeAnnotation

export type TSEnumMember = {
  type: 'TSEnumMember',
  id: K.IdentifierKind | K.StringLiteralKind,
  initializer?: K.ExpressionKind | null,
  ...
} & Omit<Node, 'type'>

export type TSTypeQuery = {
  type: 'TSTypeQuery',
  exprName: K.IdentifierKind | K.TSQualifiedNameKind | K.TSImportTypeKind,
  ...
} & Omit<TSType, 'type'>

export type TSImportType = {
  type: 'TSImportType',
  argument: K.StringLiteralKind,
  qualifier?: K.IdentifierKind | K.TSQualifiedNameKind | void,
  ...
} & Omit<TSType, 'type'> &
  TSHasOptionalTypeParameterInstantiation

export type TSTypeLiteral = {
  type: 'TSTypeLiteral',
  members: (
    | K.TSCallSignatureDeclarationKind
    | K.TSConstructSignatureDeclarationKind
    | K.TSIndexSignatureKind
    | K.TSMethodSignatureKind
    | K.TSPropertySignatureKind
  )[],
  ...
} & Omit<TSType, 'type'>

export type TSTypeAssertion = {
  type: 'TSTypeAssertion',
  typeAnnotation: K.TSTypeKind,
  expression: K.ExpressionKind,
  extra?: {
    parenthesized: boolean,
    ...
  } | null,
  ...
} & Omit<Expression, 'type'> &
  Omit<Pattern, 'type'>

export type TSEnumDeclaration = {
  type: 'TSEnumDeclaration',
  id: K.IdentifierKind,
  const?: boolean,
  declare?: boolean,
  members: K.TSEnumMemberKind[],
  initializer?: K.ExpressionKind | null,
  ...
} & Omit<Declaration, 'type'>

export type TSTypeAliasDeclaration = {
  type: 'TSTypeAliasDeclaration',
  id: K.IdentifierKind,
  declare?: boolean,
  typeAnnotation: K.TSTypeKind,
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeParameters

export type TSModuleBlock = {
  type: 'TSModuleBlock',
  body: K.StatementKind[],
  ...
} & Omit<Node, 'type'>

export type TSModuleDeclaration = {
  type: 'TSModuleDeclaration',
  id: K.StringLiteralKind | K.IdentifierKind | K.TSQualifiedNameKind,
  declare?: boolean,
  global?: boolean,
  body?: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null,
  ...
} & Omit<Declaration, 'type'>

export type TSImportEqualsDeclaration = {
  type: 'TSImportEqualsDeclaration',
  id: K.IdentifierKind,
  isExport?: boolean,
  moduleReference:
    | K.IdentifierKind
    | K.TSQualifiedNameKind
    | K.TSExternalModuleReferenceKind,
  ...
} & Omit<Declaration, 'type'>

export type TSExternalModuleReference = {
  type: 'TSExternalModuleReference',
  expression: K.StringLiteralKind,
  ...
} & Omit<Declaration, 'type'>

export type TSExportAssignment = {
  type: 'TSExportAssignment',
  expression: K.ExpressionKind,
  ...
} & Omit<Statement, 'type'>

export type TSNamespaceExportDeclaration = {
  type: 'TSNamespaceExportDeclaration',
  id: K.IdentifierKind,
  ...
} & Omit<Declaration, 'type'>

export type TSInterfaceBody = {
  type: 'TSInterfaceBody',
  body: (
    | K.TSCallSignatureDeclarationKind
    | K.TSConstructSignatureDeclarationKind
    | K.TSIndexSignatureKind
    | K.TSMethodSignatureKind
    | K.TSPropertySignatureKind
  )[],
  ...
} & Omit<Node, 'type'>

export type TSInterfaceDeclaration = {
  type: 'TSInterfaceDeclaration',
  id: K.IdentifierKind | K.TSQualifiedNameKind,
  declare?: boolean,
  extends?: K.TSExpressionWithTypeArgumentsKind[] | null,
  body: K.TSInterfaceBodyKind,
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeParameters

export type TSParameterProperty = {
  type: 'TSParameterProperty',
  accessibility?: 'public' | 'private' | 'protected' | void,
  readonly?: boolean,
  parameter: K.IdentifierKind | K.AssignmentPatternKind,
  ...
} & Omit<Pattern, 'type'>

export type OptionalMemberExpression = {
  type: 'OptionalMemberExpression',
  optional?: boolean,
  ...
} & Omit<MemberExpression, 'type'>

export type OptionalCallExpression = {
  type: 'OptionalCallExpression',
  optional?: boolean,
  ...
} & Omit<CallExpression, 'type'>

export type ASTNode =
  | File
  | Program
  | Identifier
  | BlockStatement
  | EmptyStatement
  | ExpressionStatement
  | IfStatement
  | LabeledStatement
  | BreakStatement
  | ContinueStatement
  | WithStatement
  | SwitchStatement
  | SwitchCase
  | ReturnStatement
  | ThrowStatement
  | TryStatement
  | CatchClause
  | WhileStatement
  | DoWhileStatement
  | ForStatement
  | VariableDeclaration
  | ForInStatement
  | DebuggerStatement
  | FunctionDeclaration
  | FunctionExpression
  | VariableDeclarator
  | ThisExpression
  | ArrayExpression
  | ObjectExpression
  | Property
  | Literal
  | SequenceExpression
  | UnaryExpression
  | BinaryExpression
  | AssignmentExpression
  | MemberExpression
  | UpdateExpression
  | LogicalExpression
  | ConditionalExpression
  | NewExpression
  | CallExpression
  | RestElement
  | TypeAnnotation
  | TSTypeAnnotation
  | SpreadElementPattern
  | ArrowFunctionExpression
  | ForOfStatement
  | YieldExpression
  | GeneratorExpression
  | ComprehensionBlock
  | ComprehensionExpression
  | ObjectProperty
  | PropertyPattern
  | ObjectPattern
  | ArrayPattern
  | MethodDefinition
  | SpreadElement
  | AssignmentPattern
  | ClassPropertyDefinition
  | ClassProperty
  | ClassBody
  | ClassDeclaration
  | ClassExpression
  | ImportSpecifier
  | ImportNamespaceSpecifier
  | ImportDefaultSpecifier
  | ImportDeclaration
  | TaggedTemplateExpression
  | TemplateLiteral
  | TemplateElement
  | SpreadProperty
  | SpreadPropertyPattern
  | AwaitExpression
  | JSXAttribute
  | JSXIdentifier
  | JSXNamespacedName
  | JSXExpressionContainer
  | JSXMemberExpression
  | JSXSpreadAttribute
  | JSXElement
  | JSXOpeningElement
  | JSXClosingElement
  | JSXFragment
  | JSXText
  | JSXOpeningFragment
  | JSXClosingFragment
  | JSXEmptyExpression
  | JSXSpreadChild
  | TypeParameterDeclaration
  | TSTypeParameterDeclaration
  | TypeParameterInstantiation
  | TSTypeParameterInstantiation
  | ClassImplements
  | TSExpressionWithTypeArguments
  | AnyTypeAnnotation
  | EmptyTypeAnnotation
  | MixedTypeAnnotation
  | VoidTypeAnnotation
  | NumberTypeAnnotation
  | NumberLiteralTypeAnnotation
  | NumericLiteralTypeAnnotation
  | StringTypeAnnotation
  | StringLiteralTypeAnnotation
  | BooleanTypeAnnotation
  | BooleanLiteralTypeAnnotation
  | NullableTypeAnnotation
  | NullLiteralTypeAnnotation
  | NullTypeAnnotation
  | ThisTypeAnnotation
  | ExistsTypeAnnotation
  | ExistentialTypeParam
  | FunctionTypeAnnotation
  | FunctionTypeParam
  | ArrayTypeAnnotation
  | ObjectTypeAnnotation
  | ObjectTypeProperty
  | ObjectTypeSpreadProperty
  | ObjectTypeIndexer
  | ObjectTypeCallProperty
  | ObjectTypeInternalSlot
  | Variance
  | QualifiedTypeIdentifier
  | GenericTypeAnnotation
  | MemberTypeAnnotation
  | UnionTypeAnnotation
  | IntersectionTypeAnnotation
  | TypeofTypeAnnotation
  | TypeParameter
  | InterfaceTypeAnnotation
  | InterfaceExtends
  | InterfaceDeclaration
  | DeclareInterface
  | TypeAlias
  | OpaqueType
  | DeclareTypeAlias
  | DeclareOpaqueType
  | TypeCastExpression
  | TupleTypeAnnotation
  | DeclareVariable
  | DeclareFunction
  | DeclareClass
  | DeclareModule
  | DeclareModuleExports
  | DeclareExportDeclaration
  | ExportSpecifier
  | ExportBatchSpecifier
  | DeclareExportAllDeclaration
  | InferredPredicate
  | DeclaredPredicate
  | ExportDeclaration
  | Block
  | Line
  | Noop
  | DoExpression
  | Super
  | BindExpression
  | Decorator
  | MetaProperty
  | ParenthesizedExpression
  | ExportDefaultDeclaration
  | ExportNamedDeclaration
  | ExportNamespaceSpecifier
  | ExportDefaultSpecifier
  | ExportAllDeclaration
  | CommentBlock
  | CommentLine
  | Directive
  | DirectiveLiteral
  | InterpreterDirective
  | StringLiteral
  | NumericLiteral
  | BigIntLiteral
  | NullLiteral
  | BooleanLiteral
  | RegExpLiteral
  | ObjectMethod
  | ClassPrivateProperty
  | ClassMethod
  | ClassPrivateMethod
  | PrivateName
  | RestProperty
  | ForAwaitStatement
  | Import
  | TSQualifiedName
  | TSTypeReference
  | TSAsExpression
  | TSNonNullExpression
  | TSAnyKeyword
  | TSBigIntKeyword
  | TSBooleanKeyword
  | TSNeverKeyword
  | TSNullKeyword
  | TSNumberKeyword
  | TSObjectKeyword
  | TSStringKeyword
  | TSSymbolKeyword
  | TSUndefinedKeyword
  | TSUnknownKeyword
  | TSVoidKeyword
  | TSThisType
  | TSArrayType
  | TSLiteralType
  | TSUnionType
  | TSIntersectionType
  | TSConditionalType
  | TSInferType
  | TSTypeParameter
  | TSParenthesizedType
  | TSFunctionType
  | TSConstructorType
  | TSDeclareFunction
  | TSDeclareMethod
  | TSMappedType
  | TSTupleType
  | TSRestType
  | TSOptionalType
  | TSIndexedAccessType
  | TSTypeOperator
  | TSIndexSignature
  | TSPropertySignature
  | TSMethodSignature
  | TSTypePredicate
  | TSCallSignatureDeclaration
  | TSConstructSignatureDeclaration
  | TSEnumMember
  | TSTypeQuery
  | TSImportType
  | TSTypeLiteral
  | TSTypeAssertion
  | TSEnumDeclaration
  | TSTypeAliasDeclaration
  | TSModuleBlock
  | TSModuleDeclaration
  | TSImportEqualsDeclaration
  | TSExternalModuleReference
  | TSExportAssignment
  | TSNamespaceExportDeclaration
  | TSInterfaceBody
  | TSInterfaceDeclaration
  | TSParameterProperty
  | OptionalMemberExpression
  | OptionalCallExpression

declare var namedTypes$Printable: Type<Printable>

declare var namedTypes$SourceLocation: Type<SourceLocation>

declare var namedTypes$Node: Type<Node>

declare var namedTypes$Comment: Type<Comment>

declare var namedTypes$Position: Type<Position>

declare var namedTypes$File: Type<File>

declare var namedTypes$Program: Type<Program>

declare var namedTypes$Statement: Type<Statement>

declare var namedTypes$Function: Type<Function>

declare var namedTypes$Expression: Type<Expression>

declare var namedTypes$Pattern: Type<Pattern>

declare var namedTypes$Identifier: Type<Identifier>

declare var namedTypes$BlockStatement: Type<BlockStatement>

declare var namedTypes$EmptyStatement: Type<EmptyStatement>

declare var namedTypes$ExpressionStatement: Type<ExpressionStatement>

declare var namedTypes$IfStatement: Type<IfStatement>

declare var namedTypes$LabeledStatement: Type<LabeledStatement>

declare var namedTypes$BreakStatement: Type<BreakStatement>

declare var namedTypes$ContinueStatement: Type<ContinueStatement>

declare var namedTypes$WithStatement: Type<WithStatement>

declare var namedTypes$SwitchStatement: Type<SwitchStatement>

declare var namedTypes$SwitchCase: Type<SwitchCase>

declare var namedTypes$ReturnStatement: Type<ReturnStatement>

declare var namedTypes$ThrowStatement: Type<ThrowStatement>

declare var namedTypes$TryStatement: Type<TryStatement>

declare var namedTypes$CatchClause: Type<CatchClause>

declare var namedTypes$WhileStatement: Type<WhileStatement>

declare var namedTypes$DoWhileStatement: Type<DoWhileStatement>

declare var namedTypes$ForStatement: Type<ForStatement>

declare var namedTypes$Declaration: Type<Declaration>

declare var namedTypes$VariableDeclaration: Type<VariableDeclaration>

declare var namedTypes$ForInStatement: Type<ForInStatement>

declare var namedTypes$DebuggerStatement: Type<DebuggerStatement>

declare var namedTypes$FunctionDeclaration: Type<FunctionDeclaration>

declare var namedTypes$FunctionExpression: Type<FunctionExpression>

declare var namedTypes$VariableDeclarator: Type<VariableDeclarator>

declare var namedTypes$ThisExpression: Type<ThisExpression>

declare var namedTypes$ArrayExpression: Type<ArrayExpression>

declare var namedTypes$ObjectExpression: Type<ObjectExpression>

declare var namedTypes$Property: Type<Property>

declare var namedTypes$Literal: Type<Literal>

declare var namedTypes$SequenceExpression: Type<SequenceExpression>

declare var namedTypes$UnaryExpression: Type<UnaryExpression>

declare var namedTypes$BinaryExpression: Type<BinaryExpression>

declare var namedTypes$AssignmentExpression: Type<AssignmentExpression>

declare var namedTypes$MemberExpression: Type<MemberExpression>

declare var namedTypes$UpdateExpression: Type<UpdateExpression>

declare var namedTypes$LogicalExpression: Type<LogicalExpression>

declare var namedTypes$ConditionalExpression: Type<ConditionalExpression>

declare var namedTypes$NewExpression: Type<NewExpression>

declare var namedTypes$CallExpression: Type<CallExpression>

declare var namedTypes$RestElement: Type<RestElement>

declare var namedTypes$TypeAnnotation: Type<TypeAnnotation>

declare var namedTypes$TSTypeAnnotation: Type<TSTypeAnnotation>

declare var namedTypes$SpreadElementPattern: Type<SpreadElementPattern>

declare var namedTypes$ArrowFunctionExpression: Type<ArrowFunctionExpression>

declare var namedTypes$ForOfStatement: Type<ForOfStatement>

declare var namedTypes$YieldExpression: Type<YieldExpression>

declare var namedTypes$GeneratorExpression: Type<GeneratorExpression>

declare var namedTypes$ComprehensionBlock: Type<ComprehensionBlock>

declare var namedTypes$ComprehensionExpression: Type<ComprehensionExpression>

declare var namedTypes$ObjectProperty: Type<ObjectProperty>

declare var namedTypes$PropertyPattern: Type<PropertyPattern>

declare var namedTypes$ObjectPattern: Type<ObjectPattern>

declare var namedTypes$ArrayPattern: Type<ArrayPattern>

declare var namedTypes$MethodDefinition: Type<MethodDefinition>

declare var namedTypes$SpreadElement: Type<SpreadElement>

declare var namedTypes$AssignmentPattern: Type<AssignmentPattern>

declare var namedTypes$ClassPropertyDefinition: Type<ClassPropertyDefinition>

declare var namedTypes$ClassProperty: Type<ClassProperty>

declare var namedTypes$ClassBody: Type<ClassBody>

declare var namedTypes$ClassDeclaration: Type<ClassDeclaration>

declare var namedTypes$ClassExpression: Type<ClassExpression>

declare var namedTypes$Specifier: Type<Specifier>

declare var namedTypes$ModuleSpecifier: Type<ModuleSpecifier>

declare var namedTypes$ImportSpecifier: Type<ImportSpecifier>

declare var namedTypes$ImportNamespaceSpecifier: Type<ImportNamespaceSpecifier>

declare var namedTypes$ImportDefaultSpecifier: Type<ImportDefaultSpecifier>

declare var namedTypes$ImportDeclaration: Type<ImportDeclaration>

declare var namedTypes$TaggedTemplateExpression: Type<TaggedTemplateExpression>

declare var namedTypes$TemplateLiteral: Type<TemplateLiteral>

declare var namedTypes$TemplateElement: Type<TemplateElement>

declare var namedTypes$SpreadProperty: Type<SpreadProperty>

declare var namedTypes$SpreadPropertyPattern: Type<SpreadPropertyPattern>

declare var namedTypes$AwaitExpression: Type<AwaitExpression>

declare var namedTypes$JSXAttribute: Type<JSXAttribute>

declare var namedTypes$JSXIdentifier: Type<JSXIdentifier>

declare var namedTypes$JSXNamespacedName: Type<JSXNamespacedName>

declare var namedTypes$JSXExpressionContainer: Type<JSXExpressionContainer>

declare var namedTypes$JSXMemberExpression: Type<JSXMemberExpression>

declare var namedTypes$JSXSpreadAttribute: Type<JSXSpreadAttribute>

declare var namedTypes$JSXElement: Type<JSXElement>

declare var namedTypes$JSXOpeningElement: Type<JSXOpeningElement>

declare var namedTypes$JSXClosingElement: Type<JSXClosingElement>

declare var namedTypes$JSXFragment: Type<JSXFragment>

declare var namedTypes$JSXText: Type<JSXText>

declare var namedTypes$JSXOpeningFragment: Type<JSXOpeningFragment>

declare var namedTypes$JSXClosingFragment: Type<JSXClosingFragment>

declare var namedTypes$JSXEmptyExpression: Type<JSXEmptyExpression>

declare var namedTypes$JSXSpreadChild: Type<JSXSpreadChild>

declare var namedTypes$TypeParameterDeclaration: Type<TypeParameterDeclaration>

declare var namedTypes$TSTypeParameterDeclaration: Type<TSTypeParameterDeclaration>

declare var namedTypes$TypeParameterInstantiation: Type<TypeParameterInstantiation>

declare var namedTypes$TSTypeParameterInstantiation: Type<TSTypeParameterInstantiation>

declare var namedTypes$ClassImplements: Type<ClassImplements>

declare var namedTypes$TSType: Type<TSType>

declare var namedTypes$TSHasOptionalTypeParameterInstantiation: Type<TSHasOptionalTypeParameterInstantiation>

declare var namedTypes$TSExpressionWithTypeArguments: Type<TSExpressionWithTypeArguments>

declare var namedTypes$Flow: Type<Flow>

declare var namedTypes$FlowType: Type<FlowType>

declare var namedTypes$AnyTypeAnnotation: Type<AnyTypeAnnotation>

declare var namedTypes$EmptyTypeAnnotation: Type<EmptyTypeAnnotation>

declare var namedTypes$MixedTypeAnnotation: Type<MixedTypeAnnotation>

declare var namedTypes$VoidTypeAnnotation: Type<VoidTypeAnnotation>

declare var namedTypes$NumberTypeAnnotation: Type<NumberTypeAnnotation>

declare var namedTypes$NumberLiteralTypeAnnotation: Type<NumberLiteralTypeAnnotation>

declare var namedTypes$NumericLiteralTypeAnnotation: Type<NumericLiteralTypeAnnotation>

declare var namedTypes$StringTypeAnnotation: Type<StringTypeAnnotation>

declare var namedTypes$StringLiteralTypeAnnotation: Type<StringLiteralTypeAnnotation>

declare var namedTypes$BooleanTypeAnnotation: Type<BooleanTypeAnnotation>

declare var namedTypes$BooleanLiteralTypeAnnotation: Type<BooleanLiteralTypeAnnotation>

declare var namedTypes$NullableTypeAnnotation: Type<NullableTypeAnnotation>

declare var namedTypes$NullLiteralTypeAnnotation: Type<NullLiteralTypeAnnotation>

declare var namedTypes$NullTypeAnnotation: Type<NullTypeAnnotation>

declare var namedTypes$ThisTypeAnnotation: Type<ThisTypeAnnotation>

declare var namedTypes$ExistsTypeAnnotation: Type<ExistsTypeAnnotation>

declare var namedTypes$ExistentialTypeParam: Type<ExistentialTypeParam>

declare var namedTypes$FunctionTypeAnnotation: Type<FunctionTypeAnnotation>

declare var namedTypes$FunctionTypeParam: Type<FunctionTypeParam>

declare var namedTypes$ArrayTypeAnnotation: Type<ArrayTypeAnnotation>

declare var namedTypes$ObjectTypeAnnotation: Type<ObjectTypeAnnotation>

declare var namedTypes$ObjectTypeProperty: Type<ObjectTypeProperty>

declare var namedTypes$ObjectTypeSpreadProperty: Type<ObjectTypeSpreadProperty>

declare var namedTypes$ObjectTypeIndexer: Type<ObjectTypeIndexer>

declare var namedTypes$ObjectTypeCallProperty: Type<ObjectTypeCallProperty>

declare var namedTypes$ObjectTypeInternalSlot: Type<ObjectTypeInternalSlot>

declare var namedTypes$Variance: Type<Variance>

declare var namedTypes$QualifiedTypeIdentifier: Type<QualifiedTypeIdentifier>

declare var namedTypes$GenericTypeAnnotation: Type<GenericTypeAnnotation>

declare var namedTypes$MemberTypeAnnotation: Type<MemberTypeAnnotation>

declare var namedTypes$UnionTypeAnnotation: Type<UnionTypeAnnotation>

declare var namedTypes$IntersectionTypeAnnotation: Type<IntersectionTypeAnnotation>

declare var namedTypes$TypeofTypeAnnotation: Type<TypeofTypeAnnotation>

declare var namedTypes$TypeParameter: Type<TypeParameter>

declare var namedTypes$InterfaceTypeAnnotation: Type<InterfaceTypeAnnotation>

declare var namedTypes$InterfaceExtends: Type<InterfaceExtends>

declare var namedTypes$InterfaceDeclaration: Type<InterfaceDeclaration>

declare var namedTypes$DeclareInterface: Type<DeclareInterface>

declare var namedTypes$TypeAlias: Type<TypeAlias>

declare var namedTypes$OpaqueType: Type<OpaqueType>

declare var namedTypes$DeclareTypeAlias: Type<DeclareTypeAlias>

declare var namedTypes$DeclareOpaqueType: Type<DeclareOpaqueType>

declare var namedTypes$TypeCastExpression: Type<TypeCastExpression>

declare var namedTypes$TupleTypeAnnotation: Type<TupleTypeAnnotation>

declare var namedTypes$DeclareVariable: Type<DeclareVariable>

declare var namedTypes$DeclareFunction: Type<DeclareFunction>

declare var namedTypes$DeclareClass: Type<DeclareClass>

declare var namedTypes$DeclareModule: Type<DeclareModule>

declare var namedTypes$DeclareModuleExports: Type<DeclareModuleExports>

declare var namedTypes$DeclareExportDeclaration: Type<DeclareExportDeclaration>

declare var namedTypes$ExportSpecifier: Type<ExportSpecifier>

declare var namedTypes$ExportBatchSpecifier: Type<ExportBatchSpecifier>

declare var namedTypes$DeclareExportAllDeclaration: Type<DeclareExportAllDeclaration>

declare var namedTypes$FlowPredicate: Type<FlowPredicate>

declare var namedTypes$InferredPredicate: Type<InferredPredicate>

declare var namedTypes$DeclaredPredicate: Type<DeclaredPredicate>

declare var namedTypes$ExportDeclaration: Type<ExportDeclaration>

declare var namedTypes$Block: Type<Block>

declare var namedTypes$Line: Type<Line>

declare var namedTypes$Noop: Type<Noop>

declare var namedTypes$DoExpression: Type<DoExpression>

declare var namedTypes$Super: Type<Super>

declare var namedTypes$BindExpression: Type<BindExpression>

declare var namedTypes$Decorator: Type<Decorator>

declare var namedTypes$MetaProperty: Type<MetaProperty>

declare var namedTypes$ParenthesizedExpression: Type<ParenthesizedExpression>

declare var namedTypes$ExportDefaultDeclaration: Type<ExportDefaultDeclaration>

declare var namedTypes$ExportNamedDeclaration: Type<ExportNamedDeclaration>

declare var namedTypes$ExportNamespaceSpecifier: Type<ExportNamespaceSpecifier>

declare var namedTypes$ExportDefaultSpecifier: Type<ExportDefaultSpecifier>

declare var namedTypes$ExportAllDeclaration: Type<ExportAllDeclaration>

declare var namedTypes$CommentBlock: Type<CommentBlock>

declare var namedTypes$CommentLine: Type<CommentLine>

declare var namedTypes$Directive: Type<Directive>

declare var namedTypes$DirectiveLiteral: Type<DirectiveLiteral>

declare var namedTypes$InterpreterDirective: Type<InterpreterDirective>

declare var namedTypes$StringLiteral: Type<StringLiteral>

declare var namedTypes$NumericLiteral: Type<NumericLiteral>

declare var namedTypes$BigIntLiteral: Type<BigIntLiteral>

declare var namedTypes$NullLiteral: Type<NullLiteral>

declare var namedTypes$BooleanLiteral: Type<BooleanLiteral>

declare var namedTypes$RegExpLiteral: Type<RegExpLiteral>

declare var namedTypes$ObjectMethod: Type<ObjectMethod>

declare var namedTypes$ClassPrivateProperty: Type<ClassPrivateProperty>

declare var namedTypes$ClassMethod: Type<ClassMethod>

declare var namedTypes$ClassPrivateMethod: Type<ClassPrivateMethod>

declare var namedTypes$PrivateName: Type<PrivateName>

declare var namedTypes$RestProperty: Type<RestProperty>

declare var namedTypes$ForAwaitStatement: Type<ForAwaitStatement>

declare var namedTypes$Import: Type<Import>

declare var namedTypes$TSQualifiedName: Type<TSQualifiedName>

declare var namedTypes$TSTypeReference: Type<TSTypeReference>

declare var namedTypes$TSHasOptionalTypeParameters: Type<TSHasOptionalTypeParameters>

declare var namedTypes$TSHasOptionalTypeAnnotation: Type<TSHasOptionalTypeAnnotation>

declare var namedTypes$TSAsExpression: Type<TSAsExpression>

declare var namedTypes$TSNonNullExpression: Type<TSNonNullExpression>

declare var namedTypes$TSAnyKeyword: Type<TSAnyKeyword>

declare var namedTypes$TSBigIntKeyword: Type<TSBigIntKeyword>

declare var namedTypes$TSBooleanKeyword: Type<TSBooleanKeyword>

declare var namedTypes$TSNeverKeyword: Type<TSNeverKeyword>

declare var namedTypes$TSNullKeyword: Type<TSNullKeyword>

declare var namedTypes$TSNumberKeyword: Type<TSNumberKeyword>

declare var namedTypes$TSObjectKeyword: Type<TSObjectKeyword>

declare var namedTypes$TSStringKeyword: Type<TSStringKeyword>

declare var namedTypes$TSSymbolKeyword: Type<TSSymbolKeyword>

declare var namedTypes$TSUndefinedKeyword: Type<TSUndefinedKeyword>

declare var namedTypes$TSUnknownKeyword: Type<TSUnknownKeyword>

declare var namedTypes$TSVoidKeyword: Type<TSVoidKeyword>

declare var namedTypes$TSThisType: Type<TSThisType>

declare var namedTypes$TSArrayType: Type<TSArrayType>

declare var namedTypes$TSLiteralType: Type<TSLiteralType>

declare var namedTypes$TSUnionType: Type<TSUnionType>

declare var namedTypes$TSIntersectionType: Type<TSIntersectionType>

declare var namedTypes$TSConditionalType: Type<TSConditionalType>

declare var namedTypes$TSInferType: Type<TSInferType>

declare var namedTypes$TSTypeParameter: Type<TSTypeParameter>

declare var namedTypes$TSParenthesizedType: Type<TSParenthesizedType>

declare var namedTypes$TSFunctionType: Type<TSFunctionType>

declare var namedTypes$TSConstructorType: Type<TSConstructorType>

declare var namedTypes$TSDeclareFunction: Type<TSDeclareFunction>

declare var namedTypes$TSDeclareMethod: Type<TSDeclareMethod>

declare var namedTypes$TSMappedType: Type<TSMappedType>

declare var namedTypes$TSTupleType: Type<TSTupleType>

declare var namedTypes$TSRestType: Type<TSRestType>

declare var namedTypes$TSOptionalType: Type<TSOptionalType>

declare var namedTypes$TSIndexedAccessType: Type<TSIndexedAccessType>

declare var namedTypes$TSTypeOperator: Type<TSTypeOperator>

declare var namedTypes$TSIndexSignature: Type<TSIndexSignature>

declare var namedTypes$TSPropertySignature: Type<TSPropertySignature>

declare var namedTypes$TSMethodSignature: Type<TSMethodSignature>

declare var namedTypes$TSTypePredicate: Type<TSTypePredicate>

declare var namedTypes$TSCallSignatureDeclaration: Type<TSCallSignatureDeclaration>

declare var namedTypes$TSConstructSignatureDeclaration: Type<TSConstructSignatureDeclaration>

declare var namedTypes$TSEnumMember: Type<TSEnumMember>

declare var namedTypes$TSTypeQuery: Type<TSTypeQuery>

declare var namedTypes$TSImportType: Type<TSImportType>

declare var namedTypes$TSTypeLiteral: Type<TSTypeLiteral>

declare var namedTypes$TSTypeAssertion: Type<TSTypeAssertion>

declare var namedTypes$TSEnumDeclaration: Type<TSEnumDeclaration>

declare var namedTypes$TSTypeAliasDeclaration: Type<TSTypeAliasDeclaration>

declare var namedTypes$TSModuleBlock: Type<TSModuleBlock>

declare var namedTypes$TSModuleDeclaration: Type<TSModuleDeclaration>

declare var namedTypes$TSImportEqualsDeclaration: Type<TSImportEqualsDeclaration>

declare var namedTypes$TSExternalModuleReference: Type<TSExternalModuleReference>

declare var namedTypes$TSExportAssignment: Type<TSExportAssignment>

declare var namedTypes$TSNamespaceExportDeclaration: Type<TSNamespaceExportDeclaration>

declare var namedTypes$TSInterfaceBody: Type<TSInterfaceBody>

declare var namedTypes$TSInterfaceDeclaration: Type<TSInterfaceDeclaration>

declare var namedTypes$TSParameterProperty: Type<TSParameterProperty>

declare var namedTypes$OptionalMemberExpression: Type<OptionalMemberExpression>

declare var namedTypes$OptionalCallExpression: Type<OptionalCallExpression>
export interface NamedTypes {
  Printable: Type<Printable>;
  SourceLocation: Type<SourceLocation>;
  Node: Type<Node>;
  Comment: Type<Comment>;
  Position: Type<Position>;
  File: Type<File>;
  Program: Type<Program>;
  Statement: Type<Statement>;
  Function: Type<Function>;
  Expression: Type<Expression>;
  Pattern: Type<Pattern>;
  Identifier: Type<Identifier>;
  BlockStatement: Type<BlockStatement>;
  EmptyStatement: Type<EmptyStatement>;
  ExpressionStatement: Type<ExpressionStatement>;
  IfStatement: Type<IfStatement>;
  LabeledStatement: Type<LabeledStatement>;
  BreakStatement: Type<BreakStatement>;
  ContinueStatement: Type<ContinueStatement>;
  WithStatement: Type<WithStatement>;
  SwitchStatement: Type<SwitchStatement>;
  SwitchCase: Type<SwitchCase>;
  ReturnStatement: Type<ReturnStatement>;
  ThrowStatement: Type<ThrowStatement>;
  TryStatement: Type<TryStatement>;
  CatchClause: Type<CatchClause>;
  WhileStatement: Type<WhileStatement>;
  DoWhileStatement: Type<DoWhileStatement>;
  ForStatement: Type<ForStatement>;
  Declaration: Type<Declaration>;
  VariableDeclaration: Type<VariableDeclaration>;
  ForInStatement: Type<ForInStatement>;
  DebuggerStatement: Type<DebuggerStatement>;
  FunctionDeclaration: Type<FunctionDeclaration>;
  FunctionExpression: Type<FunctionExpression>;
  VariableDeclarator: Type<VariableDeclarator>;
  ThisExpression: Type<ThisExpression>;
  ArrayExpression: Type<ArrayExpression>;
  ObjectExpression: Type<ObjectExpression>;
  Property: Type<Property>;
  Literal: Type<Literal>;
  SequenceExpression: Type<SequenceExpression>;
  UnaryExpression: Type<UnaryExpression>;
  BinaryExpression: Type<BinaryExpression>;
  AssignmentExpression: Type<AssignmentExpression>;
  MemberExpression: Type<MemberExpression>;
  UpdateExpression: Type<UpdateExpression>;
  LogicalExpression: Type<LogicalExpression>;
  ConditionalExpression: Type<ConditionalExpression>;
  NewExpression: Type<NewExpression>;
  CallExpression: Type<CallExpression>;
  RestElement: Type<RestElement>;
  TypeAnnotation: Type<TypeAnnotation>;
  TSTypeAnnotation: Type<TSTypeAnnotation>;
  SpreadElementPattern: Type<SpreadElementPattern>;
  ArrowFunctionExpression: Type<ArrowFunctionExpression>;
  ForOfStatement: Type<ForOfStatement>;
  YieldExpression: Type<YieldExpression>;
  GeneratorExpression: Type<GeneratorExpression>;
  ComprehensionBlock: Type<ComprehensionBlock>;
  ComprehensionExpression: Type<ComprehensionExpression>;
  ObjectProperty: Type<ObjectProperty>;
  PropertyPattern: Type<PropertyPattern>;
  ObjectPattern: Type<ObjectPattern>;
  ArrayPattern: Type<ArrayPattern>;
  MethodDefinition: Type<MethodDefinition>;
  SpreadElement: Type<SpreadElement>;
  AssignmentPattern: Type<AssignmentPattern>;
  ClassPropertyDefinition: Type<ClassPropertyDefinition>;
  ClassProperty: Type<ClassProperty>;
  ClassBody: Type<ClassBody>;
  ClassDeclaration: Type<ClassDeclaration>;
  ClassExpression: Type<ClassExpression>;
  Specifier: Type<Specifier>;
  ModuleSpecifier: Type<ModuleSpecifier>;
  ImportSpecifier: Type<ImportSpecifier>;
  ImportNamespaceSpecifier: Type<ImportNamespaceSpecifier>;
  ImportDefaultSpecifier: Type<ImportDefaultSpecifier>;
  ImportDeclaration: Type<ImportDeclaration>;
  TaggedTemplateExpression: Type<TaggedTemplateExpression>;
  TemplateLiteral: Type<TemplateLiteral>;
  TemplateElement: Type<TemplateElement>;
  SpreadProperty: Type<SpreadProperty>;
  SpreadPropertyPattern: Type<SpreadPropertyPattern>;
  AwaitExpression: Type<AwaitExpression>;
  JSXAttribute: Type<JSXAttribute>;
  JSXIdentifier: Type<JSXIdentifier>;
  JSXNamespacedName: Type<JSXNamespacedName>;
  JSXExpressionContainer: Type<JSXExpressionContainer>;
  JSXMemberExpression: Type<JSXMemberExpression>;
  JSXSpreadAttribute: Type<JSXSpreadAttribute>;
  JSXElement: Type<JSXElement>;
  JSXOpeningElement: Type<JSXOpeningElement>;
  JSXClosingElement: Type<JSXClosingElement>;
  JSXFragment: Type<JSXFragment>;
  JSXText: Type<JSXText>;
  JSXOpeningFragment: Type<JSXOpeningFragment>;
  JSXClosingFragment: Type<JSXClosingFragment>;
  JSXEmptyExpression: Type<JSXEmptyExpression>;
  JSXSpreadChild: Type<JSXSpreadChild>;
  TypeParameterDeclaration: Type<TypeParameterDeclaration>;
  TSTypeParameterDeclaration: Type<TSTypeParameterDeclaration>;
  TypeParameterInstantiation: Type<TypeParameterInstantiation>;
  TSTypeParameterInstantiation: Type<TSTypeParameterInstantiation>;
  ClassImplements: Type<ClassImplements>;
  TSType: Type<TSType>;
  TSHasOptionalTypeParameterInstantiation: Type<TSHasOptionalTypeParameterInstantiation>;
  TSExpressionWithTypeArguments: Type<TSExpressionWithTypeArguments>;
  Flow: Type<Flow>;
  FlowType: Type<FlowType>;
  AnyTypeAnnotation: Type<AnyTypeAnnotation>;
  EmptyTypeAnnotation: Type<EmptyTypeAnnotation>;
  MixedTypeAnnotation: Type<MixedTypeAnnotation>;
  VoidTypeAnnotation: Type<VoidTypeAnnotation>;
  NumberTypeAnnotation: Type<NumberTypeAnnotation>;
  NumberLiteralTypeAnnotation: Type<NumberLiteralTypeAnnotation>;
  NumericLiteralTypeAnnotation: Type<NumericLiteralTypeAnnotation>;
  StringTypeAnnotation: Type<StringTypeAnnotation>;
  StringLiteralTypeAnnotation: Type<StringLiteralTypeAnnotation>;
  BooleanTypeAnnotation: Type<BooleanTypeAnnotation>;
  BooleanLiteralTypeAnnotation: Type<BooleanLiteralTypeAnnotation>;
  NullableTypeAnnotation: Type<NullableTypeAnnotation>;
  NullLiteralTypeAnnotation: Type<NullLiteralTypeAnnotation>;
  NullTypeAnnotation: Type<NullTypeAnnotation>;
  ThisTypeAnnotation: Type<ThisTypeAnnotation>;
  ExistsTypeAnnotation: Type<ExistsTypeAnnotation>;
  ExistentialTypeParam: Type<ExistentialTypeParam>;
  FunctionTypeAnnotation: Type<FunctionTypeAnnotation>;
  FunctionTypeParam: Type<FunctionTypeParam>;
  ArrayTypeAnnotation: Type<ArrayTypeAnnotation>;
  ObjectTypeAnnotation: Type<ObjectTypeAnnotation>;
  ObjectTypeProperty: Type<ObjectTypeProperty>;
  ObjectTypeSpreadProperty: Type<ObjectTypeSpreadProperty>;
  ObjectTypeIndexer: Type<ObjectTypeIndexer>;
  ObjectTypeCallProperty: Type<ObjectTypeCallProperty>;
  ObjectTypeInternalSlot: Type<ObjectTypeInternalSlot>;
  Variance: Type<Variance>;
  QualifiedTypeIdentifier: Type<QualifiedTypeIdentifier>;
  GenericTypeAnnotation: Type<GenericTypeAnnotation>;
  MemberTypeAnnotation: Type<MemberTypeAnnotation>;
  UnionTypeAnnotation: Type<UnionTypeAnnotation>;
  IntersectionTypeAnnotation: Type<IntersectionTypeAnnotation>;
  TypeofTypeAnnotation: Type<TypeofTypeAnnotation>;
  TypeParameter: Type<TypeParameter>;
  InterfaceTypeAnnotation: Type<InterfaceTypeAnnotation>;
  InterfaceExtends: Type<InterfaceExtends>;
  InterfaceDeclaration: Type<InterfaceDeclaration>;
  DeclareInterface: Type<DeclareInterface>;
  TypeAlias: Type<TypeAlias>;
  OpaqueType: Type<OpaqueType>;
  DeclareTypeAlias: Type<DeclareTypeAlias>;
  DeclareOpaqueType: Type<DeclareOpaqueType>;
  TypeCastExpression: Type<TypeCastExpression>;
  TupleTypeAnnotation: Type<TupleTypeAnnotation>;
  DeclareVariable: Type<DeclareVariable>;
  DeclareFunction: Type<DeclareFunction>;
  DeclareClass: Type<DeclareClass>;
  DeclareModule: Type<DeclareModule>;
  DeclareModuleExports: Type<DeclareModuleExports>;
  DeclareExportDeclaration: Type<DeclareExportDeclaration>;
  ExportSpecifier: Type<ExportSpecifier>;
  ExportBatchSpecifier: Type<ExportBatchSpecifier>;
  DeclareExportAllDeclaration: Type<DeclareExportAllDeclaration>;
  FlowPredicate: Type<FlowPredicate>;
  InferredPredicate: Type<InferredPredicate>;
  DeclaredPredicate: Type<DeclaredPredicate>;
  ExportDeclaration: Type<ExportDeclaration>;
  Block: Type<Block>;
  Line: Type<Line>;
  Noop: Type<Noop>;
  DoExpression: Type<DoExpression>;
  Super: Type<Super>;
  BindExpression: Type<BindExpression>;
  Decorator: Type<Decorator>;
  MetaProperty: Type<MetaProperty>;
  ParenthesizedExpression: Type<ParenthesizedExpression>;
  ExportDefaultDeclaration: Type<ExportDefaultDeclaration>;
  ExportNamedDeclaration: Type<ExportNamedDeclaration>;
  ExportNamespaceSpecifier: Type<ExportNamespaceSpecifier>;
  ExportDefaultSpecifier: Type<ExportDefaultSpecifier>;
  ExportAllDeclaration: Type<ExportAllDeclaration>;
  CommentBlock: Type<CommentBlock>;
  CommentLine: Type<CommentLine>;
  Directive: Type<Directive>;
  DirectiveLiteral: Type<DirectiveLiteral>;
  InterpreterDirective: Type<InterpreterDirective>;
  StringLiteral: Type<StringLiteral>;
  NumericLiteral: Type<NumericLiteral>;
  BigIntLiteral: Type<BigIntLiteral>;
  NullLiteral: Type<NullLiteral>;
  BooleanLiteral: Type<BooleanLiteral>;
  RegExpLiteral: Type<RegExpLiteral>;
  ObjectMethod: Type<ObjectMethod>;
  ClassPrivateProperty: Type<ClassPrivateProperty>;
  ClassMethod: Type<ClassMethod>;
  ClassPrivateMethod: Type<ClassPrivateMethod>;
  PrivateName: Type<PrivateName>;
  RestProperty: Type<RestProperty>;
  ForAwaitStatement: Type<ForAwaitStatement>;
  Import: Type<Import>;
  TSQualifiedName: Type<TSQualifiedName>;
  TSTypeReference: Type<TSTypeReference>;
  TSHasOptionalTypeParameters: Type<TSHasOptionalTypeParameters>;
  TSHasOptionalTypeAnnotation: Type<TSHasOptionalTypeAnnotation>;
  TSAsExpression: Type<TSAsExpression>;
  TSNonNullExpression: Type<TSNonNullExpression>;
  TSAnyKeyword: Type<TSAnyKeyword>;
  TSBigIntKeyword: Type<TSBigIntKeyword>;
  TSBooleanKeyword: Type<TSBooleanKeyword>;
  TSNeverKeyword: Type<TSNeverKeyword>;
  TSNullKeyword: Type<TSNullKeyword>;
  TSNumberKeyword: Type<TSNumberKeyword>;
  TSObjectKeyword: Type<TSObjectKeyword>;
  TSStringKeyword: Type<TSStringKeyword>;
  TSSymbolKeyword: Type<TSSymbolKeyword>;
  TSUndefinedKeyword: Type<TSUndefinedKeyword>;
  TSUnknownKeyword: Type<TSUnknownKeyword>;
  TSVoidKeyword: Type<TSVoidKeyword>;
  TSThisType: Type<TSThisType>;
  TSArrayType: Type<TSArrayType>;
  TSLiteralType: Type<TSLiteralType>;
  TSUnionType: Type<TSUnionType>;
  TSIntersectionType: Type<TSIntersectionType>;
  TSConditionalType: Type<TSConditionalType>;
  TSInferType: Type<TSInferType>;
  TSTypeParameter: Type<TSTypeParameter>;
  TSParenthesizedType: Type<TSParenthesizedType>;
  TSFunctionType: Type<TSFunctionType>;
  TSConstructorType: Type<TSConstructorType>;
  TSDeclareFunction: Type<TSDeclareFunction>;
  TSDeclareMethod: Type<TSDeclareMethod>;
  TSMappedType: Type<TSMappedType>;
  TSTupleType: Type<TSTupleType>;
  TSRestType: Type<TSRestType>;
  TSOptionalType: Type<TSOptionalType>;
  TSIndexedAccessType: Type<TSIndexedAccessType>;
  TSTypeOperator: Type<TSTypeOperator>;
  TSIndexSignature: Type<TSIndexSignature>;
  TSPropertySignature: Type<TSPropertySignature>;
  TSMethodSignature: Type<TSMethodSignature>;
  TSTypePredicate: Type<TSTypePredicate>;
  TSCallSignatureDeclaration: Type<TSCallSignatureDeclaration>;
  TSConstructSignatureDeclaration: Type<TSConstructSignatureDeclaration>;
  TSEnumMember: Type<TSEnumMember>;
  TSTypeQuery: Type<TSTypeQuery>;
  TSImportType: Type<TSImportType>;
  TSTypeLiteral: Type<TSTypeLiteral>;
  TSTypeAssertion: Type<TSTypeAssertion>;
  TSEnumDeclaration: Type<TSEnumDeclaration>;
  TSTypeAliasDeclaration: Type<TSTypeAliasDeclaration>;
  TSModuleBlock: Type<TSModuleBlock>;
  TSModuleDeclaration: Type<TSModuleDeclaration>;
  TSImportEqualsDeclaration: Type<TSImportEqualsDeclaration>;
  TSExternalModuleReference: Type<TSExternalModuleReference>;
  TSExportAssignment: Type<TSExportAssignment>;
  TSNamespaceExportDeclaration: Type<TSNamespaceExportDeclaration>;
  TSInterfaceBody: Type<TSInterfaceBody>;
  TSInterfaceDeclaration: Type<TSInterfaceDeclaration>;
  TSParameterProperty: Type<TSParameterProperty>;
  OptionalMemberExpression: Type<OptionalMemberExpression>;
  OptionalCallExpression: Type<OptionalCallExpression>;
}
