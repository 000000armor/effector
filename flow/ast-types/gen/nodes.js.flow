/**
 * Flowtype definitions for ast-types
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.9.2
 * @flow
 */

import type {Omit} from '../types'
import * as K from './kinds'
export interface Printable {
  loc: K.SourceLocationKind | null;
}
export interface SourceLocation {
  start: K.PositionKind;
  end: K.PositionKind;
  source: string | null;
}
export type Node = {
  type: string,
  comments: K.CommentKind[] | null,
  ...
} & Printable
export type Comment = {
  value: string,
  leading: boolean,
  trailing: boolean,
  ...
} & Printable
export interface Position {
  line: number;
  column: number;
}
export type File = {
  type: 'File',
  program: K.ProgramKind,
  name: string | null,
  ...
} & Omit<Node, 'type'>
export type Program = {
  type: 'Program',
  body: K.StatementKind[],
  directives: K.DirectiveKind[],
  interpreter: K.InterpreterDirectiveKind | null,
  ...
} & Omit<Node, 'type'>
export type Statement = {...} & Node
export type Function = {
  id: K.IdentifierKind | null,
  params: K.PatternKind[],
  body: K.BlockStatementKind,
  generator: boolean,
  async: boolean,
  expression: boolean,
  defaults: (K.ExpressionKind | null)[],
  rest: K.IdentifierKind | null,
  returnType: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null,
  typeParameters:
    | K.TypeParameterDeclarationKind
    | K.TSTypeParameterDeclarationKind
    | null,
  ...
} & Node
export type Expression = {...} & Node
export type Pattern = {...} & Node
export type Identifier = {
  type: 'Identifier',
  name: string,
  optional: boolean,
  typeAnnotation: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null,
  ...
} & Omit<Expression, 'type'> &
  Omit<Pattern, 'type'>
export type BlockStatement = {
  type: 'BlockStatement',
  body: K.StatementKind[],
  directives: K.DirectiveKind[],
  ...
} & Omit<Statement, 'type'>
export type EmptyStatement = {
  type: 'EmptyStatement',
  ...
} & Omit<Statement, 'type'>
export type ExpressionStatement = {
  type: 'ExpressionStatement',
  expression: K.ExpressionKind,
  ...
} & Omit<Statement, 'type'>
export type IfStatement = {
  type: 'IfStatement',
  test: K.ExpressionKind,
  consequent: K.StatementKind,
  alternate: K.StatementKind | null,
  ...
} & Omit<Statement, 'type'>
export type LabeledStatement = {
  type: 'LabeledStatement',
  label: K.IdentifierKind,
  body: K.StatementKind,
  ...
} & Omit<Statement, 'type'>
export type BreakStatement = {
  type: 'BreakStatement',
  label: K.IdentifierKind | null,
  ...
} & Omit<Statement, 'type'>
export type ContinueStatement = {
  type: 'ContinueStatement',
  label: K.IdentifierKind | null,
  ...
} & Omit<Statement, 'type'>
export type WithStatement = {
  type: 'WithStatement',
  object: K.ExpressionKind,
  body: K.StatementKind,
  ...
} & Omit<Statement, 'type'>
export type SwitchStatement = {
  type: 'SwitchStatement',
  discriminant: K.ExpressionKind,
  cases: K.SwitchCaseKind[],
  lexical: boolean,
  ...
} & Omit<Statement, 'type'>
export type SwitchCase = {
  type: 'SwitchCase',
  test: K.ExpressionKind | null,
  consequent: K.StatementKind[],
  ...
} & Omit<Node, 'type'>
export type ReturnStatement = {
  type: 'ReturnStatement',
  argument: K.ExpressionKind | null,
  ...
} & Omit<Statement, 'type'>
export type ThrowStatement = {
  type: 'ThrowStatement',
  argument: K.ExpressionKind,
  ...
} & Omit<Statement, 'type'>
export type TryStatement = {
  type: 'TryStatement',
  block: K.BlockStatementKind,
  handler: K.CatchClauseKind | null,
  handlers: K.CatchClauseKind[],
  guardedHandlers: K.CatchClauseKind[],
  finalizer: K.BlockStatementKind | null,
  ...
} & Omit<Statement, 'type'>
export type CatchClause = {
  type: 'CatchClause',
  param: K.PatternKind | null,
  guard: K.ExpressionKind | null,
  body: K.BlockStatementKind,
  ...
} & Omit<Node, 'type'>
export type WhileStatement = {
  type: 'WhileStatement',
  test: K.ExpressionKind,
  body: K.StatementKind,
  ...
} & Omit<Statement, 'type'>
export type DoWhileStatement = {
  type: 'DoWhileStatement',
  body: K.StatementKind,
  test: K.ExpressionKind,
  ...
} & Omit<Statement, 'type'>
export type ForStatement = {
  type: 'ForStatement',
  init: K.VariableDeclarationKind | K.ExpressionKind | null,
  test: K.ExpressionKind | null,
  update: K.ExpressionKind | null,
  body: K.StatementKind,
  ...
} & Omit<Statement, 'type'>
export type Declaration = {...} & Statement
export type VariableDeclaration = {
  type: 'VariableDeclaration',
  kind: 'var' | 'let' | 'const',
  declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[],
  ...
} & Omit<Declaration, 'type'>
export type ForInStatement = {
  type: 'ForInStatement',
  left: K.VariableDeclarationKind | K.ExpressionKind,
  right: K.ExpressionKind,
  body: K.StatementKind,
  ...
} & Omit<Statement, 'type'>
export type DebuggerStatement = {
  type: 'DebuggerStatement',
  ...
} & Omit<Statement, 'type'>
export type FunctionDeclaration = {
  type: 'FunctionDeclaration',
  id: K.IdentifierKind,
  ...
} & Omit<Function, 'type' | 'id'> &
  Omit<Declaration, 'type'>
export type FunctionExpression = {
  type: 'FunctionExpression',
  ...
} & Omit<Function, 'type'> &
  Omit<Expression, 'type'>
export type VariableDeclarator = {
  type: 'VariableDeclarator',
  id: K.PatternKind,
  init: K.ExpressionKind | null,
  ...
} & Omit<Node, 'type'>
export type ThisExpression = {
  type: 'ThisExpression',
  ...
} & Omit<Expression, 'type'>
export type ArrayExpression = {
  type: 'ArrayExpression',
  elements: (
    | K.ExpressionKind
    | K.SpreadElementKind
    | K.RestElementKind
    | null
  )[],
  ...
} & Omit<Expression, 'type'>
export type ObjectExpression = {
  type: 'ObjectExpression',
  properties: (
    | K.PropertyKind
    | K.ObjectMethodKind
    | K.ObjectPropertyKind
    | K.SpreadPropertyKind
    | K.SpreadElementKind
  )[],
  ...
} & Omit<Expression, 'type'>
export type Property = {
  type: 'Property',
  kind: 'init' | 'get' | 'set',
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
  value: K.ExpressionKind | K.PatternKind,
  method: boolean,
  shorthand: boolean,
  computed: boolean,
  decorators: K.DecoratorKind[] | null,
  ...
} & Omit<Node, 'type'>
export type Literal = {
  type: 'Literal',
  value: string | boolean | null | number | RegExp,
  regex: {
    pattern: string,
    flags: string,
    ...
  } | null,
  ...
} & Omit<Expression, 'type'>
export type SequenceExpression = {
  type: 'SequenceExpression',
  expressions: K.ExpressionKind[],
  ...
} & Omit<Expression, 'type'>
export type UnaryExpression = {
  type: 'UnaryExpression',
  operator: '-' | '+' | '!' | '~' | 'typeof' | 'void' | 'delete',
  argument: K.ExpressionKind,
  prefix: boolean,
  ...
} & Omit<Expression, 'type'>
export type BinaryExpression = {
  type: 'BinaryExpression',
  operator:
    | '=='
    | '!='
    | '==='
    | '!=='
    | '<'
    | '<='
    | '>'
    | '>='
    | '<<'
    | '>>'
    | '>>>'
    | '+'
    | '-'
    | '*'
    | '/'
    | '%'
    | '**'
    | '&'
    | '|'
    | '^'
    | 'in'
    | 'instanceof',
  left: K.ExpressionKind,
  right: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>
export type AssignmentExpression = {
  type: 'AssignmentExpression',
  operator:
    | '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '<<='
    | '>>='
    | '>>>='
    | '|='
    | '^='
    | '&=',
  left: K.PatternKind | K.MemberExpressionKind,
  right: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>
export type MemberExpression = {
  type: 'MemberExpression',
  object: K.ExpressionKind,
  property: K.IdentifierKind | K.ExpressionKind,
  computed: boolean,
  ...
} & Omit<Expression, 'type'>
export type UpdateExpression = {
  type: 'UpdateExpression',
  operator: '++' | '--',
  argument: K.ExpressionKind,
  prefix: boolean,
  ...
} & Omit<Expression, 'type'>
export type LogicalExpression = {
  type: 'LogicalExpression',
  operator: '||' | '&&' | '??',
  left: K.ExpressionKind,
  right: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>
export type ConditionalExpression = {
  type: 'ConditionalExpression',
  test: K.ExpressionKind,
  consequent: K.ExpressionKind,
  alternate: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>
export type NewExpression = {
  type: 'NewExpression',
  callee: K.ExpressionKind,
  arguments: (K.ExpressionKind | K.SpreadElementKind)[],
  ...
} & Omit<Expression, 'type'>
export type CallExpression = {
  type: 'CallExpression',
  callee: K.ExpressionKind,
  arguments: (K.ExpressionKind | K.SpreadElementKind)[],
  ...
} & Omit<Expression, 'type'>
export type RestElement = {
  type: 'RestElement',
  argument: K.PatternKind,
  typeAnnotation: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null,
  ...
} & Omit<Pattern, 'type'>
export type TypeAnnotation = {
  type: 'TypeAnnotation',
  typeAnnotation: K.FlowTypeKind,
  ...
} & Omit<Node, 'type'>
export type TSTypeAnnotation = {
  type: 'TSTypeAnnotation',
  typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind,
  ...
} & Omit<Node, 'type'>
export type SpreadElementPattern = {
  type: 'SpreadElementPattern',
  argument: K.PatternKind,
  ...
} & Omit<Pattern, 'type'>
export type ArrowFunctionExpression = {
  type: 'ArrowFunctionExpression',
  id: null,
  body: K.BlockStatementKind | K.ExpressionKind,
  generator: false,
  ...
} & Omit<Function, 'type' | 'id' | 'body' | 'generator'> &
  Omit<Expression, 'type'>
export type ForOfStatement = {
  type: 'ForOfStatement',
  left: K.VariableDeclarationKind | K.PatternKind,
  right: K.ExpressionKind,
  body: K.StatementKind,
  ...
} & Omit<Statement, 'type'>
export type YieldExpression = {
  type: 'YieldExpression',
  argument: K.ExpressionKind | null,
  delegate: boolean,
  ...
} & Omit<Expression, 'type'>
export type GeneratorExpression = {
  type: 'GeneratorExpression',
  body: K.ExpressionKind,
  blocks: K.ComprehensionBlockKind[],
  filter: K.ExpressionKind | null,
  ...
} & Omit<Expression, 'type'>
export type ComprehensionBlock = {
  type: 'ComprehensionBlock',
  left: K.PatternKind,
  right: K.ExpressionKind,
  each: boolean,
  ...
} & Omit<Node, 'type'>
export type ComprehensionExpression = {
  type: 'ComprehensionExpression',
  body: K.ExpressionKind,
  blocks: K.ComprehensionBlockKind[],
  filter: K.ExpressionKind | null,
  ...
} & Omit<Expression, 'type'>
export type ObjectProperty = {
  shorthand: boolean,
  type: 'ObjectProperty',
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
  value: K.ExpressionKind | K.PatternKind,
  accessibility: K.LiteralKind | null,
  computed: boolean,
  ...
} & Omit<Node, 'type'>
export type PropertyPattern = {
  type: 'PropertyPattern',
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
  pattern: K.PatternKind,
  computed: boolean,
  ...
} & Omit<Pattern, 'type'>
export type ObjectPattern = {
  type: 'ObjectPattern',
  properties: (
    | K.PropertyKind
    | K.PropertyPatternKind
    | K.SpreadPropertyPatternKind
    | K.SpreadPropertyKind
    | K.ObjectPropertyKind
    | K.RestPropertyKind
  )[],
  typeAnnotation: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null,
  decorators: K.DecoratorKind[] | null,
  ...
} & Omit<Pattern, 'type'>
export type ArrayPattern = {
  type: 'ArrayPattern',
  elements: (K.PatternKind | K.SpreadElementKind | null)[],
  ...
} & Omit<Pattern, 'type'>
export type MethodDefinition = {
  type: 'MethodDefinition',
  kind: 'constructor' | 'method' | 'get' | 'set',
  key: K.ExpressionKind,
  value: K.FunctionKind,
  computed: boolean,
  static: boolean,
  decorators: K.DecoratorKind[] | null,
  ...
} & Omit<Declaration, 'type'>
export type SpreadElement = {
  type: 'SpreadElement',
  argument: K.ExpressionKind,
  ...
} & Omit<Node, 'type'>
export type AssignmentPattern = {
  type: 'AssignmentPattern',
  left: K.PatternKind,
  right: K.ExpressionKind,
  ...
} & Omit<Pattern, 'type'>
export type ClassPropertyDefinition = {
  type: 'ClassPropertyDefinition',
  definition:
    | K.MethodDefinitionKind
    | K.VariableDeclaratorKind
    | K.ClassPropertyDefinitionKind
    | K.ClassPropertyKind,
  ...
} & Omit<Declaration, 'type'>
export type ClassProperty = {
  type: 'ClassProperty',
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
  computed: boolean,
  value: K.ExpressionKind | null,
  static: boolean,
  typeAnnotation: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null,
  variance: K.VarianceKind | 'plus' | 'minus' | null,
  access: 'public' | 'private' | 'protected' | void,
  ...
} & Omit<Declaration, 'type'>
export type ClassBody = {
  type: 'ClassBody',
  body: (
    | K.MethodDefinitionKind
    | K.VariableDeclaratorKind
    | K.ClassPropertyDefinitionKind
    | K.ClassPropertyKind
    | K.ClassPrivatePropertyKind
    | K.ClassMethodKind
    | K.ClassPrivateMethodKind
    | K.TSDeclareMethodKind
    | K.TSCallSignatureDeclarationKind
    | K.TSConstructSignatureDeclarationKind
    | K.TSIndexSignatureKind
    | K.TSMethodSignatureKind
    | K.TSPropertySignatureKind
  )[],
  ...
} & Omit<Declaration, 'type'>
export type ClassDeclaration = {
  type: 'ClassDeclaration',
  id: K.IdentifierKind | null,
  body: K.ClassBodyKind,
  superClass: K.ExpressionKind | null,
  typeParameters:
    | K.TypeParameterDeclarationKind
    | K.TSTypeParameterDeclarationKind
    | null,
  superTypeParameters:
    | K.TypeParameterInstantiationKind
    | K.TSTypeParameterInstantiationKind
    | null,
  implements: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[],
  ...
} & Omit<Declaration, 'type'>
export type ClassExpression = {
  type: 'ClassExpression',
  id: K.IdentifierKind | null,
  body: K.ClassBodyKind,
  superClass: K.ExpressionKind | null,
  typeParameters:
    | K.TypeParameterDeclarationKind
    | K.TSTypeParameterDeclarationKind
    | null,
  superTypeParameters:
    | K.TypeParameterInstantiationKind
    | K.TSTypeParameterInstantiationKind
    | null,
  implements: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[],
  ...
} & Omit<Expression, 'type'>
export type Specifier = {...} & Node
export type ModuleSpecifier = {
  local: K.IdentifierKind | null,
  id: K.IdentifierKind | null,
  name: K.IdentifierKind | null,
  ...
} & Specifier
export type ImportSpecifier = {
  type: 'ImportSpecifier',
  imported: K.IdentifierKind,
  ...
} & Omit<ModuleSpecifier, 'type'>
export type ImportNamespaceSpecifier = {
  type: 'ImportNamespaceSpecifier',
  ...
} & Omit<ModuleSpecifier, 'type'>
export type ImportDefaultSpecifier = {
  type: 'ImportDefaultSpecifier',
  ...
} & Omit<ModuleSpecifier, 'type'>
export type ImportDeclaration = {
  type: 'ImportDeclaration',
  specifiers: (
    | K.ImportSpecifierKind
    | K.ImportNamespaceSpecifierKind
    | K.ImportDefaultSpecifierKind
  )[],
  source: K.LiteralKind,
  importKind: 'value' | 'type',
  ...
} & Omit<Declaration, 'type'>
export type TaggedTemplateExpression = {
  type: 'TaggedTemplateExpression',
  tag: K.ExpressionKind,
  quasi: K.TemplateLiteralKind,
  ...
} & Omit<Expression, 'type'>
export type TemplateLiteral = {
  type: 'TemplateLiteral',
  quasis: K.TemplateElementKind[],
  expressions: K.ExpressionKind[],
  ...
} & Omit<Expression, 'type'>
export type TemplateElement = {
  type: 'TemplateElement',
  value: {
    cooked: string,
    raw: string,
    ...
  },
  tail: boolean,
  ...
} & Omit<Node, 'type'>
export type SpreadProperty = {
  type: 'SpreadProperty',
  argument: K.ExpressionKind,
  ...
} & Omit<Node, 'type'>
export type SpreadPropertyPattern = {
  type: 'SpreadPropertyPattern',
  argument: K.PatternKind,
  ...
} & Omit<Pattern, 'type'>
export type AwaitExpression = {
  type: 'AwaitExpression',
  argument: K.ExpressionKind | null,
  all: boolean,
  ...
} & Omit<Expression, 'type'>
export type JSXAttribute = {
  type: 'JSXAttribute',
  name: K.JSXIdentifierKind | K.JSXNamespacedNameKind,
  value: K.LiteralKind | K.JSXExpressionContainerKind | null,
  ...
} & Omit<Node, 'type'>
export type JSXIdentifier = {
  type: 'JSXIdentifier',
  name: string,
  ...
} & Omit<Identifier, 'type' | 'name'>
export type JSXNamespacedName = {
  type: 'JSXNamespacedName',
  namespace: K.JSXIdentifierKind,
  name: K.JSXIdentifierKind,
  ...
} & Omit<Node, 'type'>
export type JSXExpressionContainer = {
  type: 'JSXExpressionContainer',
  expression: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>
export type JSXMemberExpression = {
  type: 'JSXMemberExpression',
  object: K.JSXIdentifierKind | K.JSXMemberExpressionKind,
  property: K.JSXIdentifierKind,
  computed: boolean,
  ...
} & Omit<MemberExpression, 'type' | 'object' | 'property' | 'computed'>
export type JSXSpreadAttribute = {
  type: 'JSXSpreadAttribute',
  argument: K.ExpressionKind,
  ...
} & Omit<Node, 'type'>
export type JSXElement = {
  type: 'JSXElement',
  openingElement: K.JSXOpeningElementKind,
  closingElement: K.JSXClosingElementKind | null,
  children: (
    | K.JSXElementKind
    | K.JSXExpressionContainerKind
    | K.JSXFragmentKind
    | K.JSXTextKind
    | K.LiteralKind
  )[],
  name:
    | K.JSXIdentifierKind
    | K.JSXNamespacedNameKind
    | K.JSXMemberExpressionKind,
  selfClosing: boolean,
  attributes: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[],
  ...
} & Omit<Expression, 'type'>
export type JSXOpeningElement = {
  type: 'JSXOpeningElement',
  name:
    | K.JSXIdentifierKind
    | K.JSXNamespacedNameKind
    | K.JSXMemberExpressionKind,
  attributes: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[],
  selfClosing: boolean,
  ...
} & Omit<Node, 'type'>
export type JSXClosingElement = {
  type: 'JSXClosingElement',
  name:
    | K.JSXIdentifierKind
    | K.JSXNamespacedNameKind
    | K.JSXMemberExpressionKind,
  ...
} & Omit<Node, 'type'>
export type JSXFragment = {
  type: 'JSXFragment',
  openingElement: K.JSXOpeningFragmentKind,
  closingElement: K.JSXClosingFragmentKind,
  children: (
    | K.JSXElementKind
    | K.JSXExpressionContainerKind
    | K.JSXFragmentKind
    | K.JSXTextKind
    | K.LiteralKind
  )[],
  ...
} & Omit<Expression, 'type'>
export type JSXText = {
  type: 'JSXText',
  value: string,
  ...
} & Omit<Literal, 'type' | 'value'>
export type JSXOpeningFragment = {
  type: 'JSXOpeningFragment',
  ...
} & Omit<Node, 'type'>
export type JSXClosingFragment = {
  type: 'JSXClosingFragment',
  ...
} & Omit<Node, 'type'>
export type JSXEmptyExpression = {
  type: 'JSXEmptyExpression',
  ...
} & Omit<Expression, 'type'>
export type JSXSpreadChild = {
  type: 'JSXSpreadChild',
  expression: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>
export type TypeParameterDeclaration = {
  type: 'TypeParameterDeclaration',
  params: K.TypeParameterKind[],
  ...
} & Omit<Node, 'type'>
export type TSTypeParameterDeclaration = {
  type: 'TSTypeParameterDeclaration',
  params: K.TSTypeParameterKind[],
  ...
} & Omit<Declaration, 'type'>
export type TypeParameterInstantiation = {
  type: 'TypeParameterInstantiation',
  params: K.FlowTypeKind[],
  ...
} & Omit<Node, 'type'>
export type TSTypeParameterInstantiation = {
  type: 'TSTypeParameterInstantiation',
  params: K.TSTypeKind[],
  ...
} & Omit<Node, 'type'>
export type ClassImplements = {
  type: 'ClassImplements',
  id: K.IdentifierKind,
  superClass: K.ExpressionKind | null,
  typeParameters: K.TypeParameterInstantiationKind | null,
  ...
} & Omit<Node, 'type'>
export type TSType = {...} & Node
export interface TSHasOptionalTypeParameterInstantiation {
  typeParameters: K.TSTypeParameterInstantiationKind | null;
}
export type TSExpressionWithTypeArguments = {
  type: 'TSExpressionWithTypeArguments',
  expression: K.IdentifierKind | K.TSQualifiedNameKind,
  ...
} & Omit<TSType, 'type'> &
  TSHasOptionalTypeParameterInstantiation
export type Flow = {...} & Node
export type FlowType = {...} & Flow
export type AnyTypeAnnotation = {
  type: 'AnyTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>
export type EmptyTypeAnnotation = {
  type: 'EmptyTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>
export type MixedTypeAnnotation = {
  type: 'MixedTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>
export type VoidTypeAnnotation = {
  type: 'VoidTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>
export type NumberTypeAnnotation = {
  type: 'NumberTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>
export type NumberLiteralTypeAnnotation = {
  type: 'NumberLiteralTypeAnnotation',
  value: number,
  raw: string,
  ...
} & Omit<FlowType, 'type'>
export type NumericLiteralTypeAnnotation = {
  type: 'NumericLiteralTypeAnnotation',
  value: number,
  raw: string,
  ...
} & Omit<FlowType, 'type'>
export type StringTypeAnnotation = {
  type: 'StringTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>
export type StringLiteralTypeAnnotation = {
  type: 'StringLiteralTypeAnnotation',
  value: string,
  raw: string,
  ...
} & Omit<FlowType, 'type'>
export type BooleanTypeAnnotation = {
  type: 'BooleanTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>
export type BooleanLiteralTypeAnnotation = {
  type: 'BooleanLiteralTypeAnnotation',
  value: boolean,
  raw: string,
  ...
} & Omit<FlowType, 'type'>
export type NullableTypeAnnotation = {
  type: 'NullableTypeAnnotation',
  typeAnnotation: K.FlowTypeKind,
  ...
} & Omit<FlowType, 'type'>
export type NullLiteralTypeAnnotation = {
  type: 'NullLiteralTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>
export type NullTypeAnnotation = {
  type: 'NullTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>
export type ThisTypeAnnotation = {
  type: 'ThisTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>
export type ExistsTypeAnnotation = {
  type: 'ExistsTypeAnnotation',
  ...
} & Omit<FlowType, 'type'>
export type ExistentialTypeParam = {
  type: 'ExistentialTypeParam',
  ...
} & Omit<FlowType, 'type'>
export type FunctionTypeAnnotation = {
  type: 'FunctionTypeAnnotation',
  params: K.FunctionTypeParamKind[],
  returnType: K.FlowTypeKind,
  rest: K.FunctionTypeParamKind | null,
  typeParameters: K.TypeParameterDeclarationKind | null,
  ...
} & Omit<FlowType, 'type'>
export type FunctionTypeParam = {
  type: 'FunctionTypeParam',
  name: K.IdentifierKind,
  typeAnnotation: K.FlowTypeKind,
  optional: boolean,
  ...
} & Omit<Node, 'type'>
export type ArrayTypeAnnotation = {
  type: 'ArrayTypeAnnotation',
  elementType: K.FlowTypeKind,
  ...
} & Omit<FlowType, 'type'>
export type ObjectTypeAnnotation = {
  type: 'ObjectTypeAnnotation',
  properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[],
  indexers: K.ObjectTypeIndexerKind[],
  callProperties: K.ObjectTypeCallPropertyKind[],
  inexact: boolean | void,
  exact: boolean,
  internalSlots: K.ObjectTypeInternalSlotKind[],
  ...
} & Omit<FlowType, 'type'>
export type ObjectTypeProperty = {
  type: 'ObjectTypeProperty',
  key: K.LiteralKind | K.IdentifierKind,
  value: K.FlowTypeKind,
  optional: boolean,
  variance: K.VarianceKind | 'plus' | 'minus' | null,
  ...
} & Omit<Node, 'type'>
export type ObjectTypeSpreadProperty = {
  type: 'ObjectTypeSpreadProperty',
  argument: K.FlowTypeKind,
  ...
} & Omit<Node, 'type'>
export type ObjectTypeIndexer = {
  type: 'ObjectTypeIndexer',
  id: K.IdentifierKind,
  key: K.FlowTypeKind,
  value: K.FlowTypeKind,
  variance: K.VarianceKind | 'plus' | 'minus' | null,
  ...
} & Omit<Node, 'type'>
export type ObjectTypeCallProperty = {
  type: 'ObjectTypeCallProperty',
  value: K.FunctionTypeAnnotationKind,
  static: boolean,
  ...
} & Omit<Node, 'type'>
export type ObjectTypeInternalSlot = {
  type: 'ObjectTypeInternalSlot',
  id: K.IdentifierKind,
  value: K.FlowTypeKind,
  optional: boolean,
  static: boolean,
  method: boolean,
  ...
} & Omit<Node, 'type'>
export type Variance = {
  type: 'Variance',
  kind: 'plus' | 'minus',
  ...
} & Omit<Node, 'type'>
export type QualifiedTypeIdentifier = {
  type: 'QualifiedTypeIdentifier',
  qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind,
  id: K.IdentifierKind,
  ...
} & Omit<Node, 'type'>
export type GenericTypeAnnotation = {
  type: 'GenericTypeAnnotation',
  id: K.IdentifierKind | K.QualifiedTypeIdentifierKind,
  typeParameters: K.TypeParameterInstantiationKind | null,
  ...
} & Omit<FlowType, 'type'>
export type MemberTypeAnnotation = {
  type: 'MemberTypeAnnotation',
  object: K.IdentifierKind,
  property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind,
  ...
} & Omit<FlowType, 'type'>
export type UnionTypeAnnotation = {
  type: 'UnionTypeAnnotation',
  types: K.FlowTypeKind[],
  ...
} & Omit<FlowType, 'type'>
export type IntersectionTypeAnnotation = {
  type: 'IntersectionTypeAnnotation',
  types: K.FlowTypeKind[],
  ...
} & Omit<FlowType, 'type'>
export type TypeofTypeAnnotation = {
  type: 'TypeofTypeAnnotation',
  argument: K.FlowTypeKind,
  ...
} & Omit<FlowType, 'type'>
export type TypeParameter = {
  type: 'TypeParameter',
  name: string,
  variance: K.VarianceKind | 'plus' | 'minus' | null,
  bound: K.TypeAnnotationKind | null,
  ...
} & Omit<FlowType, 'type'>
export type InterfaceTypeAnnotation = {
  type: 'InterfaceTypeAnnotation',
  body: K.ObjectTypeAnnotationKind,
  extends: K.InterfaceExtendsKind[] | null,
  ...
} & Omit<FlowType, 'type'>
export type InterfaceExtends = {
  type: 'InterfaceExtends',
  id: K.IdentifierKind,
  typeParameters: K.TypeParameterInstantiationKind | null,
  ...
} & Omit<Node, 'type'>
export type InterfaceDeclaration = {
  type: 'InterfaceDeclaration',
  id: K.IdentifierKind,
  typeParameters: K.TypeParameterDeclarationKind | null,
  body: K.ObjectTypeAnnotationKind,
  extends: K.InterfaceExtendsKind[],
  ...
} & Omit<Declaration, 'type'>
export type DeclareInterface = {
  type: 'DeclareInterface',
  ...
} & Omit<InterfaceDeclaration, 'type'>
export type TypeAlias = {
  type: 'TypeAlias',
  id: K.IdentifierKind,
  typeParameters: K.TypeParameterDeclarationKind | null,
  right: K.FlowTypeKind,
  ...
} & Omit<Declaration, 'type'>
export type OpaqueType = {
  type: 'OpaqueType',
  id: K.IdentifierKind,
  typeParameters: K.TypeParameterDeclarationKind | null,
  impltype: K.FlowTypeKind,
  supertype: K.FlowTypeKind,
  ...
} & Omit<Declaration, 'type'>
export type DeclareTypeAlias = {
  type: 'DeclareTypeAlias',
  ...
} & Omit<TypeAlias, 'type'>
export type DeclareOpaqueType = {
  type: 'DeclareOpaqueType',
  ...
} & Omit<TypeAlias, 'type'>
export type TypeCastExpression = {
  type: 'TypeCastExpression',
  expression: K.ExpressionKind,
  typeAnnotation: K.TypeAnnotationKind,
  ...
} & Omit<Expression, 'type'>
export type TupleTypeAnnotation = {
  type: 'TupleTypeAnnotation',
  types: K.FlowTypeKind[],
  ...
} & Omit<FlowType, 'type'>
export type DeclareVariable = {
  type: 'DeclareVariable',
  id: K.IdentifierKind,
  ...
} & Omit<Statement, 'type'>
export type DeclareFunction = {
  type: 'DeclareFunction',
  id: K.IdentifierKind,
  ...
} & Omit<Statement, 'type'>
export type DeclareClass = {
  type: 'DeclareClass',
  ...
} & Omit<InterfaceDeclaration, 'type'>
export type DeclareModule = {
  type: 'DeclareModule',
  id: K.IdentifierKind | K.LiteralKind,
  body: K.BlockStatementKind,
  ...
} & Omit<Statement, 'type'>
export type DeclareModuleExports = {
  type: 'DeclareModuleExports',
  typeAnnotation: K.TypeAnnotationKind,
  ...
} & Omit<Statement, 'type'>
export type DeclareExportDeclaration = {
  type: 'DeclareExportDeclaration',
  default: boolean,
  declaration:
    | K.DeclareVariableKind
    | K.DeclareFunctionKind
    | K.DeclareClassKind
    | K.FlowTypeKind
    | null,
  specifiers: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[],
  source: K.LiteralKind | null,
  ...
} & Omit<Declaration, 'type'>
export type ExportSpecifier = {
  type: 'ExportSpecifier',
  exported: K.IdentifierKind,
  ...
} & Omit<ModuleSpecifier, 'type'>
export type ExportBatchSpecifier = {
  type: 'ExportBatchSpecifier',
  ...
} & Omit<Specifier, 'type'>
export type DeclareExportAllDeclaration = {
  type: 'DeclareExportAllDeclaration',
  source: K.LiteralKind | null,
  ...
} & Omit<Declaration, 'type'>
export type FlowPredicate = {...} & Flow
export type InferredPredicate = {
  type: 'InferredPredicate',
  ...
} & Omit<FlowPredicate, 'type'>
export type DeclaredPredicate = {
  type: 'DeclaredPredicate',
  value: K.ExpressionKind,
  ...
} & Omit<FlowPredicate, 'type'>
export type ExportDeclaration = {
  type: 'ExportDeclaration',
  default: boolean,
  declaration: K.DeclarationKind | K.ExpressionKind | null,
  specifiers: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[],
  source: K.LiteralKind | null,
  ...
} & Omit<Declaration, 'type'>
export type Block = {
  type: 'Block',
  ...
} & Comment
export type Line = {
  type: 'Line',
  ...
} & Comment
export type Noop = {
  type: 'Noop',
  ...
} & Omit<Statement, 'type'>
export type DoExpression = {
  type: 'DoExpression',
  body: K.StatementKind[],
  ...
} & Omit<Expression, 'type'>
export type Super = {
  type: 'Super',
  ...
} & Omit<Expression, 'type'>
export type BindExpression = {
  type: 'BindExpression',
  object: K.ExpressionKind | null,
  callee: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>
export type Decorator = {
  type: 'Decorator',
  expression: K.ExpressionKind,
  ...
} & Omit<Node, 'type'>
export type MetaProperty = {
  type: 'MetaProperty',
  meta: K.IdentifierKind,
  property: K.IdentifierKind,
  ...
} & Omit<Expression, 'type'>
export type ParenthesizedExpression = {
  type: 'ParenthesizedExpression',
  expression: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'>
export type ExportDefaultDeclaration = {
  type: 'ExportDefaultDeclaration',
  declaration: K.DeclarationKind | K.ExpressionKind,
  ...
} & Omit<Declaration, 'type'>
export type ExportNamedDeclaration = {
  type: 'ExportNamedDeclaration',
  declaration: K.DeclarationKind | null,
  specifiers: K.ExportSpecifierKind[],
  source: K.LiteralKind | null,
  ...
} & Omit<Declaration, 'type'>
export type ExportNamespaceSpecifier = {
  type: 'ExportNamespaceSpecifier',
  exported: K.IdentifierKind,
  ...
} & Omit<Specifier, 'type'>
export type ExportDefaultSpecifier = {
  type: 'ExportDefaultSpecifier',
  exported: K.IdentifierKind,
  ...
} & Omit<Specifier, 'type'>
export type ExportAllDeclaration = {
  type: 'ExportAllDeclaration',
  exported: K.IdentifierKind | null,
  source: K.LiteralKind,
  ...
} & Omit<Declaration, 'type'>
export type CommentBlock = {
  type: 'CommentBlock',
  ...
} & Comment
export type CommentLine = {
  type: 'CommentLine',
  ...
} & Comment
export type Directive = {
  type: 'Directive',
  value: K.DirectiveLiteralKind,
  ...
} & Omit<Node, 'type'>
export type DirectiveLiteral = {
  type: 'DirectiveLiteral',
  value: string,
  ...
} & Omit<Node, 'type'> &
  Omit<Expression, 'type'>
export type InterpreterDirective = {
  type: 'InterpreterDirective',
  value: string,
  ...
} & Omit<Node, 'type'>
export type StringLiteral = {
  type: 'StringLiteral',
  value: string,
  ...
} & Omit<Literal, 'type' | 'value'>
export type NumericLiteral = {
  type: 'NumericLiteral',
  value: number,
  raw: string | null,
  extra: {
    rawValue: number,
    raw: string,
    ...
  },
  ...
} & Omit<Literal, 'type' | 'value'>
export type BigIntLiteral = {
  type: 'BigIntLiteral',
  value: string | number,
  extra: {
    rawValue: string,
    raw: string,
    ...
  },
  ...
} & Omit<Literal, 'type' | 'value'>
export type NullLiteral = {
  type: 'NullLiteral',
  value: null,
  ...
} & Omit<Literal, 'type' | 'value'>
export type BooleanLiteral = {
  type: 'BooleanLiteral',
  value: boolean,
  ...
} & Omit<Literal, 'type' | 'value'>
export type RegExpLiteral = {
  type: 'RegExpLiteral',
  pattern: string,
  flags: string,
  value: RegExp,
  ...
} & Omit<Literal, 'type' | 'value'>
export type ObjectMethod = {
  type: 'ObjectMethod',
  kind: 'method' | 'get' | 'set',
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
  params: K.PatternKind[],
  body: K.BlockStatementKind,
  computed: boolean,
  generator: boolean,
  async: boolean,
  accessibility: K.LiteralKind | null,
  decorators: K.DecoratorKind[] | null,
  ...
} & Omit<Node, 'type'> &
  Omit<Function, 'type' | 'params' | 'body' | 'generator' | 'async'>
export type ClassPrivateProperty = {
  type: 'ClassPrivateProperty',
  key: K.PrivateNameKind,
  value: K.ExpressionKind | null,
  ...
} & Omit<ClassProperty, 'type' | 'key' | 'value'>
export type ClassMethod = {
  type: 'ClassMethod',
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
  kind: 'get' | 'set' | 'method' | 'constructor',
  body: K.BlockStatementKind,
  computed: boolean,
  static: boolean | null,
  abstract: boolean | null,
  access: 'public' | 'private' | 'protected' | null,
  accessibility: 'public' | 'private' | 'protected' | null,
  decorators: K.DecoratorKind[] | null,
  optional: boolean | null,
  ...
} & Omit<Declaration, 'type'> &
  Omit<Function, 'type' | 'body'>
export type ClassPrivateMethod = {
  type: 'ClassPrivateMethod',
  key: K.PrivateNameKind,
  kind: 'get' | 'set' | 'method' | 'constructor',
  body: K.BlockStatementKind,
  computed: boolean,
  static: boolean | null,
  abstract: boolean | null,
  access: 'public' | 'private' | 'protected' | null,
  accessibility: 'public' | 'private' | 'protected' | null,
  decorators: K.DecoratorKind[] | null,
  optional: boolean | null,
  ...
} & Omit<Declaration, 'type'> &
  Omit<Function, 'type' | 'body'>
export type PrivateName = {
  type: 'PrivateName',
  id: K.IdentifierKind,
  ...
} & Omit<Expression, 'type'> &
  Omit<Pattern, 'type'>
export type RestProperty = {
  type: 'RestProperty',
  argument: K.ExpressionKind,
  ...
} & Omit<Node, 'type'>
export type ForAwaitStatement = {
  type: 'ForAwaitStatement',
  left: K.VariableDeclarationKind | K.ExpressionKind,
  right: K.ExpressionKind,
  body: K.StatementKind,
  ...
} & Omit<Statement, 'type'>
export type Import = {
  type: 'Import',
  ...
} & Omit<Expression, 'type'>
export type TSQualifiedName = {
  type: 'TSQualifiedName',
  left: K.IdentifierKind | K.TSQualifiedNameKind,
  right: K.IdentifierKind | K.TSQualifiedNameKind,
  ...
} & Omit<Node, 'type'>
export type TSTypeReference = {
  type: 'TSTypeReference',
  typeName: K.IdentifierKind | K.TSQualifiedNameKind,
  ...
} & Omit<TSType, 'type'> &
  TSHasOptionalTypeParameterInstantiation
export interface TSHasOptionalTypeParameters {
  typeParameters: K.TSTypeParameterDeclarationKind | null | void;
}
export interface TSHasOptionalTypeAnnotation {
  typeAnnotation: K.TSTypeAnnotationKind | null;
}
export type TSAsExpression = {
  type: 'TSAsExpression',
  expression: K.ExpressionKind,
  typeAnnotation: K.TSTypeKind,
  extra: {
    parenthesized: boolean,
    ...
  } | null,
  ...
} & Omit<Expression, 'type'> &
  Omit<Pattern, 'type'>
export type TSNonNullExpression = {
  type: 'TSNonNullExpression',
  expression: K.ExpressionKind,
  ...
} & Omit<Expression, 'type'> &
  Omit<Pattern, 'type'>
export type TSAnyKeyword = {
  type: 'TSAnyKeyword',
  ...
} & Omit<TSType, 'type'>
export type TSBigIntKeyword = {
  type: 'TSBigIntKeyword',
  ...
} & Omit<TSType, 'type'>
export type TSBooleanKeyword = {
  type: 'TSBooleanKeyword',
  ...
} & Omit<TSType, 'type'>
export type TSNeverKeyword = {
  type: 'TSNeverKeyword',
  ...
} & Omit<TSType, 'type'>
export type TSNullKeyword = {
  type: 'TSNullKeyword',
  ...
} & Omit<TSType, 'type'>
export type TSNumberKeyword = {
  type: 'TSNumberKeyword',
  ...
} & Omit<TSType, 'type'>
export type TSObjectKeyword = {
  type: 'TSObjectKeyword',
  ...
} & Omit<TSType, 'type'>
export type TSStringKeyword = {
  type: 'TSStringKeyword',
  ...
} & Omit<TSType, 'type'>
export type TSSymbolKeyword = {
  type: 'TSSymbolKeyword',
  ...
} & Omit<TSType, 'type'>
export type TSUndefinedKeyword = {
  type: 'TSUndefinedKeyword',
  ...
} & Omit<TSType, 'type'>
export type TSUnknownKeyword = {
  type: 'TSUnknownKeyword',
  ...
} & Omit<TSType, 'type'>
export type TSVoidKeyword = {
  type: 'TSVoidKeyword',
  ...
} & Omit<TSType, 'type'>
export type TSThisType = {
  type: 'TSThisType',
  ...
} & Omit<TSType, 'type'>
export type TSArrayType = {
  type: 'TSArrayType',
  elementType: K.TSTypeKind,
  ...
} & Omit<TSType, 'type'>
export type TSLiteralType = {
  type: 'TSLiteralType',
  literal:
    | K.NumericLiteralKind
    | K.StringLiteralKind
    | K.BooleanLiteralKind
    | K.TemplateLiteralKind
    | K.UnaryExpressionKind,
  ...
} & Omit<TSType, 'type'>
export type TSUnionType = {
  type: 'TSUnionType',
  types: K.TSTypeKind[],
  ...
} & Omit<TSType, 'type'>
export type TSIntersectionType = {
  type: 'TSIntersectionType',
  types: K.TSTypeKind[],
  ...
} & Omit<TSType, 'type'>
export type TSConditionalType = {
  type: 'TSConditionalType',
  checkType: K.TSTypeKind,
  extendsType: K.TSTypeKind,
  trueType: K.TSTypeKind,
  falseType: K.TSTypeKind,
  ...
} & Omit<TSType, 'type'>
export type TSInferType = {
  type: 'TSInferType',
  typeParameter: K.TSTypeParameterKind,
  ...
} & Omit<TSType, 'type'>
export type TSTypeParameter = {
  type: 'TSTypeParameter',
  name: string,
  constraint: K.TSTypeKind | void,
  default: K.TSTypeKind | void,
  ...
} & Omit<Identifier, 'type' | 'name'>
export type TSParenthesizedType = {
  type: 'TSParenthesizedType',
  typeAnnotation: K.TSTypeKind,
  ...
} & Omit<TSType, 'type'>
export type TSFunctionType = {
  type: 'TSFunctionType',
  parameters: (
    | K.IdentifierKind
    | K.RestElementKind
    | K.ArrayPatternKind
    | K.ObjectPatternKind
  )[],
  ...
} & Omit<TSType, 'type'> &
  TSHasOptionalTypeParameters &
  TSHasOptionalTypeAnnotation
export type TSConstructorType = {
  type: 'TSConstructorType',
  parameters: (
    | K.IdentifierKind
    | K.RestElementKind
    | K.ArrayPatternKind
    | K.ObjectPatternKind
  )[],
  ...
} & Omit<TSType, 'type'> &
  TSHasOptionalTypeParameters &
  TSHasOptionalTypeAnnotation
export type TSDeclareFunction = {
  type: 'TSDeclareFunction',
  declare: boolean,
  async: boolean,
  generator: boolean,
  id: K.IdentifierKind | null,
  params: K.PatternKind[],
  returnType: K.TSTypeAnnotationKind | K.NoopKind | null,
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeParameters
export type TSDeclareMethod = {
  type: 'TSDeclareMethod',
  async: boolean,
  generator: boolean,
  params: K.PatternKind[],
  abstract: boolean,
  accessibility: 'public' | 'private' | 'protected' | void,
  static: boolean,
  computed: boolean,
  optional: boolean,
  key:
    | K.IdentifierKind
    | K.StringLiteralKind
    | K.NumericLiteralKind
    | K.ExpressionKind,
  kind: 'get' | 'set' | 'method' | 'constructor',
  access: 'public' | 'private' | 'protected' | void,
  decorators: K.DecoratorKind[] | null,
  returnType: K.TSTypeAnnotationKind | K.NoopKind | null,
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeParameters
export type TSMappedType = {
  type: 'TSMappedType',
  readonly: boolean | '+' | '-',
  typeParameter: K.TSTypeParameterKind,
  optional: boolean | '+' | '-',
  typeAnnotation: K.TSTypeKind | null,
  ...
} & Omit<TSType, 'type'>
export type TSTupleType = {
  type: 'TSTupleType',
  elementTypes: K.TSTypeKind[],
  ...
} & Omit<TSType, 'type'>
export type TSRestType = {
  type: 'TSRestType',
  typeAnnotation: K.TSTypeKind,
  ...
} & Omit<TSType, 'type'>
export type TSOptionalType = {
  type: 'TSOptionalType',
  typeAnnotation: K.TSTypeKind,
  ...
} & Omit<TSType, 'type'>
export type TSIndexedAccessType = {
  type: 'TSIndexedAccessType',
  objectType: K.TSTypeKind,
  indexType: K.TSTypeKind,
  ...
} & Omit<TSType, 'type'>
export type TSTypeOperator = {
  type: 'TSTypeOperator',
  operator: string,
  typeAnnotation: K.TSTypeKind,
  ...
} & Omit<TSType, 'type'>
export type TSIndexSignature = {
  type: 'TSIndexSignature',
  parameters: K.IdentifierKind[],
  readonly: boolean,
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeAnnotation
export type TSPropertySignature = {
  type: 'TSPropertySignature',
  key: K.ExpressionKind,
  computed: boolean,
  readonly: boolean,
  optional: boolean,
  initializer: K.ExpressionKind | null,
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeAnnotation
export type TSMethodSignature = {
  type: 'TSMethodSignature',
  key: K.ExpressionKind,
  computed: boolean,
  optional: boolean,
  parameters: (
    | K.IdentifierKind
    | K.RestElementKind
    | K.ArrayPatternKind
    | K.ObjectPatternKind
  )[],
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeParameters &
  TSHasOptionalTypeAnnotation
export type TSTypePredicate = {
  type: 'TSTypePredicate',
  parameterName: K.IdentifierKind | K.TSThisTypeKind,
  typeAnnotation: K.TSTypeAnnotationKind,
  ...
} & Omit<TSTypeAnnotation, 'type' | 'typeAnnotation'>
export type TSCallSignatureDeclaration = {
  type: 'TSCallSignatureDeclaration',
  parameters: (
    | K.IdentifierKind
    | K.RestElementKind
    | K.ArrayPatternKind
    | K.ObjectPatternKind
  )[],
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeParameters &
  TSHasOptionalTypeAnnotation
export type TSConstructSignatureDeclaration = {
  type: 'TSConstructSignatureDeclaration',
  parameters: (
    | K.IdentifierKind
    | K.RestElementKind
    | K.ArrayPatternKind
    | K.ObjectPatternKind
  )[],
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeParameters &
  TSHasOptionalTypeAnnotation
export type TSEnumMember = {
  type: 'TSEnumMember',
  id: K.IdentifierKind | K.StringLiteralKind,
  initializer: K.ExpressionKind | null,
  ...
} & Omit<Node, 'type'>
export type TSTypeQuery = {
  type: 'TSTypeQuery',
  exprName: K.IdentifierKind | K.TSQualifiedNameKind | K.TSImportTypeKind,
  ...
} & Omit<TSType, 'type'>
export type TSImportType = {
  type: 'TSImportType',
  argument: K.StringLiteralKind,
  qualifier: K.IdentifierKind | K.TSQualifiedNameKind | void,
  ...
} & Omit<TSType, 'type'> &
  TSHasOptionalTypeParameterInstantiation
export type TSTypeLiteral = {
  type: 'TSTypeLiteral',
  members: (
    | K.TSCallSignatureDeclarationKind
    | K.TSConstructSignatureDeclarationKind
    | K.TSIndexSignatureKind
    | K.TSMethodSignatureKind
    | K.TSPropertySignatureKind
  )[],
  ...
} & Omit<TSType, 'type'>
export type TSTypeAssertion = {
  type: 'TSTypeAssertion',
  typeAnnotation: K.TSTypeKind,
  expression: K.ExpressionKind,
  extra: {
    parenthesized: boolean,
    ...
  } | null,
  ...
} & Omit<Expression, 'type'> &
  Omit<Pattern, 'type'>
export type TSEnumDeclaration = {
  type: 'TSEnumDeclaration',
  id: K.IdentifierKind,
  const: boolean,
  declare: boolean,
  members: K.TSEnumMemberKind[],
  initializer: K.ExpressionKind | null,
  ...
} & Omit<Declaration, 'type'>
export type TSTypeAliasDeclaration = {
  type: 'TSTypeAliasDeclaration',
  id: K.IdentifierKind,
  declare: boolean,
  typeAnnotation: K.TSTypeKind,
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeParameters
export type TSModuleBlock = {
  type: 'TSModuleBlock',
  body: K.StatementKind[],
  ...
} & Omit<Node, 'type'>
export type TSModuleDeclaration = {
  type: 'TSModuleDeclaration',
  id: K.StringLiteralKind | K.IdentifierKind | K.TSQualifiedNameKind,
  declare: boolean,
  global: boolean,
  body: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null,
  ...
} & Omit<Declaration, 'type'>
export type TSImportEqualsDeclaration = {
  type: 'TSImportEqualsDeclaration',
  id: K.IdentifierKind,
  isExport: boolean,
  moduleReference:
    | K.IdentifierKind
    | K.TSQualifiedNameKind
    | K.TSExternalModuleReferenceKind,
  ...
} & Omit<Declaration, 'type'>
export type TSExternalModuleReference = {
  type: 'TSExternalModuleReference',
  expression: K.StringLiteralKind,
  ...
} & Omit<Declaration, 'type'>
export type TSExportAssignment = {
  type: 'TSExportAssignment',
  expression: K.ExpressionKind,
  ...
} & Omit<Statement, 'type'>
export type TSNamespaceExportDeclaration = {
  type: 'TSNamespaceExportDeclaration',
  id: K.IdentifierKind,
  ...
} & Omit<Declaration, 'type'>
export type TSInterfaceBody = {
  type: 'TSInterfaceBody',
  body: (
    | K.TSCallSignatureDeclarationKind
    | K.TSConstructSignatureDeclarationKind
    | K.TSIndexSignatureKind
    | K.TSMethodSignatureKind
    | K.TSPropertySignatureKind
  )[],
  ...
} & Omit<Node, 'type'>
export type TSInterfaceDeclaration = {
  type: 'TSInterfaceDeclaration',
  id: K.IdentifierKind | K.TSQualifiedNameKind,
  declare: boolean,
  extends: K.TSExpressionWithTypeArgumentsKind[] | null,
  body: K.TSInterfaceBodyKind,
  ...
} & Omit<Declaration, 'type'> &
  TSHasOptionalTypeParameters
export type TSParameterProperty = {
  type: 'TSParameterProperty',
  accessibility: 'public' | 'private' | 'protected' | void,
  readonly: boolean,
  parameter: K.IdentifierKind | K.AssignmentPatternKind,
  ...
} & Omit<Pattern, 'type'>
export type OptionalMemberExpression = {
  type: 'OptionalMemberExpression',
  optional: boolean,
  ...
} & Omit<MemberExpression, 'type'>
export type OptionalCallExpression = {
  type: 'OptionalCallExpression',
  optional: boolean,
  ...
} & Omit<CallExpression, 'type'>
export type ASTNode =
  | File
  | Program
  | Identifier
  | BlockStatement
  | EmptyStatement
  | ExpressionStatement
  | IfStatement
  | LabeledStatement
  | BreakStatement
  | ContinueStatement
  | WithStatement
  | SwitchStatement
  | SwitchCase
  | ReturnStatement
  | ThrowStatement
  | TryStatement
  | CatchClause
  | WhileStatement
  | DoWhileStatement
  | ForStatement
  | VariableDeclaration
  | ForInStatement
  | DebuggerStatement
  | FunctionDeclaration
  | FunctionExpression
  | VariableDeclarator
  | ThisExpression
  | ArrayExpression
  | ObjectExpression
  | Property
  | Literal
  | SequenceExpression
  | UnaryExpression
  | BinaryExpression
  | AssignmentExpression
  | MemberExpression
  | UpdateExpression
  | LogicalExpression
  | ConditionalExpression
  | NewExpression
  | CallExpression
  | RestElement
  | TypeAnnotation
  | TSTypeAnnotation
  | SpreadElementPattern
  | ArrowFunctionExpression
  | ForOfStatement
  | YieldExpression
  | GeneratorExpression
  | ComprehensionBlock
  | ComprehensionExpression
  | ObjectProperty
  | PropertyPattern
  | ObjectPattern
  | ArrayPattern
  | MethodDefinition
  | SpreadElement
  | AssignmentPattern
  | ClassPropertyDefinition
  | ClassProperty
  | ClassBody
  | ClassDeclaration
  | ClassExpression
  | ImportSpecifier
  | ImportNamespaceSpecifier
  | ImportDefaultSpecifier
  | ImportDeclaration
  | TaggedTemplateExpression
  | TemplateLiteral
  | TemplateElement
  | SpreadProperty
  | SpreadPropertyPattern
  | AwaitExpression
  | JSXAttribute
  | JSXIdentifier
  | JSXNamespacedName
  | JSXExpressionContainer
  | JSXMemberExpression
  | JSXSpreadAttribute
  | JSXElement
  | JSXOpeningElement
  | JSXClosingElement
  | JSXFragment
  | JSXText
  | JSXOpeningFragment
  | JSXClosingFragment
  | JSXEmptyExpression
  | JSXSpreadChild
  | TypeParameterDeclaration
  | TSTypeParameterDeclaration
  | TypeParameterInstantiation
  | TSTypeParameterInstantiation
  | ClassImplements
  | TSExpressionWithTypeArguments
  | AnyTypeAnnotation
  | EmptyTypeAnnotation
  | MixedTypeAnnotation
  | VoidTypeAnnotation
  | NumberTypeAnnotation
  | NumberLiteralTypeAnnotation
  | NumericLiteralTypeAnnotation
  | StringTypeAnnotation
  | StringLiteralTypeAnnotation
  | BooleanTypeAnnotation
  | BooleanLiteralTypeAnnotation
  | NullableTypeAnnotation
  | NullLiteralTypeAnnotation
  | NullTypeAnnotation
  | ThisTypeAnnotation
  | ExistsTypeAnnotation
  | ExistentialTypeParam
  | FunctionTypeAnnotation
  | FunctionTypeParam
  | ArrayTypeAnnotation
  | ObjectTypeAnnotation
  | ObjectTypeProperty
  | ObjectTypeSpreadProperty
  | ObjectTypeIndexer
  | ObjectTypeCallProperty
  | ObjectTypeInternalSlot
  | Variance
  | QualifiedTypeIdentifier
  | GenericTypeAnnotation
  | MemberTypeAnnotation
  | UnionTypeAnnotation
  | IntersectionTypeAnnotation
  | TypeofTypeAnnotation
  | TypeParameter
  | InterfaceTypeAnnotation
  | InterfaceExtends
  | InterfaceDeclaration
  | DeclareInterface
  | TypeAlias
  | OpaqueType
  | DeclareTypeAlias
  | DeclareOpaqueType
  | TypeCastExpression
  | TupleTypeAnnotation
  | DeclareVariable
  | DeclareFunction
  | DeclareClass
  | DeclareModule
  | DeclareModuleExports
  | DeclareExportDeclaration
  | ExportSpecifier
  | ExportBatchSpecifier
  | DeclareExportAllDeclaration
  | InferredPredicate
  | DeclaredPredicate
  | ExportDeclaration
  | Block
  | Line
  | Noop
  | DoExpression
  | Super
  | BindExpression
  | Decorator
  | MetaProperty
  | ParenthesizedExpression
  | ExportDefaultDeclaration
  | ExportNamedDeclaration
  | ExportNamespaceSpecifier
  | ExportDefaultSpecifier
  | ExportAllDeclaration
  | CommentBlock
  | CommentLine
  | Directive
  | DirectiveLiteral
  | InterpreterDirective
  | StringLiteral
  | NumericLiteral
  | BigIntLiteral
  | NullLiteral
  | BooleanLiteral
  | RegExpLiteral
  | ObjectMethod
  | ClassPrivateProperty
  | ClassMethod
  | ClassPrivateMethod
  | PrivateName
  | RestProperty
  | ForAwaitStatement
  | Import
  | TSQualifiedName
  | TSTypeReference
  | TSAsExpression
  | TSNonNullExpression
  | TSAnyKeyword
  | TSBigIntKeyword
  | TSBooleanKeyword
  | TSNeverKeyword
  | TSNullKeyword
  | TSNumberKeyword
  | TSObjectKeyword
  | TSStringKeyword
  | TSSymbolKeyword
  | TSUndefinedKeyword
  | TSUnknownKeyword
  | TSVoidKeyword
  | TSThisType
  | TSArrayType
  | TSLiteralType
  | TSUnionType
  | TSIntersectionType
  | TSConditionalType
  | TSInferType
  | TSTypeParameter
  | TSParenthesizedType
  | TSFunctionType
  | TSConstructorType
  | TSDeclareFunction
  | TSDeclareMethod
  | TSMappedType
  | TSTupleType
  | TSRestType
  | TSOptionalType
  | TSIndexedAccessType
  | TSTypeOperator
  | TSIndexSignature
  | TSPropertySignature
  | TSMethodSignature
  | TSTypePredicate
  | TSCallSignatureDeclaration
  | TSConstructSignatureDeclaration
  | TSEnumMember
  | TSTypeQuery
  | TSImportType
  | TSTypeLiteral
  | TSTypeAssertion
  | TSEnumDeclaration
  | TSTypeAliasDeclaration
  | TSModuleBlock
  | TSModuleDeclaration
  | TSImportEqualsDeclaration
  | TSExternalModuleReference
  | TSExportAssignment
  | TSNamespaceExportDeclaration
  | TSInterfaceBody
  | TSInterfaceDeclaration
  | TSParameterProperty
  | OptionalMemberExpression
  | OptionalCallExpression
