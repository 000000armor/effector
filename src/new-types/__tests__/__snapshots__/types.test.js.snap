// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`snapshots 1`] = `
"Command failed: npx tsc -p __fixtures__/typescript

__fixtures__/typescript/types.test.js/#effect.ts: Argument of type '20' is not assignable to parameter of type 'string'.
__fixtures__/typescript/types.test.js/#effect.ts: Argument of type '20' is not assignable to parameter of type 'string'.
__fixtures__/typescript/types.test.js/#filter incorrect.ts: Type 'Event<string>' is not assignable to type 'Event<number>'.
  Types of property 'watch' are incompatible.
    Type '(watcher: (payload: string) => any) => Subscription' is not assignable to type '(watcher: (payload: number) => any) => Subscription'.
      Types of parameters 'watcher' and 'watcher' are incompatible.
        Types of parameters 'payload' and 'payload' are incompatible.
          Type 'string' is not assignable to type 'number'.
__fixtures__/typescript/types.test.js/#map.ts: Type 'Store<string>' is not assignable to type 'Store<number>'.
  Types of property 'getState' are incompatible.
    Type '() => string' is not assignable to type '() => number'.
      Type 'string' is not assignable to type 'number'.
__fixtures__/typescript/types.test.js/#use.ts: Argument of type 'Effect<number, string, any>' is not assignable to parameter of type '(params: void) => unknown'.
  Types of parameters 'payload' and 'params' are incompatible.
    Type 'void' is not assignable to type 'number'.
__fixtures__/typescript/types.test.js/createApi.ts: Type 'Event<number>' is not assignable to type 'Event<string>'.
  Types of property 'watch' are incompatible.
    Type '(watcher: (payload: number) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
      Types of parameters 'watcher' and 'watcher' are incompatible.
        Types of parameters 'payload' and 'payload' are incompatible.
          Type 'number' is not assignable to type 'string'.
__fixtures__/typescript/types.test.js/createApi.ts: Type 'Event<void>' is not assignable to type 'Event<string>'.
  Types of property 'watch' are incompatible.
    Type '(watcher: (payload: void) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
      Types of parameters 'watcher' and 'watcher' are incompatible.
        Types of parameters 'payload' and 'payload' are incompatible.
          Type 'void' is not assignable to type 'string'.
__fixtures__/typescript/types.test.js/createComponent.ts: Type 'number' is not assignable to type 'string'.
__fixtures__/typescript/types.test.js/createComponent.ts: Property 'unknownProp' does not exist on type '{ id: number; }'.
__fixtures__/typescript/types.test.js/createComponent.ts: Type 'string' is not assignable to type 'number'.
__fixtures__/typescript/types.test.js/createDomain.ts: Argument of type '234' is not assignable to parameter of type 'string | undefined'.
__fixtures__/typescript/types.test.js/createDomain.ts: Argument of type '{ foo: boolean; }' is not assignable to parameter of type 'string'.
__fixtures__/typescript/types.test.js/createGate.ts: Type 'number' does not satisfy the constraint 'object'.
__fixtures__/typescript/types.test.js/createGate.ts: Argument of type '1' is not assignable to parameter of type '{ a: number; } | undefined'.
__fixtures__/typescript/types.test.js/createGate.ts: Argument of type '{}' is not assignable to parameter of type '{ a: number; }'.
  Property 'a' is missing in type '{}' but required in type '{ a: number; }'.
__fixtures__/typescript/types.test.js/createStore.ts: Type 'Store<number>' is not assignable to type 'Store<string>'.
  Types of property 'getState' are incompatible.
    Type '() => number' is not assignable to type '() => string'.
      Type 'number' is not assignable to type 'string'.
__fixtures__/typescript/types.test.js/effect by event with handler.ts: Type 'Event<{ a: string; b: boolean; }>' is not assignable to type 'Event<number>'.
  Types of property 'watch' are incompatible.
    Type '(watcher: (payload: { a: string; b: boolean; }) => any) => Subscription' is not assignable to type '(watcher: (payload: number) => any) => Subscription'.
      Types of parameters 'watcher' and 'watcher' are incompatible.
        Types of parameters 'payload' and 'payload' are incompatible.
          Type '{ a: string; b: boolean; }' is not assignable to type 'number'.
__fixtures__/typescript/types.test.js/effect by event.ts: Type 'Event<string>' is not assignable to type 'Event<number>'.
__fixtures__/typescript/types.test.js/event by event with handler.ts: Type 'Event<{ a: string; b: boolean; }>' is not assignable to type 'Event<string>'.
  Types of property 'watch' are incompatible.
    Type '(watcher: (payload: { a: string; b: boolean; }) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
      Types of parameters 'watcher' and 'watcher' are incompatible.
        Types of parameters 'payload' and 'payload' are incompatible.
          Type '{ a: string; b: boolean; }' is not assignable to type 'string'.
__fixtures__/typescript/types.test.js/event by event.ts: Type 'Event<number>' is not assignable to type 'Event<string>'.
__fixtures__/typescript/types.test.js/incorrect case.ts: Type 'Event<string>' is not assignable to type 'Event<number>'.
__fixtures__/typescript/types.test.js/launch.ts: Argument of type '\\"\\"' is not assignable to parameter of type 'number'.
__fixtures__/typescript/types.test.js/no false-positive (should be type error).ts: Type 'Effect<string, string, Error>' is not assignable to type 'Effect<number, number, Error>'.
  Types of property 'done' are incompatible.
    Type 'Event<{ params: string; result: string; }>' is not assignable to type 'Event<{ params: number; result: number; }>'.
      Types of property 'watch' are incompatible.
        Type '(watcher: (payload: { params: string; result: string; }) => any) => Subscription' is not assignable to type '(watcher: (payload: { params: number; result: number; }) => any) => Subscription'.
          Types of parameters 'watcher' and 'watcher' are incompatible.
            Types of parameters 'payload' and 'payload' are incompatible.
              Type '{ params: string; result: string; }' is not assignable to type '{ params: number; result: number; }'.
__fixtures__/typescript/types.test.js/snapshots.ts: 'await' expression is only allowed within an async function.
__fixtures__/typescript/types.test.js/split arguments no false-positive.ts: Type 'null' is not assignable to type 'boolean'.
__fixtures__/typescript/types.test.js/split arguments no false-positive.ts: Type '(list: null) => true' is not assignable to type '(payload: string[]) => boolean'.
  Types of parameters 'list' and 'payload' are incompatible.
    Type 'string[]' is not assignable to type 'null'.
__fixtures__/typescript/types.test.js/split arguments no false-positive.ts: Type '(list: number[]) => true' is not assignable to type '(payload: string[]) => boolean'.
  Types of parameters 'list' and 'payload' are incompatible.
    Type 'string[]' is not assignable to type 'number[]'.
      Type 'string' is not assignable to type 'number'.
__fixtures__/typescript/types.test.js/split result no false-positive.ts: Type 'Event<string[]>' is not assignable to type 'Event<number>'.
  Types of property 'watch' are incompatible.
    Type '(watcher: (payload: string[]) => any) => Subscription' is not assignable to type '(watcher: (payload: number) => any) => Subscription'.
      Types of parameters 'watcher' and 'watcher' are incompatible.
        Types of parameters 'payload' and 'payload' are incompatible.
          Type 'string[]' is not assignable to type 'number'.
__fixtures__/typescript/types.test.js/split result no false-positive.ts: Type 'Event<string[]>' is not assignable to type 'null'.
__fixtures__/typescript/types.test.js/split result no false-positive.ts: Type 'Event<string[]>' is not assignable to type 'Event<number>'.
__fixtures__/typescript/types.test.js/split result no false-positive.ts: Type 'Event<string[]>' is not assignable to type 'null'.
__fixtures__/typescript/types.test.js/store by event with handler.ts: Type 'Event<{ a: string; b: boolean; }>' is not assignable to type 'Event<string>'.
  Types of property 'watch' are incompatible.
    Type '(watcher: (payload: { a: string; b: boolean; }) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
      Types of parameters 'watcher' and 'watcher' are incompatible.
        Types of parameters 'payload' and 'payload' are incompatible.
          Type '{ a: string; b: boolean; }' is not assignable to type 'string'.
__fixtures__/typescript/types.test.js/store by event.ts: Type 'Event<number>' is not assignable to type 'Event<string>'.
__fixtures__/typescript/types.test.js/store by store with handler.ts: Type 'Store<{ a: string; b: boolean; }>' is not assignable to type 'Store<string>'.
  Types of property 'getState' are incompatible.
    Type '() => { a: string; b: boolean; }' is not assignable to type '() => string'.
      Type '{ a: string; b: boolean; }' is not assignable to type 'string'.
__fixtures__/typescript/types.test.js/store by store.ts: Type 'Store<boolean>' is not assignable to type 'Store<string>'.
  Types of property 'getState' are incompatible.
    Type '() => boolean' is not assignable to type '() => string'.
      Type 'boolean' is not assignable to type 'string'.
"
`;

exports[`snapshots 2`] = `
"  types/__fixtures__/flow/types.test.js/#effect.js
   | 
   |   });
>  |   effect2(20);
   |           ^ 
   |  Cannot call \`effect2\` with \`20\` bound to \`payload\` 
   |  because number [1] is incompatible with string [2].
   |  
   |   const effect3 = domain.effect('', {
   |     handler: effect1

   | 
   |   });
>  |   effect2(20);
   |           ^^ [1]
   |   const effect3 = domain.effect('', {
   |     handler: effect1

   |   const effect1: Effect<string, number, Error> = domain.effect();
   |   const effect2 = domain.effect('', {
>  |     handler(params: string) {
   |                     ^^^^^^ [2]
   |       return 256;
   |     }

  

  types/__fixtures__/flow/types.test.js/#effect.js
   |     handler: effect1
   |   });
>  |   effect3(20);
   |           ^ 
   |  Cannot call \`effect3\` with \`20\` bound to \`payload\` 
   |  because number [1] is incompatible with string [2].
   |  
   | }

   |     handler: effect1
   |   });
>  |   effect3(20);
   |           ^^ [1]
   | }

   | {
   |   const domain = createDomain();
>  |   const effect1: Effect<string, number, Error> = domain.effect();
   |                         ^^^^^^ [2]
   |   const effect2 = domain.effect('', {
   |     handler(params: string) {

  

  types/__fixtures__/flow/types.test.js/#filter incorrect.js
   |   const event: Event<number> = createEvent();
   |   const filteredEvent_error: Event<number> = event.filter(n => {
>  |     if (n % 2) return n.toString();
   |                       ^^^^^^^^^^^ 
   |  Cannot assign \`event.filter(...)\` to \`filteredEvent_error\` 
   |  because string [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   |   });
   | }

   <BUILTINS>/core.js
>  |     toString(radix?: number): string;
   |                               ^^^^^^ [1]

  types/__fixtures__/flow/types.test.js/#filter incorrect.js
   | {
   |   const event: Event<number> = createEvent();
>  |   const filteredEvent_error: Event<number> = event.filter(n => {
   |                                    ^^^^^^ [2]
   |     if (n % 2) return n.toString();
   |   });

  ../packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  types/__fixtures__/flow/types.test.js/#map.js
   |   const computed = store.map(() => 'hello');
   |   const map_check1: Store<string> = computed;
>  |   const map_check2: Store<number> = computed;
   |                                     ^^^^^^^ 
   |  Cannot assign \`computed\` to \`map_check2\` 
   |  because string [1] is incompatible with number [2] in type argument \`State\` [3].
   |  
   | }

   |   const store = createStore(0);
   |   const computed = store.map(() => 'hello');
>  |   const map_check1: Store<string> = computed;
   |                           ^^^^^^ [1]
   |   const map_check2: Store<number> = computed;
   | }

   |   const computed = store.map(() => 'hello');
   |   const map_check1: Store<string> = computed;
>  |   const map_check2: Store<number> = computed;
   |                           ^^^^^^ [2]
   | }

  ../packages/effector/index.js.flow
   | }
   | 
>  | declare export class Store<State> implements Unit<State> {
   |                            ^^^^^ [3]
   |   +kind: kind;
   |   reset(...triggers: Array<Unit<any>>): this;

  

  types/__fixtures__/flow/types.test.js/createApi.js
   |       event: (n, x: number) => x
   |     });
>  |     const createApi_check2: Event<string> = event;
   |                                             ^^^^ 
   |  Cannot assign \`event\` to \`createApi_check2\` 
   |  because string [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   |   }
   |   {

   |       event: (n, x: number) => x
   |     });
>  |     const createApi_check2: Event<string> = event;
   |                                   ^^^^^^ [1]
   |   }
   |   {

   |       event
   |     } = createApi(store, {
>  |       event: (n, x: number) => x
   |                     ^^^^^^ [2]
   |     });
   |     const createApi_check2: Event<string> = event;

  ../packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  types/__fixtures__/flow/types.test.js/createApi.js
   |       event
   |     } = createApi(store, {
>  |       event: (n, x) => x
   |                        ^ 
   |  Cannot call \`createApi\` with object literal bound to \`api\` 
   |  because string [1] is incompatible with number [2] in the return value of
   |  property \`event\`.
   |  
   |     });
   |     const createApi_check3: Event<string> = event;

   |       event: (n, x) => x
   |     });
>  |     const createApi_check3: Event<string> = event;
   |                                   ^^^^^^ [1]
   |   }
   | }

   | import { createFormApi } from '@effector/forms';
   | {
>  |   const store: Store<number> = createStore(0);
   |                      ^^^^^^ [2]
   |   {
   |     const {

  

  types/__fixtures__/flow/types.test.js/createComponent.js
   |   }) => {
   |     const createComponent_initialProps_check1: number = initialProps.id;
>  |     const createComponent_initialProps_check2: string = initialProps.id;
   |                                                         ^^^^^^^^^^^^^^ 
   |  Cannot assign \`initialProps.id\` to \`createComponent_initialProps_check2\` 
   |  because number [1] is incompatible with string [2].
   |  
   |     const createComponent_initialProps_check3: string = initialProps.unknownProp;
   |     return list.map(list => list[initialProps.id] || {

   |   }>({});
   |   const InitialProps = createComponent((initialProps: {
>  |     id: number
   |         ^^^^^^ [1]
   |   }) => {
   |     const createComponent_initialProps_check1: number = initialProps.id;

   |   }) => {
   |     const createComponent_initialProps_check1: number = initialProps.id;
>  |     const createComponent_initialProps_check2: string = initialProps.id;
   |                                                ^^^^^^ [2]
   |     const createComponent_initialProps_check3: string = initialProps.unknownProp;
   |     return list.map(list => list[initialProps.id] || {

  

  types/__fixtures__/flow/types.test.js/createComponent.js
   |     const createComponent_initialProps_check1: number = initialProps.id;
   |     const createComponent_initialProps_check2: string = initialProps.id;
>  |     const createComponent_initialProps_check3: string = initialProps.unknownProp;
   |                                                                      ^^^^^^^^^^ 
   |  Cannot get \`initialProps.unknownProp\` 
   |  because property \`unknownProp\` is missing in object type [1].
   |  
   |     return list.map(list => list[initialProps.id] || {
   |       text: 'Loading...'

   |     }
   |   }>({});
>  |   const InitialProps = createComponent((initialProps: {
   |                                                       ^^ [1]
   |     id: number
   | ^^^^^^^^^^^^^^
   |   }) => {
   | ^^^
   |     const createComponent_initialProps_check1: number = initialProps.id;
   |     const createComponent_initialProps_check2: string = initialProps.id;

  

  types/__fixtures__/flow/types.test.js/createComponent.js
   |   }, (_, state) => {
   |     const createComponent_initialProps_check4: string = state.text;
>  |     const createComponent_initialProps_check5: number = state.text;
   |                                                         ^^^^^^^^^ 
   |  Cannot assign \`state.text\` to \`createComponent_initialProps_check5\` 
   |  because string [1] is incompatible with number [2].
   |  
   |     return null;
   |   });

   |   const list = createStore<{
   |     [key: number]: {
>  |       text: string
   |             ^^^^^^ [1]
   |     }
   |   }>({});

   |   }, (_, state) => {
   |     const createComponent_initialProps_check4: string = state.text;
>  |     const createComponent_initialProps_check5: number = state.text;
   |                                                ^^^^^^ [2]
   |     return null;
   |   });

  

  types/__fixtures__/flow/types.test.js/createDomain.js
   |   const domain = createDomain();
   |   const domain2 = createDomain('hello');
>  |   const domain3 = createDomain(234);
   |                                ^^ 
   |  Cannot call \`createDomain\` with \`234\` bound to \`domainName\` 
   |  because number [1] is incompatible with string [2].
   |  
   |   const domain4 = createDomain({
   |     foo: true

   |   const domain = createDomain();
   |   const domain2 = createDomain('hello');
>  |   const domain3 = createDomain(234);
   |                                ^^^ [1]
   |   const domain4 = createDomain({
   |     foo: true

  ../packages/effector/index.js.flow
   |   <S>(field: Store<S> | S) => Store<S>,
   | >
>  | declare export function createDomain(domainName?: string): Domain
   |                                                   ^^^^^^ [2]
   | 
   | declare export function sample<A>(config: {|

  

  types/__fixtures__/flow/types.test.js/createDomain.js
   |   const domain2 = createDomain('hello');
   |   const domain3 = createDomain(234);
>  |   const domain4 = createDomain({
   |                                ^
>  |     foo: true
   | ^^^^^^^^^^^^^
>  |   });
   | ^^^ 
   |  Cannot call \`createDomain\` with object literal bound to \`domainName\` 
   |  because object literal [1] is incompatible with string [2].
   |  
   | }

   |   const domain2 = createDomain('hello');
   |   const domain3 = createDomain(234);
>  |   const domain4 = createDomain({
   |                                ^^ [1]
   |     foo: true
   | ^^^^^^^^^^^^^
   |   });
   | ^^^
   | }

  ../packages/effector/index.js.flow
   |   <S>(field: Store<S> | S) => Store<S>,
   | >
>  | declare export function createDomain(domainName?: string): Domain
   |                                                   ^^^^^^ [2]
   | 
   | declare export function sample<A>(config: {|

  

  types/__fixtures__/flow/types.test.js/createGate.js
   | import { createFormApi } from '@effector/forms';
   | {
>  |   const Foo = createGate<number>('foo');
   |                          ^^^^^ 
   |  Cannot call \`createGate\` 
   |  because number [1] is incompatible with object type [2] in type
   |  argument \`Props\`.
   |  
   |   const Bar = createGate<{
   |     a: number

   | import { createFormApi } from '@effector/forms';
   | {
>  |   const Foo = createGate<number>('foo');
   |                          ^^^^^^ [1]
   |   const Bar = createGate<{
   |     a: number

  ../packages/effector-react/index.js.flow
   | declare export function useGate<Props>(Gate: Gate<Props>, props?: Props): void
   | 
>  | declare export function createGate<Props: {...}>(name?: string): Gate<Props>
   |                                           ^^^^^ [2]
   | declare export function createGate<Props>(
   |   name: string,

  

  types/__fixtures__/flow/types.test.js/createGate.js
   |   const Component = () => {
   |     useGate(Foo, 1);
>  |     useGate(Bar, 1);
   |                  ^ 
   |  Cannot call \`useGate\` with \`1\` bound to \`props\` 
   |  because number [1] is incompatible with object type [2].
   |  
   |     useGate(Bar, {
   |       a: 1

   |   const Component = () => {
   |     useGate(Foo, 1);
>  |     useGate(Bar, 1);
   |                  ^^ [1]
   |     useGate(Bar, {
   |       a: 1

   | {
   |   const Foo = createGate<number>('foo');
>  |   const Bar = createGate<{
   |                          ^^ [2]
   |     a: number
   | ^^^^^^^^^^^^^
   |   }>('bar');
   | ^^^
   |   const Baz = createGate<number | null>('baz', null);
   | 

  

  types/__fixtures__/flow/types.test.js/createStore.js
   | {
   |   const createStore_store1: Store<number> = createStore(0);
>  |   const createStore_store2: Store<string> = createStore(0);
   |                                                         ^ 
   |  Cannot assign \`createStore(...)\` to \`createStore_store2\` 
   |  because number [1] is incompatible with string [2] in type argument \`State\` [3].
   |  
   | }

   | {
   |   const createStore_store1: Store<number> = createStore(0);
>  |   const createStore_store2: Store<string> = createStore(0);
   |                                                         ^^ [1]
   | }

   | {
   |   const createStore_store1: Store<number> = createStore(0);
>  |   const createStore_store2: Store<string> = createStore(0);
   |                                   ^^^^^^ [2]
   | }

  ../packages/effector/index.js.flow
   | }
   | 
>  | declare export class Store<State> implements Unit<State> {
   |                            ^^^^^ [3]
   |   +kind: kind;
   |   reset(...triggers: Array<Unit<any>>): this;

  

  types/__fixtures__/flow/types.test.js/effect by event with handler.js
   |     b: boolean,
   |   }> = g;
>  |   const sample_efeh_check2: Event<number> = g;
   |                                             ^ 
   |  Cannot assign \`g\` to \`sample_efeh_check2\` 
   |  because object type [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   | }

   |     b
   |   }));
>  |   const sample_efeh_check1: Event<{
   |                                   ^^ [1]
   |     a: string,
   | ^^^^^^^^^^^^^^
   |     b: boolean,
   | ^^^^^^^^^^^^^^
   |   }> = g;
   | ^^^
   |   const sample_efeh_check2: Event<number> = g;
   | }

   |     b: boolean,
   |   }> = g;
>  |   const sample_efeh_check2: Event<number> = g;
   |                                   ^^^^^^ [2]
   | }

  ../packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  types/__fixtures__/flow/types.test.js/effect by event.js
   |   const g = sample(f, b);
   |   const sample_efe_check1: Event<string> = g;
>  |   const sample_efe_check2: Event<number> = g;
   |                                            ^ 
   |  Cannot assign \`g\` to \`sample_efe_check2\` 
   |  because string [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   | }

   | import { createFormApi } from '@effector/forms';
   | {
>  |   const f = createEffect<string, any, any>();
   |                          ^^^^^^ [1]
   |   const b = createEvent<boolean>();
   |   const g = sample(f, b);

   |   const g = sample(f, b);
   |   const sample_efe_check1: Event<string> = g;
>  |   const sample_efe_check2: Event<number> = g;
   |                                  ^^^^^^ [2]
   | }

  ../packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  types/__fixtures__/flow/types.test.js/event by event with handler.js
   |     b: boolean,
   |   }> = c;
>  |   const sample_eeh_check2: Event<string> = c;
   |                                            ^ 
   |  Cannot assign \`c\` to \`sample_eeh_check2\` 
   |  because object type [1] is incompatible with string [2] in type argument
   |  \`Payload\` [3].
   |  
   | }

   |     b
   |   }));
>  |   const sample_eeh_check1: Event<{
   |                                  ^^ [1]
   |     a: string,
   | ^^^^^^^^^^^^^^
   |     b: boolean,
   | ^^^^^^^^^^^^^^
   |   }> = c;
   | ^^^
   |   const sample_eeh_check2: Event<string> = c;
   | }

   |     b: boolean,
   |   }> = c;
>  |   const sample_eeh_check2: Event<string> = c;
   |                                  ^^^^^^ [2]
   | }

  ../packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  types/__fixtures__/flow/types.test.js/event by event.js
   |   const c = sample(a, b);
   |   const sample_ee_check1: Event<number> = c;
>  |   const sample_ee_check2: Event<string> = c;
   |                                           ^ 
   |  Cannot assign \`c\` to \`sample_ee_check2\` 
   |  because number [1] is incompatible with string [2] in type argument
   |  \`Payload\` [3].
   |  
   | }

   | import { createFormApi } from '@effector/forms';
   | {
>  |   const a = createEvent<number>();
   |                         ^^^^^^ [1]
   |   const b = createEvent<boolean>();
   |   const c = sample(a, b);

   |   const c = sample(a, b);
   |   const sample_ee_check1: Event<number> = c;
>  |   const sample_ee_check2: Event<string> = c;
   |                                 ^^^^^^ [2]
   | }

  ../packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  types/__fixtures__/flow/types.test.js/incorrect case.js
   |   const a = createStore('');
   |   const clock = createEvent();
>  |   const sample_s_edge_incorrect: Event<number> = sample(a, clock);
   |                                                  ^^^^^^^^^^^^^^^ 
   |  Cannot assign \`sample(...)\` to \`sample_s_edge_incorrect\` 
   |  because string [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   | }

   | import { createFormApi } from '@effector/forms';
   | {
>  |   const a = createStore('');
   |                         ^^ [1]
   |   const clock = createEvent();
   |   const sample_s_edge_incorrect: Event<number> = sample(a, clock);

   |   const a = createStore('');
   |   const clock = createEvent();
>  |   const sample_s_edge_incorrect: Event<number> = sample(a, clock);
   |                                        ^^^^^^ [2]
   | }

  ../packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  types/__fixtures__/flow/types.test.js/launch.js
   |     })]
   |   });
>  |   launch(foo, '');
   |               ^ 
   |  Cannot call \`launch\` with empty string bound to \`payload\` 
   |  because string [1] is incompatible with number [2].
   |  
   |   launch(foo, 0);
   |   launch(customNode, 100);

   |     })]
   |   });
>  |   launch(foo, '');
   |               ^^ [1]
   |   launch(foo, 0);
   |   launch(customNode, 100);

   | import { createFormApi } from '@effector/forms';
   | {
>  |   const foo = createEvent<number>();
   |                           ^^^^^^ [2]
   |   const customNode = createNode({
   |     scope: {

  

  types/__fixtures__/flow/types.test.js/no false-positive (should be type error).js
   | {
   |   const nestedEffect: Effect<string, string> = createEffect();
>  |   const parentEffect: Effect<number, number> = createEffect('should not throw', {
   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>  |     handler: nestedEffect
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
>  |   });
   | ^^^^ 
   |  Cannot assign \`createEffect(...)\` to \`parentEffect\` 
   |  because number [1] is incompatible with string [2] in type
   |  argument \`Params\` [3].
   |  
   | }

   | {
   |   const nestedEffect: Effect<string, string> = createEffect();
>  |   const parentEffect: Effect<number, number> = createEffect('should not throw', {
   |                              ^^^^^^ [1]
   |     handler: nestedEffect
   |   });

   | import { createFormApi } from '@effector/forms';
   | {
>  |   const nestedEffect: Effect<string, string> = createEffect();
   |                              ^^^^^^ [2]
   |   const parentEffect: Effect<number, number> = createEffect('should not throw', {
   |     handler: nestedEffect

  ../packages/effector/index.js.flow
   | }
   | 
>  | declare export class Effect<Params, Done, Fail = Error>
   |                             ^^^^^^ [3]
   |   implements Unit<Params> {
   |   (payload: Params): Promise<Done>;

  

  types/__fixtures__/flow/types.test.js/no false-positive (should be type error).js
   | {
   |   const nestedEffect: Effect<string, string> = createEffect();
>  |   const parentEffect: Effect<number, number> = createEffect('should not throw', {
   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>  |     handler: nestedEffect
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
>  |   });
   | ^^^^ 
   |  Cannot assign \`createEffect(...)\` to \`parentEffect\` 
   |  because string [1] is incompatible with number [2] in type argument \`Done\` [3].
   |  
   | }

   | import { createFormApi } from '@effector/forms';
   | {
>  |   const nestedEffect: Effect<string, string> = createEffect();
   |                                      ^^^^^^ [1]
   |   const parentEffect: Effect<number, number> = createEffect('should not throw', {
   |     handler: nestedEffect

   | {
   |   const nestedEffect: Effect<string, string> = createEffect();
>  |   const parentEffect: Effect<number, number> = createEffect('should not throw', {
   |                                      ^^^^^^ [2]
   |     handler: nestedEffect
   |   });

  ../packages/effector/index.js.flow
   | }
   | 
>  | declare export class Effect<Params, Done, Fail = Error>
   |                                     ^^^^ [3]
   |   implements Unit<Params> {
   |   (payload: Params): Promise<Done>;

  

  types/__fixtures__/flow/types.test.js/split arguments no false-positive.js
   |   const source: Event<string[]> = createEvent();
   |   split(source, {
>  |     wrongResult: list => null,
   |                          ^^^ 
   |  Cannot call \`split\` with object literal bound to \`cases\` 
   |  because null [1] is incompatible with boolean [2] in the return value of
   |  property \`wrongResult\`.
   |  
   |     wrongArg_1: (list: null) => true,
   |     wrongArg_2: (list: number[]) => true

   |   const source: Event<string[]> = createEvent();
   |   split(source, {
>  |     wrongResult: list => null,
   |                          ^^^^ [1]
   |     wrongArg_1: (list: null) => true,
   |     wrongArg_2: (list: number[]) => true

  ../packages/effector/index.js.flow
   |   S,
   |   Obj: {
>  |     +[name: string]: (payload: S) => boolean,
   |                                      ^^^^^^^ [2]
   |     ...,
   |   },

  

  types/__fixtures__/flow/types.test.js/split arguments no false-positive.js
   |   split(source, {
   |     wrongResult: list => null,
>  |     wrongArg_1: (list: null) => true,
   |                        ^^^ 
   |  Cannot call \`split\` with object literal bound to \`cases\` 
   |  because null [1] is incompatible with array type [2] in the first argument of
   |  property \`wrongArg_1\`.
   |  
   |     wrongArg_2: (list: number[]) => true
   |   });

   |   split(source, {
   |     wrongResult: list => null,
>  |     wrongArg_1: (list: null) => true,
   |                        ^^^^ [1]
   |     wrongArg_2: (list: number[]) => true
   |   });

   | import { createFormApi } from '@effector/forms';
   | {
>  |   const source: Event<string[]> = createEvent();
   |                       ^^^^^^^^ [2]
   |   split(source, {
   |     wrongResult: list => null,

  

  types/__fixtures__/flow/types.test.js/split arguments no false-positive.js
   |     wrongResult: list => null,
   |     wrongArg_1: (list: null) => true,
>  |     wrongArg_2: (list: number[]) => true
   |                        ^^^^^ 
   |  Cannot call \`split\` with object literal bound to \`cases\` 
   |  because number [1] is incompatible with string [2] in array element of the
   |  first argument of property \`wrongArg_2\`.
   |  
   |   });
   | }

   |     wrongResult: list => null,
   |     wrongArg_1: (list: null) => true,
>  |     wrongArg_2: (list: number[]) => true
   |                        ^^^^^^ [1]
   |   });
   | }

   | import { createFormApi } from '@effector/forms';
   | {
>  |   const source: Event<string[]> = createEvent();
   |                       ^^^^^^ [2]
   |   split(source, {
   |     wrongResult: list => null,

  

  types/__fixtures__/flow/types.test.js/split result no false-positive.js
   |       oneElement: list => list.length === 1
   |     });
>  |     const split_result__nofpos__user_defined_1: Event<number> = emptyList;
   |                                                                 ^^^^^^^^ 
   |  Cannot assign \`emptyList\` to \`split_result__nofpos__user_defined_1\` 
   |  because array type [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   |     const split_result__nofpos__user_defined_2: null = oneElement;
   |   }

   | {
   |   {
>  |     const source: Event<string[]> = createEvent();
   |                         ^^^^^^^^ [1]
   |     const {
   |       emptyList,

   |       oneElement: list => list.length === 1
   |     });
>  |     const split_result__nofpos__user_defined_1: Event<number> = emptyList;
   |                                                       ^^^^^^ [2]
   |     const split_result__nofpos__user_defined_2: null = oneElement;
   |   }

  ../packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  types/__fixtures__/flow/types.test.js/split result no false-positive.js
   |     });
   |     const split_result__nofpos__user_defined_1: Event<number> = emptyList;
>  |     const split_result__nofpos__user_defined_2: null = oneElement;
   |                                                        ^^^^^^^^^ 
   |  Cannot assign \`oneElement\` to \`split_result__nofpos__user_defined_2\` 
   |  because \`Event\` [1] is incompatible with null [2].
   |  
   |   }
   |   {

  ../packages/effector/index.js.flow
   | ): $ObjMap<
   |   {...Obj, __: (payload: S) => boolean, ...},
>  |   (h: (payload: S) => boolean) => Event<S>,
   |                                   ^^^^^^^^ [1]
   | >
   | declare export function restoreObject<

  types/__fixtures__/flow/types.test.js/split result no false-positive.js
   |     });
   |     const split_result__nofpos__user_defined_1: Event<number> = emptyList;
>  |     const split_result__nofpos__user_defined_2: null = oneElement;
   |                                                 ^^^^ [2]
   |   }
   |   {

  

  types/__fixtures__/flow/types.test.js/split result no false-positive.js
   |       oneElement: list => list.length === 1
   |     });
>  |     const split_result__nofpos__defaults_1: Event<number> = __;
   |                                                             ^ 
   |  Cannot assign \`__\` to \`split_result__nofpos__defaults_1\` 
   |  because array type [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   |   }
   |   {

   |   }
   |   {
>  |     const source: Event<string[]> = createEvent();
   |                         ^^^^^^^^ [1]
   |     const {
   |       __

   |       oneElement: list => list.length === 1
   |     });
>  |     const split_result__nofpos__defaults_1: Event<number> = __;
   |                                                   ^^^^^^ [2]
   |   }
   |   {

  ../packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  types/__fixtures__/flow/types.test.js/split result no false-positive.js
   |       oneElement: list => list.length === 1
   |     });
>  |     const split_result__nofpos__defaults_2: null = __;
   |                                                    ^ 
   |  Cannot assign \`__\` to \`split_result__nofpos__defaults_2\` 
   |  because \`Event\` [1] is incompatible with null [2].
   |  
   |   }
   | }

  ../packages/effector/index.js.flow
   | ): $ObjMap<
   |   {...Obj, __: (payload: S) => boolean, ...},
>  |   (h: (payload: S) => boolean) => Event<S>,
   |                                   ^^^^^^^^ [1]
   | >
   | declare export function restoreObject<

  types/__fixtures__/flow/types.test.js/split result no false-positive.js
   |       oneElement: list => list.length === 1
   |     });
>  |     const split_result__nofpos__defaults_2: null = __;
   |                                             ^^^^ [2]
   |   }
   | }

  

  types/__fixtures__/flow/types.test.js/store by event with handler.js
   |     b: boolean,
   |   }> = e;
>  |   const sample_seh_check2: Event<string> = e;
   |                                            ^ 
   |  Cannot assign \`e\` to \`sample_seh_check2\` 
   |  because object type [1] is incompatible with string [2] in type argument
   |  \`Payload\` [3].
   |  
   | }

   |     b
   |   }));
>  |   const sample_seh_check1: Event<{
   |                                  ^^ [1]
   |     a: string,
   | ^^^^^^^^^^^^^^
   |     b: boolean,
   | ^^^^^^^^^^^^^^
   |   }> = e;
   | ^^^
   |   const sample_seh_check2: Event<string> = e;
   | }

   |     b: boolean,
   |   }> = e;
>  |   const sample_seh_check2: Event<string> = e;
   |                                  ^^^^^^ [2]
   | }

  ../packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  types/__fixtures__/flow/types.test.js/store by event.js
   |   const e = sample(d, b);
   |   const sample_se_check1: Event<number> = e;
>  |   const sample_se_check2: Event<string> = e;
   |                                           ^ 
   |  Cannot assign \`e\` to \`sample_se_check2\` 
   |  because number [1] is incompatible with string [2] in type argument
   |  \`Payload\` [3].
   |  
   | }

   |   const b = createEvent<boolean>();
   |   const e = sample(d, b);
>  |   const sample_se_check1: Event<number> = e;
   |                                 ^^^^^^ [1]
   |   const sample_se_check2: Event<string> = e;
   | }

   |   const e = sample(d, b);
   |   const sample_se_check1: Event<number> = e;
>  |   const sample_se_check2: Event<string> = e;
   |                                 ^^^^^^ [2]
   | }

  ../packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  types/__fixtures__/flow/types.test.js/store by store with handler.js
   |     b: boolean,
   |   }> = c;
>  |   const sample_ssh_check2: Store<string> = c;
   |                                            ^ 
   |  Cannot assign \`c\` to \`sample_ssh_check2\` 
   |  because object type [1] is incompatible with string [2] in type
   |  argument \`State\` [3].
   |  
   | }

   |     b
   |   }));
>  |   const sample_ssh_check1: Store<{
   |                                  ^^ [1]
   |     a: string,
   | ^^^^^^^^^^^^^^
   |     b: boolean,
   | ^^^^^^^^^^^^^^
   |   }> = c;
   | ^^^
   |   const sample_ssh_check2: Store<string> = c;
   | }

   |     b: boolean,
   |   }> = c;
>  |   const sample_ssh_check2: Store<string> = c;
   |                                  ^^^^^^ [2]
   | }

  ../packages/effector/index.js.flow
   | }
   | 
>  | declare export class Store<State> implements Unit<State> {
   |                            ^^^^^ [3]
   |   +kind: kind;
   |   reset(...triggers: Array<Unit<any>>): this;

  

  types/__fixtures__/flow/types.test.js/store by store.js
   |   const c = sample(a, b);
   |   const sample_ss_check1: Store<boolean> = c;
>  |   const sample_ss_check2: Store<string> = c;
   |                                           ^ 
   |  Cannot assign \`c\` to \`sample_ss_check2\` 
   |  because boolean [1] is incompatible with string [2] in type
   |  argument \`State\` [3].
   |  
   | }

   |   const b = createStore(0);
   |   const c = sample(a, b);
>  |   const sample_ss_check1: Store<boolean> = c;
   |                                 ^^^^^^^ [1]
   |   const sample_ss_check2: Store<string> = c;
   | }

   |   const c = sample(a, b);
   |   const sample_ss_check1: Store<boolean> = c;
>  |   const sample_ss_check2: Store<string> = c;
   |                                 ^^^^^^ [2]
   | }

  ../packages/effector/index.js.flow
   | }
   | 
>  | declare export class Store<State> implements Unit<State> {
   |                            ^^^^^ [3]
   |   +kind: kind;
   |   reset(...triggers: Array<Unit<any>>): this;

  "
`;
