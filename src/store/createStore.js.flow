//@flow

import type {ComponentType, Node} from 'react'
import type {Event} from '../effector'

export type Store<T> = {
 /*::+['@@iterable']: () => Iterable<T>,*/
 subscribe(
  listner: () => void,
 ): {
  (): void,
  unsubscribe(): void,
 },
 //  replaceReducer(
 //   transform: (input: (_: T, p: any) => T) => (_: T, p: any) => T,
 //  ): void,
 replaceReducer(nextReducer: (_: T, p: any) => T): void,
 getState(): T,
 withProps<Props>(fn: (state: T, props: Props) => Node): ComponentType<Props>,
 reset(event: Event<*>): Store<T>,
 dispatch: (action: any) => any,
 on<E>(event: Event<E>, handler: (state: T, payload: E) => T): Store<T>,
 watch<E>(watcher: (state: T, payload: E, type: string) => any): void,
 map<S>(fn: (_: T) => S): Store<S>,
 thru<U>(fn: (store: Store<T>) => U): U,
}

declare export function createStore<T>(preloadedState: T): Store<T>

type MapStoreFields = (<O: {[string]: any}>(
 _: O,
) => $ObjMap<O, <S>(field: Store<S> | S) => S>) &
 (<O>(_: O) => O)

declare export function createStoreObject<T>(
 preloadedState: T,
): Store<$Call<MapStoreFields, T>>

declare export function createReduxStore<T>(
 reducer: (state: T, event: any) => T,
 preloadedState?: T,
 enhancer?: Function | Function[],
): Store<T>

// declare export function createStore<T>(
//  reducer: (store: T, payload: any) => T,
//  enhancerRaw: Function | $ReadOnlyArray<Function>,
//  none: void,
// ): Store<T>
// declare export function createStore<T>(
//  reducer: (store: T, payload: any) => T,
//  preloadedStateRaw?: T,
//  enhancerRaw: Function | $ReadOnlyArray<Function>,
// ): Store<T>
