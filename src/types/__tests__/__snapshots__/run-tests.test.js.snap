// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Flow: json messages 1`] = `
"  src/types/types.test.js
   56 |             oneElement: list => list.length === 1,
   57 |           })
>  58 |           const split_result__nofpos__user_defined_1: Event<number> = emptyList
      |                                                                       ^^^^^^^^ 
      |  Cannot assign \`emptyList\` to \`split_result__nofpos__user_defined_1\` 
      |  because array type [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
   59 |           const split_result__nofpos__user_defined_2: null = oneElement
   60 |         }

   51 |       test('split result no false-positive', () => {
   52 |         {
>  53 |           const source: Event<string[]> = createEvent()
      |                               ^^^^^^^^ [1]
   54 |           const {emptyList, oneElement} = split(source, {
   55 |             emptyList: list => list.length === 0,

   56 |             oneElement: list => list.length === 1,
   57 |           })
>  58 |           const split_result__nofpos__user_defined_1: Event<number> = emptyList
      |                                                             ^^^^^^ [2]
   59 |           const split_result__nofpos__user_defined_2: null = oneElement
   60 |         }

  packages/effector/index.js.flow
   35 |   +kind: kind;
   36 | }
>  37 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   38 |   (payload: Payload): Payload;
   39 |   +kind: kind;

  

  src/types/types.test.js
   57 |           })
   58 |           const split_result__nofpos__user_defined_1: Event<number> = emptyList
>  59 |           const split_result__nofpos__user_defined_2: null = oneElement
      |                                                              ^^^^^^^^^ 
      |  Cannot assign \`oneElement\` to \`split_result__nofpos__user_defined_2\` 
      |  because \`Event\` [1] is incompatible with null [2].
      |  
   60 |         }
   61 |         {

  packages/effector/index.js.flow
  306 | ): $ObjMap<
  307 |   {...Obj, __: (payload: S) => boolean},
> 308 |   (h: (payload: S) => boolean) => Event<S>,
      |                                   ^^^^^^^^ [1]
  309 | >
  310 | declare export function restoreObject<

  src/types/types.test.js
   57 |           })
   58 |           const split_result__nofpos__user_defined_1: Event<number> = emptyList
>  59 |           const split_result__nofpos__user_defined_2: null = oneElement
      |                                                       ^^^^ [2]
   60 |         }
   61 |         {

  

  src/types/types.test.js
   65 |             oneElement: list => list.length === 1,
   66 |           })
>  67 |           const split_result__nofpos__defaults_1: Event<number> = __
      |                                                                   ^ 
      |  Cannot assign \`__\` to \`split_result__nofpos__defaults_1\` 
      |  because array type [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
   68 |         }
   69 |         {

   60 |         }
   61 |         {
>  62 |           const source: Event<string[]> = createEvent()
      |                               ^^^^^^^^ [1]
   63 |           const {__} = split(source, {
   64 |             emptyList: list => list.length === 0,

   65 |             oneElement: list => list.length === 1,
   66 |           })
>  67 |           const split_result__nofpos__defaults_1: Event<number> = __
      |                                                         ^^^^^^ [2]
   68 |         }
   69 |         {

  packages/effector/index.js.flow
   35 |   +kind: kind;
   36 | }
>  37 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   38 |   (payload: Payload): Payload;
   39 |   +kind: kind;

  

  src/types/types.test.js
   73 |             oneElement: list => list.length === 1,
   74 |           })
>  75 |           const split_result__nofpos__defaults_2: null = __
      |                                                          ^ 
      |  Cannot assign \`__\` to \`split_result__nofpos__defaults_2\` 
      |  because \`Event\` [1] is incompatible with null [2].
      |  
   76 |         }
   77 |       })

  packages/effector/index.js.flow
  306 | ): $ObjMap<
  307 |   {...Obj, __: (payload: S) => boolean},
> 308 |   (h: (payload: S) => boolean) => Event<S>,
      |                                   ^^^^^^^^ [1]
  309 | >
  310 | declare export function restoreObject<

  src/types/types.test.js
   73 |             oneElement: list => list.length === 1,
   74 |           })
>  75 |           const split_result__nofpos__defaults_2: null = __
      |                                                   ^^^^ [2]
   76 |         }
   77 |       })

  

  src/types/types.test.js
   81 |       const source: Event<string[]> = createEvent()
   82 |       split(source, {
>  83 |         wrongResult: list => null,
      |                              ^^^ 
      |  Cannot call \`split\` with object literal bound to \`cases\` 
      |  because null [1] is incompatible with boolean [2] in the return value of
      |  property \`wrongResult\`.
      |  
   84 |         wrongArg_1: (list: null) => true,
   85 |         wrongArg_2: (list: number[]) => true,

   81 |       const source: Event<string[]> = createEvent()
   82 |       split(source, {
>  83 |         wrongResult: list => null,
      |                              ^^^^ [1]
   84 |         wrongArg_1: (list: null) => true,
   85 |         wrongArg_2: (list: number[]) => true,

  packages/effector/index.js.flow
  298 |   S,
  299 |   Obj: {
> 300 |     +[name: string]: (payload: S) => boolean,
      |                                      ^^^^^^^ [2]
  301 |     ...,
  302 |   },

  

  src/types/types.test.js
   82 |       split(source, {
   83 |         wrongResult: list => null,
>  84 |         wrongArg_1: (list: null) => true,
      |                            ^^^ 
      |  Cannot call \`split\` with object literal bound to \`cases\` 
      |  because null [1] is incompatible with array type [2] in the first argument of
      |  property \`wrongArg_1\`.
      |  
   85 |         wrongArg_2: (list: number[]) => true,
   86 |       })

   82 |       split(source, {
   83 |         wrongResult: list => null,
>  84 |         wrongArg_1: (list: null) => true,
      |                            ^^^^ [1]
   85 |         wrongArg_2: (list: number[]) => true,
   86 |       })

   79 | 
   80 |     test('split arguments no false-positive', () => {
>  81 |       const source: Event<string[]> = createEvent()
      |                           ^^^^^^^^ [2]
   82 |       split(source, {
   83 |         wrongResult: list => null,

  

  src/types/types.test.js
   83 |         wrongResult: list => null,
   84 |         wrongArg_1: (list: null) => true,
>  85 |         wrongArg_2: (list: number[]) => true,
      |                            ^^^^^ 
      |  Cannot call \`split\` with object literal bound to \`cases\` 
      |  because number [1] is incompatible with string [2] in array element of the
      |  first argument of property \`wrongArg_2\`.
      |  
   86 |       })
   87 |     })

   83 |         wrongResult: list => null,
   84 |         wrongArg_1: (list: null) => true,
>  85 |         wrongArg_2: (list: number[]) => true,
      |                            ^^^^^^ [1]
   86 |       })
   87 |     })

   79 | 
   80 |     test('split arguments no false-positive', () => {
>  81 |       const source: Event<string[]> = createEvent()
      |                           ^^^^^^ [2]
   82 |       split(source, {
   83 |         wrongResult: list => null,

  

  src/types/types.test.js
   94 | 
   95 |       const sample_ee_check1: Event<number> = c
>  96 |       const sample_ee_check2: Event<string> = c
      |                                               ^ 
      |  Cannot assign \`c\` to \`sample_ee_check2\` 
      |  because number [1] is incompatible with string [2] in type argument
      |  \`Payload\` [3].
      |  
   97 |     })
   98 |     test('event by event with handler', () => {

   89 |   describe('sample', () => {
   90 |     test('event by event', () => {
>  91 |       const a = createEvent<number>()
      |                             ^^^^^^ [1]
   92 |       const b = createEvent<boolean>()
   93 |       const c = sample(a, b)

   94 | 
   95 |       const sample_ee_check1: Event<number> = c
>  96 |       const sample_ee_check2: Event<string> = c
      |                                     ^^^^^^ [2]
   97 |     })
   98 |     test('event by event with handler', () => {

  packages/effector/index.js.flow
   35 |   +kind: kind;
   36 | }
>  37 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   38 |   (payload: Payload): Payload;
   39 |   +kind: kind;

  

  src/types/types.test.js
  102 | 
  103 |       const sample_eeh_check1: Event<{a: string, b: boolean}> = c
> 104 |       const sample_eeh_check2: Event<string> = c
      |                                                ^ 
      |  Cannot assign \`c\` to \`sample_eeh_check2\` 
      |  because object type [1] is incompatible with string [2] in type argument
      |  \`Payload\` [3].
      |  
  105 |     })
  106 | 

  101 |       const c = sample(a, b, (a, b) => ({a, b}))
  102 | 
> 103 |       const sample_eeh_check1: Event<{a: string, b: boolean}> = c
      |                                      ^^^^^^^^^^^^^^^^^^^^^^^ [1]
  104 |       const sample_eeh_check2: Event<string> = c
  105 |     })

  102 | 
  103 |       const sample_eeh_check1: Event<{a: string, b: boolean}> = c
> 104 |       const sample_eeh_check2: Event<string> = c
      |                                      ^^^^^^ [2]
  105 |     })
  106 | 

  packages/effector/index.js.flow
   35 |   +kind: kind;
   36 | }
>  37 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   38 |   (payload: Payload): Payload;
   39 |   +kind: kind;

  

  src/types/types.test.js
  111 | 
  112 |       const sample_se_check1: Event<number> = e
> 113 |       const sample_se_check2: Event<string> = e
      |                                               ^ 
      |  Cannot assign \`e\` to \`sample_se_check2\` 
      |  because number [1] is incompatible with string [2] in type argument
      |  \`Payload\` [3].
      |  
  114 |     })
  115 |     test('store by event with handler', () => {

  110 |       const e = sample(d, b)
  111 | 
> 112 |       const sample_se_check1: Event<number> = e
      |                                     ^^^^^^ [1]
  113 |       const sample_se_check2: Event<string> = e
  114 |     })

  111 | 
  112 |       const sample_se_check1: Event<number> = e
> 113 |       const sample_se_check2: Event<string> = e
      |                                     ^^^^^^ [2]
  114 |     })
  115 |     test('store by event with handler', () => {

  packages/effector/index.js.flow
   35 |   +kind: kind;
   36 | }
>  37 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   38 |   (payload: Payload): Payload;
   39 |   +kind: kind;

  

  src/types/types.test.js
  119 | 
  120 |       const sample_seh_check1: Event<{a: string, b: boolean}> = e
> 121 |       const sample_seh_check2: Event<string> = e
      |                                                ^ 
      |  Cannot assign \`e\` to \`sample_seh_check2\` 
      |  because object type [1] is incompatible with string [2] in type argument
      |  \`Payload\` [3].
      |  
  122 |     })
  123 | 

  118 |       const e = sample(d, b, (a, b) => ({a, b}))
  119 | 
> 120 |       const sample_seh_check1: Event<{a: string, b: boolean}> = e
      |                                      ^^^^^^^^^^^^^^^^^^^^^^^ [1]
  121 |       const sample_seh_check2: Event<string> = e
  122 |     })

  119 | 
  120 |       const sample_seh_check1: Event<{a: string, b: boolean}> = e
> 121 |       const sample_seh_check2: Event<string> = e
      |                                      ^^^^^^ [2]
  122 |     })
  123 | 

  packages/effector/index.js.flow
   35 |   +kind: kind;
   36 | }
>  37 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   38 |   (payload: Payload): Payload;
   39 |   +kind: kind;

  

  src/types/types.test.js
  128 | 
  129 |       const sample_efe_check1: Event<string> = g
> 130 |       const sample_efe_check2: Event<number> = g
      |                                                ^ 
      |  Cannot assign \`g\` to \`sample_efe_check2\` 
      |  because string [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
  131 |     })
  132 |     test('effect by event with handler', () => {

  123 | 
  124 |     test('effect by event', () => {
> 125 |       const f = createEffect<string, any, any>()
      |                              ^^^^^^ [1]
  126 |       const b = createEvent<boolean>()
  127 |       const g = sample(f, b)

  128 | 
  129 |       const sample_efe_check1: Event<string> = g
> 130 |       const sample_efe_check2: Event<number> = g
      |                                      ^^^^^^ [2]
  131 |     })
  132 |     test('effect by event with handler', () => {

  packages/effector/index.js.flow
   35 |   +kind: kind;
   36 | }
>  37 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   38 |   (payload: Payload): Payload;
   39 |   +kind: kind;

  

  src/types/types.test.js
  136 | 
  137 |       const sample_efeh_check1: Event<{a: string, b: boolean}> = g
> 138 |       const sample_efeh_check2: Event<number> = g
      |                                                 ^ 
      |  Cannot assign \`g\` to \`sample_efeh_check2\` 
      |  because object type [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
  139 |     })
  140 | 

  135 |       const g = sample(f, b, (a, b) => ({a, b}))
  136 | 
> 137 |       const sample_efeh_check1: Event<{a: string, b: boolean}> = g
      |                                       ^^^^^^^^^^^^^^^^^^^^^^^ [1]
  138 |       const sample_efeh_check2: Event<number> = g
  139 |     })

  136 | 
  137 |       const sample_efeh_check1: Event<{a: string, b: boolean}> = g
> 138 |       const sample_efeh_check2: Event<number> = g
      |                                       ^^^^^^ [2]
  139 |     })
  140 | 

  packages/effector/index.js.flow
   35 |   +kind: kind;
   36 | }
>  37 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   38 |   (payload: Payload): Payload;
   39 |   +kind: kind;

  

  src/types/types.test.js
  145 | 
  146 |       const sample_ss_check1: Store<boolean> = c
> 147 |       const sample_ss_check2: Store<string> = c
      |                                               ^ 
      |  Cannot assign \`c\` to \`sample_ss_check2\` 
      |  because boolean [1] is incompatible with string [2] in type
      |  argument \`State\` [3].
      |  
  148 |     })
  149 |     test('store by store with handler', () => {

  144 |       const c = sample(a, b)
  145 | 
> 146 |       const sample_ss_check1: Store<boolean> = c
      |                                     ^^^^^^^ [1]
  147 |       const sample_ss_check2: Store<string> = c
  148 |     })

  145 | 
  146 |       const sample_ss_check1: Store<boolean> = c
> 147 |       const sample_ss_check2: Store<string> = c
      |                                     ^^^^^^ [2]
  148 |     })
  149 |     test('store by store with handler', () => {

  packages/effector/index.js.flow
   90 | }
   91 | 
>  92 | declare export class Store<State> implements Unit<State> {
      |                            ^^^^^ [3]
   93 |   +kind: kind;
   94 |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
  153 | 
  154 |       const sample_ssh_check1: Store<{a: string, b: boolean}> = c
> 155 |       const sample_ssh_check2: Store<string> = c
      |                                                ^ 
      |  Cannot assign \`c\` to \`sample_ssh_check2\` 
      |  because object type [1] is incompatible with string [2] in type
      |  argument \`State\` [3].
      |  
  156 |     })
  157 |     describe('sample(Store<T>):Store<T>', () => {

  152 |       const c = sample(a, b, (a, b) => ({a, b}))
  153 | 
> 154 |       const sample_ssh_check1: Store<{a: string, b: boolean}> = c
      |                                      ^^^^^^^^^^^^^^^^^^^^^^^ [1]
  155 |       const sample_ssh_check2: Store<string> = c
  156 |     })

  153 | 
  154 |       const sample_ssh_check1: Store<{a: string, b: boolean}> = c
> 155 |       const sample_ssh_check2: Store<string> = c
      |                                      ^^^^^^ [2]
  156 |     })
  157 |     describe('sample(Store<T>):Store<T>', () => {

  packages/effector/index.js.flow
   90 | }
   91 | 
>  92 | declare export class Store<State> implements Unit<State> {
      |                            ^^^^^ [3]
   93 |   +kind: kind;
   94 |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
  162 |       test('incorrect case', () => {
  163 |         const a = createStore('')
> 164 |         const sample_s_incorrect: Store<number> = sample(a)
      |                                                   ^^^^^^^^ 
      |  Cannot assign \`sample(...)\` to \`sample_s_incorrect\` 
      |  because string [1] is incompatible with number [2] in type argument \`State\` [3].
      |  
  165 |       })
  166 |       describe('edge case', () => {

  161 |       })
  162 |       test('incorrect case', () => {
> 163 |         const a = createStore('')
      |                               ^^ [1]
  164 |         const sample_s_incorrect: Store<number> = sample(a)
  165 |       })

  162 |       test('incorrect case', () => {
  163 |         const a = createStore('')
> 164 |         const sample_s_incorrect: Store<number> = sample(a)
      |                                         ^^^^^^ [2]
  165 |       })
  166 |       describe('edge case', () => {

  packages/effector/index.js.flow
   90 | }
   91 | 
>  92 | declare export class Store<State> implements Unit<State> {
      |                            ^^^^^ [3]
   93 |   +kind: kind;
   94 |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
  173 |           const a = createStore('')
  174 |           const clock = createEvent()
> 175 |           const sample_s_edge_incorrect: Event<number> = sample(a, clock)
      |                                                          ^^^^^^^^^^^^^^^ 
      |  Cannot assign \`sample(...)\` to \`sample_s_edge_incorrect\` 
      |  because string [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
  176 |         })
  177 |       })

  171 |         })
  172 |         test('incorrect case', () => {
> 173 |           const a = createStore('')
      |                                 ^^ [1]
  174 |           const clock = createEvent()
  175 |           const sample_s_edge_incorrect: Event<number> = sample(a, clock)

  173 |           const a = createStore('')
  174 |           const clock = createEvent()
> 175 |           const sample_s_edge_incorrect: Event<number> = sample(a, clock)
      |                                                ^^^^^^ [2]
  176 |         })
  177 |       })

  packages/effector/index.js.flow
   35 |   +kind: kind;
   36 | }
>  37 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   38 |   (payload: Payload): Payload;
   39 |   +kind: kind;

  

  src/types/types.test.js
  193 | 
  194 |     //const check1: Event<string> = computed
> 195 |     const event_map_check2: Event<number> = computed
      |                                             ^^^^^^^ 
      |  Cannot assign \`computed\` to \`event_map_check2\` 
      |  because string [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
  196 |     event(2)
  197 |     computed('')

  190 |   test('#map', () => {
  191 |     const event: Event<number> = createEvent()
> 192 |     const computed = event.map(() => 'foo')
      |                                      ^^^^^ [1]
  193 | 
  194 |     //const check1: Event<string> = computed

  193 | 
  194 |     //const check1: Event<string> = computed
> 195 |     const event_map_check2: Event<number> = computed
      |                                   ^^^^^^ [2]
  196 |     event(2)
  197 |     computed('')

  packages/effector/index.js.flow
   35 |   +kind: kind;
   36 | }
>  37 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   38 |   (payload: Payload): Payload;
   39 |   +kind: kind;

  

  src/types/types.test.js
  193 | 
  194 |     //const check1: Event<string> = computed
> 195 |     const event_map_check2: Event<number> = computed
      |                                             ^^^^^^^ 
      |  Cannot assign \`computed\` to \`event_map_check2\` 
      |  because string [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
  196 |     event(2)
  197 |     computed('')

  195 |     const event_map_check2: Event<number> = computed
  196 |     event(2)
> 197 |     computed('')
      |              ^^ [1]
  198 |   })
  199 |   test('#watch', () => {

  193 | 
  194 |     //const check1: Event<string> = computed
> 195 |     const event_map_check2: Event<number> = computed
      |                                   ^^^^^^ [2]
  196 |     event(2)
  197 |     computed('')

  packages/effector/index.js.flow
   35 |   +kind: kind;
   36 | }
>  37 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   38 |   (payload: Payload): Payload;
   39 |   +kind: kind;

  

  src/types/types.test.js
  219 |       const event: Event<number> = createEvent()
  220 |       const filteredEvent_error: Event<number> = event.filter(n => {
> 221 |         if (n % 2) return n.toString()
      |                           ^^^^^^^^^^^ 
      |  Cannot assign \`event.filter(...)\` to \`filteredEvent_error\` 
      |  because string [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
  222 |       })
  223 |     })

   [LIB] core.js
> 158 |     toString(radix?: number): string;
      |                               ^^^^^^ [1]

  src/types/types.test.js
  218 |     test('#filter incorrect', () => {
  219 |       const event: Event<number> = createEvent()
> 220 |       const filteredEvent_error: Event<number> = event.filter(n => {
      |                                        ^^^^^^ [2]
  221 |         if (n % 2) return n.toString()
  222 |       })

  packages/effector/index.js.flow
   35 |   +kind: kind;
   36 | }
>  37 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   38 |   (payload: Payload): Payload;
   39 |   +kind: kind;

  

  src/types/types.test.js
  267 |       test('no false-positive (should be type error)', () => {
  268 |         const nestedEffect: Effect<string, string> = createEffect()
> 269 |         const parentEffect: Effect<number, number> = createEffect(
      |                                                      ^^^^^^^^^^^^
> 270 |           'should not throw',
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 271 |           {
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 272 |             handler: nestedEffect,
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 273 |           },
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 274 |         )
      | ^^^^^^^^^ 
      |  Cannot assign \`createEffect(...)\` to \`parentEffect\` 
      |  because number [1] is incompatible with string [2] in type
      |  argument \`Params\` [3].
      |  
  275 |       })
  276 |     })

  267 |       test('no false-positive (should be type error)', () => {
  268 |         const nestedEffect: Effect<string, string> = createEffect()
> 269 |         const parentEffect: Effect<number, number> = createEffect(
      |                                    ^^^^^^ [1]
  270 |           'should not throw',
  271 |           {

  266 |     describe('with handler', () => {
  267 |       test('no false-positive (should be type error)', () => {
> 268 |         const nestedEffect: Effect<string, string> = createEffect()
      |                                    ^^^^^^ [2]
  269 |         const parentEffect: Effect<number, number> = createEffect(
  270 |           'should not throw',

  packages/effector/index.js.flow
   54 | }
   55 | 
>  56 | declare export class Effect<Params, Done, Fail = Error>
      |                             ^^^^^^ [3]
   57 |   implements Unit<Params> {
   58 |   (payload: Params): Promise<Done>;

  

  src/types/types.test.js
  267 |       test('no false-positive (should be type error)', () => {
  268 |         const nestedEffect: Effect<string, string> = createEffect()
> 269 |         const parentEffect: Effect<number, number> = createEffect(
      |                                                      ^^^^^^^^^^^^
> 270 |           'should not throw',
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 271 |           {
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 272 |             handler: nestedEffect,
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 273 |           },
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 274 |         )
      | ^^^^^^^^^ 
      |  Cannot assign \`createEffect(...)\` to \`parentEffect\` 
      |  because string [1] is incompatible with number [2] in type argument \`Done\` [3].
      |  
  275 |       })
  276 |     })

  266 |     describe('with handler', () => {
  267 |       test('no false-positive (should be type error)', () => {
> 268 |         const nestedEffect: Effect<string, string> = createEffect()
      |                                            ^^^^^^ [1]
  269 |         const parentEffect: Effect<number, number> = createEffect(
  270 |           'should not throw',

  267 |       test('no false-positive (should be type error)', () => {
  268 |         const nestedEffect: Effect<string, string> = createEffect()
> 269 |         const parentEffect: Effect<number, number> = createEffect(
      |                                            ^^^^^^ [2]
  270 |           'should not throw',
  271 |           {

  packages/effector/index.js.flow
   54 | }
   55 | 
>  56 | declare export class Effect<Params, Done, Fail = Error>
      |                                     ^^^^ [3]
   57 |   implements Unit<Params> {
   58 |   (payload: Params): Promise<Done>;

  

  src/types/types.test.js
  282 |   test('createStore', () => {
  283 |     const createStore_store1: Store<number> = createStore(0)
> 284 |     const createStore_store2: Store<string> = createStore(0)
      |                                                           ^ 
      |  Cannot assign \`createStore(...)\` to \`createStore_store2\` 
      |  because number [1] is incompatible with string [2] in type argument \`State\` [3].
      |  
  285 |   })
  286 |   test('createStoreObject', () => {

  282 |   test('createStore', () => {
  283 |     const createStore_store1: Store<number> = createStore(0)
> 284 |     const createStore_store2: Store<string> = createStore(0)
      |                                                           ^^ [1]
  285 |   })
  286 |   test('createStoreObject', () => {

  282 |   test('createStore', () => {
  283 |     const createStore_store1: Store<number> = createStore(0)
> 284 |     const createStore_store2: Store<string> = createStore(0)
      |                                     ^^^^^^ [2]
  285 |   })
  286 |   test('createStoreObject', () => {

  packages/effector/index.js.flow
   90 | }
   91 | 
>  92 | declare export class Store<State> implements Unit<State> {
      |                            ^^^^^ [3]
   93 |   +kind: kind;
   94 |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
  305 |         event: (n, x: number) => x,
  306 |       })
> 307 |       const createApi_check2: Event<string> = event
      |                                               ^^^^ 
      |  Cannot assign \`event\` to \`createApi_check2\` 
      |  because string [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
  308 |     }
  309 |     {

  305 |         event: (n, x: number) => x,
  306 |       })
> 307 |       const createApi_check2: Event<string> = event
      |                                     ^^^^^^ [1]
  308 |     }
  309 |     {

  303 |     {
  304 |       const {event} = createApi(store, {
> 305 |         event: (n, x: number) => x,
      |                       ^^^^^^ [2]
  306 |       })
  307 |       const createApi_check2: Event<string> = event

  packages/effector/index.js.flow
   35 |   +kind: kind;
   36 | }
>  37 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   38 |   (payload: Payload): Payload;
   39 |   +kind: kind;

  

  src/types/types.test.js
  309 |     {
  310 |       const {event} = createApi(store, {
> 311 |         event: (n, x) => x,
      |                          ^ 
      |  Cannot call \`createApi\` with object literal bound to \`api\` 
      |  because string [1] is incompatible with number [2] in the return value of
      |  property \`event\`.
      |  
  312 |       })
  313 |       const createApi_check3: Event<string> = event

  311 |         event: (n, x) => x,
  312 |       })
> 313 |       const createApi_check3: Event<string> = event
      |                                     ^^^^^^ [1]
  314 |     }
  315 |   })

  294 |   })
  295 |   test('createApi', () => {
> 296 |     const store: Store<number> = createStore(0)
      |                        ^^^^^^ [2]
  297 |     {
  298 |       const {event} = createApi(store, {

  

  src/types/types.test.js
  367 |     const map_check1: Store<string> = computed
  368 | 
> 369 |     const map_check2: Store<number> = computed
      |                                       ^^^^^^^ 
      |  Cannot assign \`computed\` to \`map_check2\` 
      |  because string [1] is incompatible with number [2] in type argument \`State\` [3].
      |  
  370 |   })
  371 | 

  365 |     const computed = store.map(() => 'hello')
  366 | 
> 367 |     const map_check1: Store<string> = computed
      |                             ^^^^^^ [1]
  368 | 
  369 |     const map_check2: Store<number> = computed

  367 |     const map_check1: Store<string> = computed
  368 | 
> 369 |     const map_check2: Store<number> = computed
      |                             ^^^^^^ [2]
  370 |   })
  371 | 

  packages/effector/index.js.flow
   90 | }
   91 | 
>  92 | declare export class Store<State> implements Unit<State> {
      |                            ^^^^^ [3]
   93 |   +kind: kind;
   94 |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
  449 |     const domain = createDomain()
  450 |     const domain2 = createDomain('hello')
> 451 |     const domain3 = createDomain(234)
      |                                  ^^ 
      |  Cannot call \`createDomain\` with \`234\` bound to \`domainName\` 
      |  because number [1] is incompatible with string [2].
      |  
  452 |     const domain4 = createDomain({foo: true})
  453 |   })

  449 |     const domain = createDomain()
  450 |     const domain2 = createDomain('hello')
> 451 |     const domain3 = createDomain(234)
      |                                  ^^^ [1]
  452 |     const domain4 = createDomain({foo: true})
  453 |   })

  packages/effector/index.js.flow
  340 |   <S>(field: Store<S> | S) => Store<S>,
  341 | >
> 342 | declare export function createDomain(domainName?: string): Domain
      |                                                   ^^^^^^ [2]
  343 | 
  344 | declare export function sample<A>(config: {|

  

  src/types/types.test.js
  450 |     const domain2 = createDomain('hello')
  451 |     const domain3 = createDomain(234)
> 452 |     const domain4 = createDomain({foo: true})
      |                                  ^^^^^^^^^^ 
      |  Cannot call \`createDomain\` with object literal bound to \`domainName\` 
      |  because object literal [1] is incompatible with string [2].
      |  
  453 |   })
  454 | 

  450 |     const domain2 = createDomain('hello')
  451 |     const domain3 = createDomain(234)
> 452 |     const domain4 = createDomain({foo: true})
      |                                  ^^^^^^^^^^^ [1]
  453 |   })
  454 | 

  packages/effector/index.js.flow
  340 |   <S>(field: Store<S> | S) => Store<S>,
  341 | >
> 342 | declare export function createDomain(domainName?: string): Domain
      |                                                   ^^^^^^ [2]
  343 | 
  344 | declare export function sample<A>(config: {|

  

  src/types/types.test.js
  466 |       },
  467 |     })
> 468 |     effect2(20)
      |             ^ 
      |  Cannot call \`effect2\` with \`20\` bound to \`payload\` 
      |  because number [1] is incompatible with string [2].
      |  
  469 |     const effect3 = domain.effect('', {
  470 |       handler: effect1,

  466 |       },
  467 |     })
> 468 |     effect2(20)
      |             ^^ [1]
  469 |     const effect3 = domain.effect('', {
  470 |       handler: effect1,

  462 |     const effect1: Effect<string, number, Error> = domain.effect()
  463 |     const effect2 = domain.effect('', {
> 464 |       handler(params: string) {
      |                       ^^^^^^ [2]
  465 |         return 256
  466 |       },

  

  src/types/types.test.js
  470 |       handler: effect1,
  471 |     })
> 472 |     effect3(20)
      |             ^ 
      |  Cannot call \`effect3\` with \`20\` bound to \`payload\` 
      |  because number [1] is incompatible with string [2].
      |  
  473 |   })
  474 | 

  470 |       handler: effect1,
  471 |     })
> 472 |     effect3(20)
      |             ^^ [1]
  473 |   })
  474 | 

  460 |   test('#effect', () => {
  461 |     const domain = createDomain()
> 462 |     const effect1: Effect<string, number, Error> = domain.effect()
      |                           ^^^^^^ [2]
  463 |     const effect2 = domain.effect('', {
  464 |       handler(params: string) {

  

  src/types/types.test.js
  556 |       ],
  557 |     })
> 558 |     launch(foo, '')
      |                 ^ 
      |  Cannot call \`launch\` with empty string bound to \`payload\` 
      |  because string [1] is incompatible with number [2].
      |  
  559 |     launch(foo, 0)
  560 |     launch(customNode, 100)

  556 |       ],
  557 |     })
> 558 |     launch(foo, '')
      |                 ^^ [1]
  559 |     launch(foo, 0)
  560 |     launch(customNode, 100)

  537 | 
  538 |   test('launch', () => {
> 539 |     const foo = createEvent<number>()
      |                             ^^^^^^ [2]
  540 |     const customNode = createNode({
  541 |       scope: {max: 100, lastValue: -1, add: 10},

  

  src/types/types.test.js
  588 |       (initialProps: {id: number}) => {
  589 |         const createComponent_initialProps_check1: number = initialProps.id
> 590 |         const createComponent_initialProps_check2: string = initialProps.id
      |                                                             ^^^^^^^^^^^^^^ 
      |  Cannot assign \`initialProps.id\` to \`createComponent_initialProps_check2\` 
      |  because number [1] is incompatible with string [2].
      |  
  591 |         const createComponent_initialProps_check3: string =
  592 |           initialProps.unknownProp

  586 |     }>({})
  587 |     const InitialProps = createComponent(
> 588 |       (initialProps: {id: number}) => {
      |                           ^^^^^^ [1]
  589 |         const createComponent_initialProps_check1: number = initialProps.id
  590 |         const createComponent_initialProps_check2: string = initialProps.id

  588 |       (initialProps: {id: number}) => {
  589 |         const createComponent_initialProps_check1: number = initialProps.id
> 590 |         const createComponent_initialProps_check2: string = initialProps.id
      |                                                    ^^^^^^ [2]
  591 |         const createComponent_initialProps_check3: string =
  592 |           initialProps.unknownProp

  

  src/types/types.test.js
  590 |         const createComponent_initialProps_check2: string = initialProps.id
  591 |         const createComponent_initialProps_check3: string =
> 592 |           initialProps.unknownProp
      |                        ^^^^^^^^^^ 
      |  Cannot get \`initialProps.unknownProp\` 
      |  because property \`unknownProp\` is missing in object type [1].
      |  
  593 |         return list.map(list => list[initialProps.id] || {text: 'Loading...'})
  594 |       },

  586 |     }>({})
  587 |     const InitialProps = createComponent(
> 588 |       (initialProps: {id: number}) => {
      |                      ^^^^^^^^^^^^ [1]
  589 |         const createComponent_initialProps_check1: number = initialProps.id
  590 |         const createComponent_initialProps_check2: string = initialProps.id

  

  src/types/types.test.js
  595 |       (_, state) => {
  596 |         const createComponent_initialProps_check4: string = state.text
> 597 |         const createComponent_initialProps_check5: number = state.text
      |                                                             ^^^^^^^^^ 
      |  Cannot assign \`state.text\` to \`createComponent_initialProps_check5\` 
      |  because string [1] is incompatible with number [2].
      |  
  598 |         return null
  599 |       },

  582 |     const list = createStore<{
  583 |       [key: number]: {
> 584 |         text: string,
      |               ^^^^^^ [1]
  585 |       },
  586 |     }>({})

  595 |       (_, state) => {
  596 |         const createComponent_initialProps_check4: string = state.text
> 597 |         const createComponent_initialProps_check5: number = state.text
      |                                                    ^^^^^^ [2]
  598 |         return null
  599 |       },

  

  src/types/types.test.js
  602 | 
  603 |   test('createGate', () => {
> 604 |     const Foo = createGate<number>('foo')
      |                            ^^^^^ 
      |  Cannot call \`createGate\` 
      |  because number [1] is incompatible with object type [2] in type
      |  argument \`Props\`.
      |  
  605 |     const Bar = createGate<{a: number}>('bar')
  606 |     const Baz = createGate<number | null>('baz', null)

  602 | 
  603 |   test('createGate', () => {
> 604 |     const Foo = createGate<number>('foo')
      |                            ^^^^^^ [1]
  605 |     const Bar = createGate<{a: number}>('bar')
  606 |     const Baz = createGate<number | null>('baz', null)

  packages/effector-react/index.js.flow
   57 | declare export function useGate<Props>(Gate: Gate<Props>, props?: Props): void
   58 | 
>  59 | declare export function createGate<Props: {}>(name?: string): Gate<Props>
      |                                           ^^ [2]
   60 | declare export function createGate<Props>(
   61 |   name: string,

  

  src/types/types.test.js
  608 |     const Component = () => {
  609 |       useGate(Foo, 1)
> 610 |       useGate(Bar, 1)
      |                    ^ 
      |  Cannot call \`useGate\` with \`1\` bound to \`props\` 
      |  because number [1] is incompatible with object type [2].
      |  
  611 |       useGate(Bar, {a: 1})
  612 |       useGate(Bar, {})

  608 |     const Component = () => {
  609 |       useGate(Foo, 1)
> 610 |       useGate(Bar, 1)
      |                    ^^ [1]
  611 |       useGate(Bar, {a: 1})
  612 |       useGate(Bar, {})

  603 |   test('createGate', () => {
  604 |     const Foo = createGate<number>('foo')
> 605 |     const Bar = createGate<{a: number}>('bar')
      |                            ^^^^^^^^^^^ [2]
  606 |     const Baz = createGate<number | null>('baz', null)
  607 | 

  "
`;

exports[`TypeScript: rejected 1`] = `
"Command failed: npx tsc -p src/types

types.test.ts: Type 'Event<string[]>' is not assignable to type 'Event<number>'.
  Type 'string[]' is not assignable to type 'number'.
types.test.ts: Type 'Event<string[]>' is not assignable to type 'null'.
types.test.ts: Type 'Event<string[]>' is not assignable to type 'Event<number>'.
types.test.ts: Type 'Event<string[]>' is not assignable to type 'null'.
types.test.ts: Type 'null' is not assignable to type 'boolean'.
types.test.ts: Type '(list: null) => true' is not assignable to type '(payload: string[]) => boolean'.
  Types of parameters 'list' and 'payload' are incompatible.
    Type 'string[]' is not assignable to type 'null'.
types.test.ts: Type '(list: number[]) => true' is not assignable to type '(payload: string[]) => boolean'.
  Types of parameters 'list' and 'payload' are incompatible.
    Type 'string[]' is not assignable to type 'number[]'.
      Type 'string' is not assignable to type 'number'.
types.test.ts: Type 'Event<number>' is not assignable to type 'Event<string>'.
types.test.ts: Type 'Event<{ a: string; b: boolean; }>' is not assignable to type 'Event<string>'.
  Type '{ a: string; b: boolean; }' is not assignable to type 'string'.
types.test.ts: Type 'Event<number>' is not assignable to type 'Event<string>'.
types.test.ts: Type 'Event<{ a: string; b: boolean; }>' is not assignable to type 'Event<string>'.
  Type '{ a: string; b: boolean; }' is not assignable to type 'string'.
types.test.ts: Type 'Event<string>' is not assignable to type 'Event<number>'.
types.test.ts: Type 'Event<{ a: string; b: boolean; }>' is not assignable to type 'Event<number>'.
  Type '{ a: string; b: boolean; }' is not assignable to type 'number'.
types.test.ts: Type 'Store<boolean>' is not assignable to type 'Store<string>'.
  Type 'boolean' is not assignable to type 'string'.
types.test.ts: Type 'Store<{ a: string; b: boolean; }>' is not assignable to type 'Store<string>'.
  Type '{ a: string; b: boolean; }' is not assignable to type 'string'.
types.test.ts: Type 'Store<string>' is not assignable to type 'Store<number>'.
types.test.ts: Type 'Event<string>' is not assignable to type 'Event<number>'.
types.test.ts: Type 'Event<string>' is not assignable to type 'Event<number>'.
  Type 'string' is not assignable to type 'number'.
types.test.ts: Type 'Event<string>' is not assignable to type 'Event<number>'.
types.test.ts: Argument of type 'Effect<number, string, any>' is not assignable to parameter of type '(params: {}) => {} | Promise<{}>'.
  Types of parameters 'payload' and 'params' are incompatible.
    Type '{}' is not assignable to type 'number'.
types.test.ts: Expected 1 arguments, but got 0.
types.test.ts: Argument of type '() => void' is not assignable to parameter of type '(params: {}) => {} | Promise<{}>'.
  Type 'void' is not assignable to type '{} | Promise<{}>'.
types.test.ts: Type 'Effect<string, string, Error>' is not assignable to type 'Effect<number, number, Error>'.
  Type 'string' is not assignable to type 'number'.
types.test.ts: Type 'Store<number>' is not assignable to type 'Store<string>'.
  Type 'number' is not assignable to type 'string'.
types.test.ts: Type 'Event<number>' is not assignable to type 'Event<string>'.
  Type 'number' is not assignable to type 'string'.
types.test.ts: Type 'Event<void>' is not assignable to type 'Event<string>'.
  Type 'void' is not assignable to type 'string'.
types.test.ts: Type 'Store<string>' is not assignable to type 'Store<number>'.
  Type 'string' is not assignable to type 'number'.
types.test.ts: Argument of type '234' is not assignable to parameter of type 'string | undefined'.
types.test.ts: Argument of type '{ foo: boolean; }' is not assignable to parameter of type 'string'.
types.test.ts: Argument of type '20' is not assignable to parameter of type 'string'.
types.test.ts: Argument of type '20' is not assignable to parameter of type 'string'.
types.test.ts: Argument of type '\\"\\"' is not assignable to parameter of type 'number'.
types.test.ts: Type 'number' is not assignable to type 'string'.
types.test.ts: Property 'unknownProp' does not exist on type '{ id: number; }'.
types.test.ts: Type 'string' is not assignable to type 'number'.
types.test.ts: Type 'number' does not satisfy the constraint 'object'.
types.test.ts: Argument of type '1' is not assignable to parameter of type '{ a: number; } | undefined'.
types.test.ts: Argument of type '{}' is not assignable to parameter of type '{ a: number; }'.
  Property 'a' is missing in type '{}' but required in type '{ a: number; }'.
useStoreMap.test.tsx: Tuple type 'readonly [number]' of length '1' has no element at index '1'.
useStoreMap.test.tsx: Type '[number, \\"username\\" | \\"email\\" | \\"bio\\"]' is not assignable to type '[number, number]'.
  Type '\\"username\\" | \\"email\\" | \\"bio\\"' is not assignable to type 'number'.
    Type '\\"username\\"' is not assignable to type 'number'.
useStoreMap.test.tsx: Element implicitly has an 'any' type because index expression is not of type 'number'.
"
`;
