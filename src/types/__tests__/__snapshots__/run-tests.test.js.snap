// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Flow: json messages 1`] = `
"  src/types/types.test.js
   |             oneElement: list => list.length === 1,
   |           })
>  |           const split_result__nofpos__user_defined_1: Event<number> = emptyList
   |                                                                       ^^^^^^^^ 
   |  Cannot assign \`emptyList\` to \`split_result__nofpos__user_defined_1\` 
   |  because array type [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   |           const split_result__nofpos__user_defined_2: null = oneElement
   |         }

   |       test('split result no false-positive', () => {
   |         {
>  |           const source: Event<string[]> = createEvent()
   |                               ^^^^^^^^ [1]
   |           const {emptyList, oneElement} = split(source, {
   |             emptyList: list => list.length === 0,

   |             oneElement: list => list.length === 1,
   |           })
>  |           const split_result__nofpos__user_defined_1: Event<number> = emptyList
   |                                                             ^^^^^^ [2]
   |           const split_result__nofpos__user_defined_2: null = oneElement
   |         }

  packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  src/types/types.test.js
   |           })
   |           const split_result__nofpos__user_defined_1: Event<number> = emptyList
>  |           const split_result__nofpos__user_defined_2: null = oneElement
   |                                                              ^^^^^^^^^ 
   |  Cannot assign \`oneElement\` to \`split_result__nofpos__user_defined_2\` 
   |  because \`Event\` [1] is incompatible with null [2].
   |  
   |         }
   |         {

  packages/effector/index.js.flow
   | ): $ObjMap<
   |   {...Obj, __: (payload: S) => boolean, ...},
>  |   (h: (payload: S) => boolean) => Event<S>,
   |                                   ^^^^^^^^ [1]
   | >
   | declare export function restoreObject<

  src/types/types.test.js
   |           })
   |           const split_result__nofpos__user_defined_1: Event<number> = emptyList
>  |           const split_result__nofpos__user_defined_2: null = oneElement
   |                                                       ^^^^ [2]
   |         }
   |         {

  

  src/types/types.test.js
   |             oneElement: list => list.length === 1,
   |           })
>  |           const split_result__nofpos__defaults_1: Event<number> = __
   |                                                                   ^ 
   |  Cannot assign \`__\` to \`split_result__nofpos__defaults_1\` 
   |  because array type [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   |         }
   |         {

   |         }
   |         {
>  |           const source: Event<string[]> = createEvent()
   |                               ^^^^^^^^ [1]
   |           const {__} = split(source, {
   |             emptyList: list => list.length === 0,

   |             oneElement: list => list.length === 1,
   |           })
>  |           const split_result__nofpos__defaults_1: Event<number> = __
   |                                                         ^^^^^^ [2]
   |         }
   |         {

  packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  src/types/types.test.js
   |             oneElement: list => list.length === 1,
   |           })
>  |           const split_result__nofpos__defaults_2: null = __
   |                                                          ^ 
   |  Cannot assign \`__\` to \`split_result__nofpos__defaults_2\` 
   |  because \`Event\` [1] is incompatible with null [2].
   |  
   |         }
   |       })

  packages/effector/index.js.flow
   | ): $ObjMap<
   |   {...Obj, __: (payload: S) => boolean, ...},
>  |   (h: (payload: S) => boolean) => Event<S>,
   |                                   ^^^^^^^^ [1]
   | >
   | declare export function restoreObject<

  src/types/types.test.js
   |             oneElement: list => list.length === 1,
   |           })
>  |           const split_result__nofpos__defaults_2: null = __
   |                                                   ^^^^ [2]
   |         }
   |       })

  

  src/types/types.test.js
   |     test('split arguments no false-positive', () => {
   |       const source: Event<string[]> = createEvent()
>  |       split(source, {
   |       ^^^^ 
   |  Cannot call \`split\` 
   |  because null [1] is incompatible with array type [2] in property \`wrongArg_1\`.
   |  
   |         wrongResult: list => null,
   |         wrongArg_1: (list: null) => true,

   |       split(source, {
   |         wrongResult: list => null,
>  |         wrongArg_1: (list: null) => true,
   |                            ^^^^ [1]
   |         wrongArg_2: (list: number[]) => true,
   |       })

   | 
   |     test('split arguments no false-positive', () => {
>  |       const source: Event<string[]> = createEvent()
   |                           ^^^^^^^^ [2]
   |       split(source, {
   |         wrongResult: list => null,

  

  src/types/types.test.js
   |       const source: Event<string[]> = createEvent()
   |       split(source, {
>  |         wrongResult: list => null,
   |                              ^^^ 
   |  Cannot call \`split\` with object literal bound to \`cases\` 
   |  because null [1] is incompatible with boolean [2] in the return value of
   |  property \`wrongResult\`.
   |  
   |         wrongArg_1: (list: null) => true,
   |         wrongArg_2: (list: number[]) => true,

   |       const source: Event<string[]> = createEvent()
   |       split(source, {
>  |         wrongResult: list => null,
   |                              ^^^^ [1]
   |         wrongArg_1: (list: null) => true,
   |         wrongArg_2: (list: number[]) => true,

  packages/effector/index.js.flow
   |   S,
   |   Obj: {
>  |     +[name: string]: (payload: S) => boolean,
   |                                      ^^^^^^^ [2]
   |     ...,
   |   },

  

  src/types/types.test.js
   |       split(source, {
   |         wrongResult: list => null,
>  |         wrongArg_1: (list: null) => true,
   |                            ^^^ 
   |  Cannot call \`split\` with object literal bound to \`cases\` 
   |  because null [1] is incompatible with array type [2] in the first argument of
   |  property \`wrongArg_1\`.
   |  
   |         wrongArg_2: (list: number[]) => true,
   |       })

   |       split(source, {
   |         wrongResult: list => null,
>  |         wrongArg_1: (list: null) => true,
   |                            ^^^^ [1]
   |         wrongArg_2: (list: number[]) => true,
   |       })

   | 
   |     test('split arguments no false-positive', () => {
>  |       const source: Event<string[]> = createEvent()
   |                           ^^^^^^^^ [2]
   |       split(source, {
   |         wrongResult: list => null,

  

  src/types/types.test.js
   |         wrongResult: list => null,
   |         wrongArg_1: (list: null) => true,
>  |         wrongArg_2: (list: number[]) => true,
   |                            ^^^^^ 
   |  Cannot call \`split\` with object literal bound to \`cases\` 
   |  because number [1] is incompatible with string [2] in array element of the
   |  first argument of property \`wrongArg_2\`.
   |  
   |       })
   |     })

   |         wrongResult: list => null,
   |         wrongArg_1: (list: null) => true,
>  |         wrongArg_2: (list: number[]) => true,
   |                            ^^^^^^ [1]
   |       })
   |     })

   | 
   |     test('split arguments no false-positive', () => {
>  |       const source: Event<string[]> = createEvent()
   |                           ^^^^^^ [2]
   |       split(source, {
   |         wrongResult: list => null,

  

  src/types/types.test.js
   | 
   |       const sample_ee_check1: Event<number> = c
>  |       const sample_ee_check2: Event<string> = c
   |                                               ^ 
   |  Cannot assign \`c\` to \`sample_ee_check2\` 
   |  because number [1] is incompatible with string [2] in type argument
   |  \`Payload\` [3].
   |  
   |     })
   |     test('event by event with handler', () => {

   |   describe('sample', () => {
   |     test('event by event', () => {
>  |       const a = createEvent<number>()
   |                             ^^^^^^ [1]
   |       const b = createEvent<boolean>()
   |       const c = sample(a, b)

   | 
   |       const sample_ee_check1: Event<number> = c
>  |       const sample_ee_check2: Event<string> = c
   |                                     ^^^^^^ [2]
   |     })
   |     test('event by event with handler', () => {

  packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  src/types/types.test.js
   | 
   |       const sample_eeh_check1: Event<{a: string, b: boolean}> = c
>  |       const sample_eeh_check2: Event<string> = c
   |                                                ^ 
   |  Cannot assign \`c\` to \`sample_eeh_check2\` 
   |  because object type [1] is incompatible with string [2] in type argument
   |  \`Payload\` [3].
   |  
   |     })
   | 

   |       const c = sample(a, b, (a, b) => ({a, b}))
   | 
>  |       const sample_eeh_check1: Event<{a: string, b: boolean}> = c
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^ [1]
   |       const sample_eeh_check2: Event<string> = c
   |     })

   | 
   |       const sample_eeh_check1: Event<{a: string, b: boolean}> = c
>  |       const sample_eeh_check2: Event<string> = c
   |                                      ^^^^^^ [2]
   |     })
   | 

  packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  src/types/types.test.js
   | 
   |       const sample_se_check1: Event<number> = e
>  |       const sample_se_check2: Event<string> = e
   |                                               ^ 
   |  Cannot assign \`e\` to \`sample_se_check2\` 
   |  because number [1] is incompatible with string [2] in type argument
   |  \`Payload\` [3].
   |  
   |     })
   |     test('store by event with handler', () => {

   |       const e = sample(d, b)
   | 
>  |       const sample_se_check1: Event<number> = e
   |                                     ^^^^^^ [1]
   |       const sample_se_check2: Event<string> = e
   |     })

   | 
   |       const sample_se_check1: Event<number> = e
>  |       const sample_se_check2: Event<string> = e
   |                                     ^^^^^^ [2]
   |     })
   |     test('store by event with handler', () => {

  packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  src/types/types.test.js
   | 
   |       const sample_seh_check1: Event<{a: string, b: boolean}> = e
>  |       const sample_seh_check2: Event<string> = e
   |                                                ^ 
   |  Cannot assign \`e\` to \`sample_seh_check2\` 
   |  because object type [1] is incompatible with string [2] in type argument
   |  \`Payload\` [3].
   |  
   |     })
   | 

   |       const e = sample(d, b, (a, b) => ({a, b}))
   | 
>  |       const sample_seh_check1: Event<{a: string, b: boolean}> = e
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^ [1]
   |       const sample_seh_check2: Event<string> = e
   |     })

   | 
   |       const sample_seh_check1: Event<{a: string, b: boolean}> = e
>  |       const sample_seh_check2: Event<string> = e
   |                                      ^^^^^^ [2]
   |     })
   | 

  packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  src/types/types.test.js
   | 
   |       const sample_efe_check1: Event<string> = g
>  |       const sample_efe_check2: Event<number> = g
   |                                                ^ 
   |  Cannot assign \`g\` to \`sample_efe_check2\` 
   |  because string [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   |     })
   |     test('effect by event with handler', () => {

   | 
   |     test('effect by event', () => {
>  |       const f = createEffect<string, any, any>()
   |                              ^^^^^^ [1]
   |       const b = createEvent<boolean>()
   |       const g = sample(f, b)

   | 
   |       const sample_efe_check1: Event<string> = g
>  |       const sample_efe_check2: Event<number> = g
   |                                      ^^^^^^ [2]
   |     })
   |     test('effect by event with handler', () => {

  packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  src/types/types.test.js
   | 
   |       const sample_efeh_check1: Event<{a: string, b: boolean}> = g
>  |       const sample_efeh_check2: Event<number> = g
   |                                                 ^ 
   |  Cannot assign \`g\` to \`sample_efeh_check2\` 
   |  because object type [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   |     })
   | 

   |       const g = sample(f, b, (a, b) => ({a, b}))
   | 
>  |       const sample_efeh_check1: Event<{a: string, b: boolean}> = g
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^ [1]
   |       const sample_efeh_check2: Event<number> = g
   |     })

   | 
   |       const sample_efeh_check1: Event<{a: string, b: boolean}> = g
>  |       const sample_efeh_check2: Event<number> = g
   |                                       ^^^^^^ [2]
   |     })
   | 

  packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  src/types/types.test.js
   | 
   |       const sample_ss_check1: Store<boolean> = c
>  |       const sample_ss_check2: Store<string> = c
   |                                               ^ 
   |  Cannot assign \`c\` to \`sample_ss_check2\` 
   |  because boolean [1] is incompatible with string [2] in type
   |  argument \`State\` [3].
   |  
   |     })
   |     test('store by store with handler', () => {

   |       const c = sample(a, b)
   | 
>  |       const sample_ss_check1: Store<boolean> = c
   |                                     ^^^^^^^ [1]
   |       const sample_ss_check2: Store<string> = c
   |     })

   | 
   |       const sample_ss_check1: Store<boolean> = c
>  |       const sample_ss_check2: Store<string> = c
   |                                     ^^^^^^ [2]
   |     })
   |     test('store by store with handler', () => {

  packages/effector/index.js.flow
   | }
   | 
>  | declare export class Store<State> implements Unit<State> {
   |                            ^^^^^ [3]
   |   +kind: kind;
   |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
   | 
   |       const sample_ssh_check1: Store<{a: string, b: boolean}> = c
>  |       const sample_ssh_check2: Store<string> = c
   |                                                ^ 
   |  Cannot assign \`c\` to \`sample_ssh_check2\` 
   |  because object type [1] is incompatible with string [2] in type
   |  argument \`State\` [3].
   |  
   |     })
   |     describe('sample(Store<T>):Store<T>', () => {

   |       const c = sample(a, b, (a, b) => ({a, b}))
   | 
>  |       const sample_ssh_check1: Store<{a: string, b: boolean}> = c
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^ [1]
   |       const sample_ssh_check2: Store<string> = c
   |     })

   | 
   |       const sample_ssh_check1: Store<{a: string, b: boolean}> = c
>  |       const sample_ssh_check2: Store<string> = c
   |                                      ^^^^^^ [2]
   |     })
   |     describe('sample(Store<T>):Store<T>', () => {

  packages/effector/index.js.flow
   | }
   | 
>  | declare export class Store<State> implements Unit<State> {
   |                            ^^^^^ [3]
   |   +kind: kind;
   |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
   |       test('incorrect case', () => {
   |         const a = createStore('')
>  |         const sample_s_incorrect: Store<number> = sample(a)
   |                                                   ^^^^^^^^ 
   |  Cannot assign \`sample(...)\` to \`sample_s_incorrect\` 
   |  because string [1] is incompatible with number [2] in type argument \`State\` [3].
   |  
   |       })
   |       describe('edge case', () => {

   |       })
   |       test('incorrect case', () => {
>  |         const a = createStore('')
   |                               ^^ [1]
   |         const sample_s_incorrect: Store<number> = sample(a)
   |       })

   |       test('incorrect case', () => {
   |         const a = createStore('')
>  |         const sample_s_incorrect: Store<number> = sample(a)
   |                                         ^^^^^^ [2]
   |       })
   |       describe('edge case', () => {

  packages/effector/index.js.flow
   | }
   | 
>  | declare export class Store<State> implements Unit<State> {
   |                            ^^^^^ [3]
   |   +kind: kind;
   |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
   |           const a = createStore('')
   |           const clock = createEvent()
>  |           const sample_s_edge_incorrect: Event<number> = sample(a, clock)
   |                                                          ^^^^^^^^^^^^^^^ 
   |  Cannot assign \`sample(...)\` to \`sample_s_edge_incorrect\` 
   |  because string [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   |         })
   |       })

   |         })
   |         test('incorrect case', () => {
>  |           const a = createStore('')
   |                                 ^^ [1]
   |           const clock = createEvent()
   |           const sample_s_edge_incorrect: Event<number> = sample(a, clock)

   |           const a = createStore('')
   |           const clock = createEvent()
>  |           const sample_s_edge_incorrect: Event<number> = sample(a, clock)
   |                                                ^^^^^^ [2]
   |         })
   |       })

  packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  src/types/types.test.js
   | 
   |     //const check1: Event<string> = computed
>  |     const event_map_check2: Event<number> = computed
   |                                             ^^^^^^^ 
   |  Cannot assign \`computed\` to \`event_map_check2\` 
   |  because string [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   |     event(2)
   |     computed('')

   |   test('#map', () => {
   |     const event: Event<number> = createEvent()
>  |     const computed = event.map(() => 'foo')
   |                                      ^^^^^ [1]
   | 
   |     //const check1: Event<string> = computed

   | 
   |     //const check1: Event<string> = computed
>  |     const event_map_check2: Event<number> = computed
   |                                   ^^^^^^ [2]
   |     event(2)
   |     computed('')

  packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  src/types/types.test.js
   | 
   |     //const check1: Event<string> = computed
>  |     const event_map_check2: Event<number> = computed
   |                                             ^^^^^^^ 
   |  Cannot assign \`computed\` to \`event_map_check2\` 
   |  because string [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   |     event(2)
   |     computed('')

   |     const event_map_check2: Event<number> = computed
   |     event(2)
>  |     computed('')
   |              ^^ [1]
   |   })
   |   test('#watch', () => {

   | 
   |     //const check1: Event<string> = computed
>  |     const event_map_check2: Event<number> = computed
   |                                   ^^^^^^ [2]
   |     event(2)
   |     computed('')

  packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  src/types/types.test.js
   |       const event: Event<number> = createEvent()
   |       const filteredEvent_error: Event<number> = event.filter(n => {
>  |         if (n % 2) return n.toString()
   |                           ^^^^^^^^^^^ 
   |  Cannot assign \`event.filter(...)\` to \`filteredEvent_error\` 
   |  because string [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   |       })
   |     })

   [LIB] core.js
>  |     toString(radix?: number): string;
   |                               ^^^^^^ [1]

  src/types/types.test.js
   |     test('#filter incorrect', () => {
   |       const event: Event<number> = createEvent()
>  |       const filteredEvent_error: Event<number> = event.filter(n => {
   |                                        ^^^^^^ [2]
   |         if (n % 2) return n.toString()
   |       })

  packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  src/types/types.test.js
   |       test('no false-positive (should be type error)', () => {
   |         const nestedEffect: Effect<string, string> = createEffect()
>  |         const parentEffect: Effect<number, number> = createEffect(
   |                                                      ^^^^^^^^^^^^
>  |           'should not throw',
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>  |           {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>  |             handler: nestedEffect,
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>  |           },
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>  |         )
   | ^^^^^^^^^ 
   |  Cannot assign \`createEffect(...)\` to \`parentEffect\` 
   |  because number [1] is incompatible with string [2] in type
   |  argument \`Params\` [3].
   |  
   |       })
   |     })

   |       test('no false-positive (should be type error)', () => {
   |         const nestedEffect: Effect<string, string> = createEffect()
>  |         const parentEffect: Effect<number, number> = createEffect(
   |                                    ^^^^^^ [1]
   |           'should not throw',
   |           {

   |     describe('with handler', () => {
   |       test('no false-positive (should be type error)', () => {
>  |         const nestedEffect: Effect<string, string> = createEffect()
   |                                    ^^^^^^ [2]
   |         const parentEffect: Effect<number, number> = createEffect(
   |           'should not throw',

  packages/effector/index.js.flow
   | }
   | 
>  | declare export class Effect<Params, Done, Fail = Error>
   |                             ^^^^^^ [3]
   |   implements Unit<Params> {
   |   (payload: Params): Promise<Done>;

  

  src/types/types.test.js
   |       test('no false-positive (should be type error)', () => {
   |         const nestedEffect: Effect<string, string> = createEffect()
>  |         const parentEffect: Effect<number, number> = createEffect(
   |                                                      ^^^^^^^^^^^^
>  |           'should not throw',
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>  |           {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>  |             handler: nestedEffect,
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>  |           },
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>  |         )
   | ^^^^^^^^^ 
   |  Cannot assign \`createEffect(...)\` to \`parentEffect\` 
   |  because string [1] is incompatible with number [2] in type argument \`Done\` [3].
   |  
   |       })
   |     })

   |     describe('with handler', () => {
   |       test('no false-positive (should be type error)', () => {
>  |         const nestedEffect: Effect<string, string> = createEffect()
   |                                            ^^^^^^ [1]
   |         const parentEffect: Effect<number, number> = createEffect(
   |           'should not throw',

   |       test('no false-positive (should be type error)', () => {
   |         const nestedEffect: Effect<string, string> = createEffect()
>  |         const parentEffect: Effect<number, number> = createEffect(
   |                                            ^^^^^^ [2]
   |           'should not throw',
   |           {

  packages/effector/index.js.flow
   | }
   | 
>  | declare export class Effect<Params, Done, Fail = Error>
   |                                     ^^^^ [3]
   |   implements Unit<Params> {
   |   (payload: Params): Promise<Done>;

  

  src/types/types.test.js
   |   test('createStore', () => {
   |     const createStore_store1: Store<number> = createStore(0)
>  |     const createStore_store2: Store<string> = createStore(0)
   |                                                           ^ 
   |  Cannot assign \`createStore(...)\` to \`createStore_store2\` 
   |  because number [1] is incompatible with string [2] in type argument \`State\` [3].
   |  
   |   })
   |   test('createStoreObject', () => {

   |   test('createStore', () => {
   |     const createStore_store1: Store<number> = createStore(0)
>  |     const createStore_store2: Store<string> = createStore(0)
   |                                                           ^^ [1]
   |   })
   |   test('createStoreObject', () => {

   |   test('createStore', () => {
   |     const createStore_store1: Store<number> = createStore(0)
>  |     const createStore_store2: Store<string> = createStore(0)
   |                                     ^^^^^^ [2]
   |   })
   |   test('createStoreObject', () => {

  packages/effector/index.js.flow
   | }
   | 
>  | declare export class Store<State> implements Unit<State> {
   |                            ^^^^^ [3]
   |   +kind: kind;
   |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
   |         event: (n, x: number) => x,
   |       })
>  |       const createApi_check2: Event<string> = event
   |                                               ^^^^ 
   |  Cannot assign \`event\` to \`createApi_check2\` 
   |  because string [1] is incompatible with number [2] in type argument
   |  \`Payload\` [3].
   |  
   |     }
   |     {

   |         event: (n, x: number) => x,
   |       })
>  |       const createApi_check2: Event<string> = event
   |                                     ^^^^^^ [1]
   |     }
   |     {

   |     {
   |       const {event} = createApi(store, {
>  |         event: (n, x: number) => x,
   |                       ^^^^^^ [2]
   |       })
   |       const createApi_check2: Event<string> = event

  packages/effector/index.js.flow
   | |}
   | 
>  | declare export class Event<Payload> implements Unit<Payload> {
   |                            ^^^^^^^ [3]
   |   (payload: Payload): Payload;
   |   +kind: kind;

  

  src/types/types.test.js
   |     {
   |       const {event} = createApi(store, {
>  |         event: (n, x) => x,
   |                          ^ 
   |  Cannot call \`createApi\` with object literal bound to \`api\` 
   |  because string [1] is incompatible with number [2] in the return value of
   |  property \`event\`.
   |  
   |       })
   |       const createApi_check3: Event<string> = event

   |         event: (n, x) => x,
   |       })
>  |       const createApi_check3: Event<string> = event
   |                                     ^^^^^^ [1]
   |     }
   |   })

   |   })
   |   test('createApi', () => {
>  |     const store: Store<number> = createStore(0)
   |                        ^^^^^^ [2]
   |     {
   |       const {event} = createApi(store, {

  

  src/types/types.test.js
   |     const map_check1: Store<string> = computed
   | 
>  |     const map_check2: Store<number> = computed
   |                                       ^^^^^^^ 
   |  Cannot assign \`computed\` to \`map_check2\` 
   |  because string [1] is incompatible with number [2] in type argument \`State\` [3].
   |  
   |   })
   | 

   |     const computed = store.map(() => 'hello')
   | 
>  |     const map_check1: Store<string> = computed
   |                             ^^^^^^ [1]
   | 
   |     const map_check2: Store<number> = computed

   |     const map_check1: Store<string> = computed
   | 
>  |     const map_check2: Store<number> = computed
   |                             ^^^^^^ [2]
   |   })
   | 

  packages/effector/index.js.flow
   | }
   | 
>  | declare export class Store<State> implements Unit<State> {
   |                            ^^^^^ [3]
   |   +kind: kind;
   |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
   |     const domain = createDomain()
   |     const domain2 = createDomain('hello')
>  |     const domain3 = createDomain(234)
   |                                  ^^ 
   |  Cannot call \`createDomain\` with \`234\` bound to \`domainName\` 
   |  because number [1] is incompatible with string [2].
   |  
   |     const domain4 = createDomain({foo: true})
   |   })

   |     const domain = createDomain()
   |     const domain2 = createDomain('hello')
>  |     const domain3 = createDomain(234)
   |                                  ^^^ [1]
   |     const domain4 = createDomain({foo: true})
   |   })

  packages/effector/index.js.flow
   |   <S>(field: Store<S> | S) => Store<S>,
   | >
>  | declare export function createDomain(domainName?: string): Domain
   |                                                   ^^^^^^ [2]
   | 
   | declare export function sample<A>(config: {|

  

  src/types/types.test.js
   |     const domain2 = createDomain('hello')
   |     const domain3 = createDomain(234)
>  |     const domain4 = createDomain({foo: true})
   |                                  ^^^^^^^^^^ 
   |  Cannot call \`createDomain\` with object literal bound to \`domainName\` 
   |  because object literal [1] is incompatible with string [2].
   |  
   |   })
   | 

   |     const domain2 = createDomain('hello')
   |     const domain3 = createDomain(234)
>  |     const domain4 = createDomain({foo: true})
   |                                  ^^^^^^^^^^^ [1]
   |   })
   | 

  packages/effector/index.js.flow
   |   <S>(field: Store<S> | S) => Store<S>,
   | >
>  | declare export function createDomain(domainName?: string): Domain
   |                                                   ^^^^^^ [2]
   | 
   | declare export function sample<A>(config: {|

  

  src/types/types.test.js
   |       },
   |     })
>  |     effect2(20)
   |             ^ 
   |  Cannot call \`effect2\` with \`20\` bound to \`payload\` 
   |  because number [1] is incompatible with string [2].
   |  
   |     const effect3 = domain.effect('', {
   |       handler: effect1,

   |       },
   |     })
>  |     effect2(20)
   |             ^^ [1]
   |     const effect3 = domain.effect('', {
   |       handler: effect1,

   |     const effect1: Effect<string, number, Error> = domain.effect()
   |     const effect2 = domain.effect('', {
>  |       handler(params: string) {
   |                       ^^^^^^ [2]
   |         return 256
   |       },

  

  src/types/types.test.js
   |       handler: effect1,
   |     })
>  |     effect3(20)
   |             ^ 
   |  Cannot call \`effect3\` with \`20\` bound to \`payload\` 
   |  because number [1] is incompatible with string [2].
   |  
   |   })
   | 

   |       handler: effect1,
   |     })
>  |     effect3(20)
   |             ^^ [1]
   |   })
   | 

   |   test('#effect', () => {
   |     const domain = createDomain()
>  |     const effect1: Effect<string, number, Error> = domain.effect()
   |                           ^^^^^^ [2]
   |     const effect2 = domain.effect('', {
   |       handler(params: string) {

  

  src/types/types.test.js
   |       const num: Event<number> = createEvent()
   |       it('incompatible (should fail)', () => {
>  |         forward({from: str, to: num})
   |                 ^^^^^^^^^^^^^^^^^^^ 
   |  Cannot call \`forward\` with object literal bound to \`opts\` 
   |  because number [1] is incompatible with string [2] in type argument \`T\` [3] of
   |  property \`to\`.
   |  
   |       })
   |       it('same types (should be ok)', () => {

   |       const str: Event<string> = createEvent()
   |       const strOrNum: Event<string | number> = createEvent()
>  |       const num: Event<number> = createEvent()
   |                        ^^^^^^ [1]
   |       it('incompatible (should fail)', () => {
   |         forward({from: str, to: num})

   |     })
   |     describe('forward with subtyping', () => {
>  |       const str: Event<string> = createEvent()
   |                        ^^^^^^ [2]
   |       const strOrNum: Event<string | number> = createEvent()
   |       const num: Event<number> = createEvent()

  packages/effector/index.js.flow
   |   +kind: kind;
   | }
>  | export interface Unit<T> extends CovariantUnit<T>, ContravariantUnit<T> {
   |                       ^^ [3]
   |   +kind: kind;
   | }

  

  src/types/types.test.js
   |       })
   |       it('less strict -> more strict type (should fail)', () => {
>  |         forward({from: strOrNum, to: str})
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^ 
   |  Cannot call \`forward\` with object literal bound to \`opts\` 
   |  because string [1] is incompatible with number [2] in type argument \`T\` [3] of
   |  property \`to\`.
   |  
   |       })
   |       it('generic from (?)', () => {

   |     })
   |     describe('forward with subtyping', () => {
>  |       const str: Event<string> = createEvent()
   |                        ^^^^^^ [1]
   |       const strOrNum: Event<string | number> = createEvent()
   |       const num: Event<number> = createEvent()

   |     describe('forward with subtyping', () => {
   |       const str: Event<string> = createEvent()
>  |       const strOrNum: Event<string | number> = createEvent()
   |                                      ^^^^^^ [2]
   |       const num: Event<number> = createEvent()
   |       it('incompatible (should fail)', () => {

  packages/effector/index.js.flow
   |   +kind: kind;
   | }
>  | export interface Unit<T> extends CovariantUnit<T>, ContravariantUnit<T> {
   |                       ^^ [3]
   |   +kind: kind;
   | }

  

  src/types/types.test.js
   |       })
   |       it('generic from (?)', () => {
>  |         forward<string | number>({from: strOrNum, to: str})
   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^ 
   |  Cannot call \`forward\` with object literal bound to \`opts\` 
   |  because string [1] is incompatible with number [2] in type argument \`T\` [3] of
   |  property \`to\`.
   |  
   |       })
   |       it('generic to (should fail)', () => {

   |     })
   |     describe('forward with subtyping', () => {
>  |       const str: Event<string> = createEvent()
   |                        ^^^^^^ [1]
   |       const strOrNum: Event<string | number> = createEvent()
   |       const num: Event<number> = createEvent()

   |       })
   |       it('generic from (?)', () => {
>  |         forward<string | number>({from: strOrNum, to: str})
   |                          ^^^^^^ [2]
   |       })
   |       it('generic to (should fail)', () => {

  packages/effector/index.js.flow
   |   +kind: kind;
   | }
>  | export interface Unit<T> extends CovariantUnit<T>, ContravariantUnit<T> {
   |                       ^^ [3]
   |   +kind: kind;
   | }

  

  src/types/types.test.js
   |       })
   |       it('generic to (should fail)', () => {
>  |         forward<string>({from: strOrNum, to: str})
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^ 
   |  Cannot call \`forward\` with object literal bound to \`opts\` 
   |  because number [1] is incompatible with string [2] in type argument \`T\` [3] of
   |  property \`from\`.
   |  
   |       })
   |     })

   |     describe('forward with subtyping', () => {
   |       const str: Event<string> = createEvent()
>  |       const strOrNum: Event<string | number> = createEvent()
   |                                      ^^^^^^ [1]
   |       const num: Event<number> = createEvent()
   |       it('incompatible (should fail)', () => {

   |       })
   |       it('generic to (should fail)', () => {
>  |         forward<string>({from: strOrNum, to: str})
   |                 ^^^^^^ [2]
   |       })
   |     })

  packages/effector/index.js.flow
   |   ...
   | }
>  | interface CovariantUnit<+T> {
   |                          ^^ [3]
   |   +kind: kind;
   | }

  

  src/types/types.test.js
   |       ],
   |     })
>  |     launch(foo, '')
   |                 ^ 
   |  Cannot call \`launch\` with empty string bound to \`payload\` 
   |  because string [1] is incompatible with number [2].
   |  
   |     launch(foo, 0)
   |     launch(customNode, 100)

   |       ],
   |     })
>  |     launch(foo, '')
   |                 ^^ [1]
   |     launch(foo, 0)
   |     launch(customNode, 100)

   | 
   |   test('launch', () => {
>  |     const foo = createEvent<number>()
   |                             ^^^^^^ [2]
   |     const customNode = createNode({
   |       scope: {max: 100, lastValue: -1, add: 10},

  

  src/types/types.test.js
   |       (initialProps: {id: number}) => {
   |         const createComponent_initialProps_check1: number = initialProps.id
>  |         const createComponent_initialProps_check2: string = initialProps.id
   |                                                             ^^^^^^^^^^^^^^ 
   |  Cannot assign \`initialProps.id\` to \`createComponent_initialProps_check2\` 
   |  because number [1] is incompatible with string [2].
   |  
   |         const createComponent_initialProps_check3: string =
   |           initialProps.unknownProp

   |     }>({})
   |     const InitialProps = createComponent(
>  |       (initialProps: {id: number}) => {
   |                           ^^^^^^ [1]
   |         const createComponent_initialProps_check1: number = initialProps.id
   |         const createComponent_initialProps_check2: string = initialProps.id

   |       (initialProps: {id: number}) => {
   |         const createComponent_initialProps_check1: number = initialProps.id
>  |         const createComponent_initialProps_check2: string = initialProps.id
   |                                                    ^^^^^^ [2]
   |         const createComponent_initialProps_check3: string =
   |           initialProps.unknownProp

  

  src/types/types.test.js
   |         const createComponent_initialProps_check2: string = initialProps.id
   |         const createComponent_initialProps_check3: string =
>  |           initialProps.unknownProp
   |                        ^^^^^^^^^^ 
   |  Cannot get \`initialProps.unknownProp\` 
   |  because property \`unknownProp\` is missing in object type [1].
   |  
   |         return list.map(list => list[initialProps.id] || {text: 'Loading...'})
   |       },

   |     }>({})
   |     const InitialProps = createComponent(
>  |       (initialProps: {id: number}) => {
   |                      ^^^^^^^^^^^^ [1]
   |         const createComponent_initialProps_check1: number = initialProps.id
   |         const createComponent_initialProps_check2: string = initialProps.id

  

  src/types/types.test.js
   |       (_, state) => {
   |         const createComponent_initialProps_check4: string = state.text
>  |         const createComponent_initialProps_check5: number = state.text
   |                                                             ^^^^^^^^^ 
   |  Cannot assign \`state.text\` to \`createComponent_initialProps_check5\` 
   |  because string [1] is incompatible with number [2].
   |  
   |         return null
   |       },

   |     const list = createStore<{
   |       [key: number]: {
>  |         text: string,
   |               ^^^^^^ [1]
   |       },
   |     }>({})

   |       (_, state) => {
   |         const createComponent_initialProps_check4: string = state.text
>  |         const createComponent_initialProps_check5: number = state.text
   |                                                    ^^^^^^ [2]
   |         return null
   |       },

  

  src/types/types.test.js
   | 
   |   test('createGate', () => {
>  |     const Foo = createGate<number>('foo')
   |                            ^^^^^ 
   |  Cannot call \`createGate\` 
   |  because number [1] is incompatible with object type [2] in type
   |  argument \`Props\`.
   |  
   |     const Bar = createGate<{a: number}>('bar')
   |     const Baz = createGate<number | null>('baz', null)

   | 
   |   test('createGate', () => {
>  |     const Foo = createGate<number>('foo')
   |                            ^^^^^^ [1]
   |     const Bar = createGate<{a: number}>('bar')
   |     const Baz = createGate<number | null>('baz', null)

  packages/effector-react/index.js.flow
   | declare export function useGate<Props>(Gate: Gate<Props>, props?: Props): void
   | 
>  | declare export function createGate<Props: {...}>(name?: string): Gate<Props>
   |                                           ^^^^^ [2]
   | declare export function createGate<Props>(
   |   name: string,

  

  src/types/types.test.js
   |     const Component = () => {
   |       useGate(Foo, 1)
>  |       useGate(Bar, 1)
   |                    ^ 
   |  Cannot call \`useGate\` with \`1\` bound to \`props\` 
   |  because number [1] is incompatible with object type [2].
   |  
   |       useGate(Bar, {a: 1})
   |       useGate(Bar, {})

   |     const Component = () => {
   |       useGate(Foo, 1)
>  |       useGate(Bar, 1)
   |                    ^^ [1]
   |       useGate(Bar, {a: 1})
   |       useGate(Bar, {})

   |   test('createGate', () => {
   |     const Foo = createGate<number>('foo')
>  |     const Bar = createGate<{a: number}>('bar')
   |                            ^^^^^^^^^^^ [2]
   |     const Baz = createGate<number | null>('baz', null)
   | 

  "
`;

exports[`TypeScript: rejected 1`] = `
"Command failed: npx tsc -p src/types

types.test.ts: Type 'Event<string[]>' is not assignable to type 'Event<number>'.
  Types of property 'watch' are incompatible.
    Type '(watcher: (payload: string[]) => any) => Subscription' is not assignable to type '(watcher: (payload: number) => any) => Subscription'.
      Types of parameters 'watcher' and 'watcher' are incompatible.
        Types of parameters 'payload' and 'payload' are incompatible.
          Type 'string[]' is not assignable to type 'number'.
types.test.ts: Type 'Event<string[]>' is not assignable to type 'null'.
types.test.ts: Type 'Event<string[]>' is not assignable to type 'Event<number>'.
types.test.ts: Type 'Event<string[]>' is not assignable to type 'null'.
types.test.ts: Type 'null' is not assignable to type 'boolean'.
types.test.ts: Type '(list: null) => true' is not assignable to type '(payload: string[]) => boolean'.
  Types of parameters 'list' and 'payload' are incompatible.
    Type 'string[]' is not assignable to type 'null'.
types.test.ts: Type '(list: number[]) => true' is not assignable to type '(payload: string[]) => boolean'.
  Types of parameters 'list' and 'payload' are incompatible.
    Type 'string[]' is not assignable to type 'number[]'.
      Type 'string' is not assignable to type 'number'.
types.test.ts: Type 'Event<number>' is not assignable to type 'Event<string>'.
types.test.ts: Type 'Event<{ a: string; b: boolean; }>' is not assignable to type 'Event<string>'.
  Types of property 'watch' are incompatible.
    Type '(watcher: (payload: { a: string; b: boolean; }) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
      Types of parameters 'watcher' and 'watcher' are incompatible.
        Types of parameters 'payload' and 'payload' are incompatible.
          Type '{ a: string; b: boolean; }' is not assignable to type 'string'.
types.test.ts: Type 'Event<number>' is not assignable to type 'Event<string>'.
types.test.ts: Type 'Event<{ a: string; b: boolean; }>' is not assignable to type 'Event<string>'.
  Types of property 'watch' are incompatible.
    Type '(watcher: (payload: { a: string; b: boolean; }) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
      Types of parameters 'watcher' and 'watcher' are incompatible.
        Types of parameters 'payload' and 'payload' are incompatible.
          Type '{ a: string; b: boolean; }' is not assignable to type 'string'.
types.test.ts: Type 'Event<string>' is not assignable to type 'Event<number>'.
types.test.ts: Type 'Event<{ a: string; b: boolean; }>' is not assignable to type 'Event<number>'.
  Types of property 'watch' are incompatible.
    Type '(watcher: (payload: { a: string; b: boolean; }) => any) => Subscription' is not assignable to type '(watcher: (payload: number) => any) => Subscription'.
      Types of parameters 'watcher' and 'watcher' are incompatible.
        Types of parameters 'payload' and 'payload' are incompatible.
          Type '{ a: string; b: boolean; }' is not assignable to type 'number'.
types.test.ts: Type 'Store<boolean>' is not assignable to type 'Store<string>'.
  Types of property 'getState' are incompatible.
    Type '() => boolean' is not assignable to type '() => string'.
      Type 'boolean' is not assignable to type 'string'.
types.test.ts: Type 'Store<{ a: string; b: boolean; }>' is not assignable to type 'Store<string>'.
  Types of property 'getState' are incompatible.
    Type '() => { a: string; b: boolean; }' is not assignable to type '() => string'.
      Type '{ a: string; b: boolean; }' is not assignable to type 'string'.
types.test.ts: Type 'Store<string>' is not assignable to type 'Store<number>'.
types.test.ts: Type 'Event<string>' is not assignable to type 'Event<number>'.
types.test.ts: Type 'Event<string>' is not assignable to type 'Event<number>'.
  Types of property 'watch' are incompatible.
    Type '(watcher: (payload: string) => any) => Subscription' is not assignable to type '(watcher: (payload: number) => any) => Subscription'.
      Types of parameters 'watcher' and 'watcher' are incompatible.
        Types of parameters 'payload' and 'payload' are incompatible.
          Type 'string' is not assignable to type 'number'.
types.test.ts: Type 'Event<string>' is not assignable to type 'Event<number>'.
types.test.ts: Argument of type 'Effect<number, string, any>' is not assignable to parameter of type '(params: void) => unknown'.
  Types of parameters 'payload' and 'params' are incompatible.
    Type 'void' is not assignable to type 'number'.
types.test.ts: Type 'Effect<string, string, Error>' is not assignable to type 'Effect<number, number, Error>'.
  Types of property 'done' are incompatible.
    Type 'Event<{ params: string; result: string; }>' is not assignable to type 'Event<{ params: number; result: number; }>'.
      Types of property 'watch' are incompatible.
        Type '(watcher: (payload: { params: string; result: string; }) => any) => Subscription' is not assignable to type '(watcher: (payload: { params: number; result: number; }) => any) => Subscription'.
          Types of parameters 'watcher' and 'watcher' are incompatible.
            Types of parameters 'payload' and 'payload' are incompatible.
              Type '{ params: string; result: string; }' is not assignable to type '{ params: number; result: number; }'.
types.test.ts: Type 'Store<number>' is not assignable to type 'Store<string>'.
  Types of property 'getState' are incompatible.
    Type '() => number' is not assignable to type '() => string'.
      Type 'number' is not assignable to type 'string'.
types.test.ts: Type 'Event<number>' is not assignable to type 'Event<string>'.
  Types of property 'watch' are incompatible.
    Type '(watcher: (payload: number) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
      Types of parameters 'watcher' and 'watcher' are incompatible.
        Types of parameters 'payload' and 'payload' are incompatible.
          Type 'number' is not assignable to type 'string'.
types.test.ts: Type 'Event<void>' is not assignable to type 'Event<string>'.
  Types of property 'watch' are incompatible.
    Type '(watcher: (payload: void) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
      Types of parameters 'watcher' and 'watcher' are incompatible.
        Types of parameters 'payload' and 'payload' are incompatible.
          Type 'void' is not assignable to type 'string'.
types.test.ts: Type 'Store<string>' is not assignable to type 'Store<number>'.
  Types of property 'getState' are incompatible.
    Type '() => string' is not assignable to type '() => number'.
      Type 'string' is not assignable to type 'number'.
types.test.ts: Argument of type '234' is not assignable to parameter of type 'string | undefined'.
types.test.ts: Argument of type '{ foo: boolean; }' is not assignable to parameter of type 'string'.
types.test.ts: Argument of type '20' is not assignable to parameter of type 'string'.
types.test.ts: Argument of type '20' is not assignable to parameter of type 'string'.
types.test.ts: Type 'Event<string>' is not assignable to type 'Unit<number>'.
  Types of property '__' are incompatible.
    Type 'string' is not assignable to type 'number'.
types.test.ts: Type 'Event<string | number>' is not assignable to type 'Unit<string>'.
  Types of property '__' are incompatible.
    Type 'string | number' is not assignable to type 'string'.
      Type 'number' is not assignable to type 'string'.
types.test.ts: Argument of type '\\"\\"' is not assignable to parameter of type 'number'.
types.test.ts: Type 'number' is not assignable to type 'string'.
types.test.ts: Property 'unknownProp' does not exist on type '{ id: number; }'.
types.test.ts: Type 'string' is not assignable to type 'number'.
types.test.ts: Type 'number' does not satisfy the constraint 'object'.
types.test.ts: Argument of type '1' is not assignable to parameter of type '{ a: number; } | undefined'.
types.test.ts: Argument of type '{}' is not assignable to parameter of type '{ a: number; }'.
  Property 'a' is missing in type '{}' but required in type '{ a: number; }'.
useStoreMap.test.tsx: Tuple type 'readonly [number]' of length '1' has no element at index '1'.
useStoreMap.test.tsx: Type '[number, \\"username\\" | \\"email\\" | \\"bio\\"]' is not assignable to type '[number, number]'.
  Type '\\"username\\" | \\"email\\" | \\"bio\\"' is not assignable to type 'number'.
    Type '\\"username\\"' is not assignable to type 'number'.
useStoreMap.test.tsx: Element implicitly has an 'any' type because index expression is not of type 'number'.
"
`;
