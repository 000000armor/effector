// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Flow: json messages 1`] = `
"  src/types/types.test.js
   57 |             oneElement: list => list.length === 1,
   58 |           })
>  59 |           const split_result__nofpos__user_defined_1: Event<number> = emptyList
      |                                                                       ^^^^^^^^ 
      |  Cannot assign \`emptyList\` to \`split_result__nofpos__user_defined_1\` 
      |  because array type [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
   60 |           const split_result__nofpos__user_defined_2: null = oneElement
   61 |         }

   52 |       test('split result no false-positive', () => {
   53 |         {
>  54 |           const source: Event<string[]> = createEvent()
      |                               ^^^^^^^^ [1]
   55 |           const {emptyList, oneElement} = split(source, {
   56 |             emptyList: list => list.length === 0,

   57 |             oneElement: list => list.length === 1,
   58 |           })
>  59 |           const split_result__nofpos__user_defined_1: Event<number> = emptyList
      |                                                             ^^^^^^ [2]
   60 |           const split_result__nofpos__user_defined_2: null = oneElement
   61 |         }

  packages/effector/index.js.flow
   42 | |}
   43 | 
>  44 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   45 |   (payload: Payload): Payload;
   46 |   +kind: kind;

  

  src/types/types.test.js
   58 |           })
   59 |           const split_result__nofpos__user_defined_1: Event<number> = emptyList
>  60 |           const split_result__nofpos__user_defined_2: null = oneElement
      |                                                              ^^^^^^^^^ 
      |  Cannot assign \`oneElement\` to \`split_result__nofpos__user_defined_2\` 
      |  because \`Event\` [1] is incompatible with null [2].
      |  
   61 |         }
   62 |         {

  packages/effector/index.js.flow
  321 | ): $ObjMap<
  322 |   {...Obj, __: (payload: S) => boolean},
> 323 |   (h: (payload: S) => boolean) => Event<S>,
      |                                   ^^^^^^^^ [1]
  324 | >
  325 | declare export function restoreObject<

  src/types/types.test.js
   58 |           })
   59 |           const split_result__nofpos__user_defined_1: Event<number> = emptyList
>  60 |           const split_result__nofpos__user_defined_2: null = oneElement
      |                                                       ^^^^ [2]
   61 |         }
   62 |         {

  

  src/types/types.test.js
   66 |             oneElement: list => list.length === 1,
   67 |           })
>  68 |           const split_result__nofpos__defaults_1: Event<number> = __
      |                                                                   ^ 
      |  Cannot assign \`__\` to \`split_result__nofpos__defaults_1\` 
      |  because array type [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
   69 |         }
   70 |         {

   61 |         }
   62 |         {
>  63 |           const source: Event<string[]> = createEvent()
      |                               ^^^^^^^^ [1]
   64 |           const {__} = split(source, {
   65 |             emptyList: list => list.length === 0,

   66 |             oneElement: list => list.length === 1,
   67 |           })
>  68 |           const split_result__nofpos__defaults_1: Event<number> = __
      |                                                         ^^^^^^ [2]
   69 |         }
   70 |         {

  packages/effector/index.js.flow
   42 | |}
   43 | 
>  44 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   45 |   (payload: Payload): Payload;
   46 |   +kind: kind;

  

  src/types/types.test.js
   74 |             oneElement: list => list.length === 1,
   75 |           })
>  76 |           const split_result__nofpos__defaults_2: null = __
      |                                                          ^ 
      |  Cannot assign \`__\` to \`split_result__nofpos__defaults_2\` 
      |  because \`Event\` [1] is incompatible with null [2].
      |  
   77 |         }
   78 |       })

  packages/effector/index.js.flow
  321 | ): $ObjMap<
  322 |   {...Obj, __: (payload: S) => boolean},
> 323 |   (h: (payload: S) => boolean) => Event<S>,
      |                                   ^^^^^^^^ [1]
  324 | >
  325 | declare export function restoreObject<

  src/types/types.test.js
   74 |             oneElement: list => list.length === 1,
   75 |           })
>  76 |           const split_result__nofpos__defaults_2: null = __
      |                                                   ^^^^ [2]
   77 |         }
   78 |       })

  

  src/types/types.test.js
   82 |       const source: Event<string[]> = createEvent()
   83 |       split(source, {
>  84 |         wrongResult: list => null,
      |                              ^^^ 
      |  Cannot call \`split\` with object literal bound to \`cases\` 
      |  because null [1] is incompatible with boolean [2] in the return value of
      |  property \`wrongResult\`.
      |  
   85 |         wrongArg_1: (list: null) => true,
   86 |         wrongArg_2: (list: number[]) => true,

   82 |       const source: Event<string[]> = createEvent()
   83 |       split(source, {
>  84 |         wrongResult: list => null,
      |                              ^^^^ [1]
   85 |         wrongArg_1: (list: null) => true,
   86 |         wrongArg_2: (list: number[]) => true,

  packages/effector/index.js.flow
  313 |   S,
  314 |   Obj: {
> 315 |     +[name: string]: (payload: S) => boolean,
      |                                      ^^^^^^^ [2]
  316 |     ...,
  317 |   },

  

  src/types/types.test.js
   83 |       split(source, {
   84 |         wrongResult: list => null,
>  85 |         wrongArg_1: (list: null) => true,
      |                            ^^^ 
      |  Cannot call \`split\` with object literal bound to \`cases\` 
      |  because null [1] is incompatible with array type [2] in the first argument of
      |  property \`wrongArg_1\`.
      |  
   86 |         wrongArg_2: (list: number[]) => true,
   87 |       })

   83 |       split(source, {
   84 |         wrongResult: list => null,
>  85 |         wrongArg_1: (list: null) => true,
      |                            ^^^^ [1]
   86 |         wrongArg_2: (list: number[]) => true,
   87 |       })

   80 | 
   81 |     test('split arguments no false-positive', () => {
>  82 |       const source: Event<string[]> = createEvent()
      |                           ^^^^^^^^ [2]
   83 |       split(source, {
   84 |         wrongResult: list => null,

  

  src/types/types.test.js
   84 |         wrongResult: list => null,
   85 |         wrongArg_1: (list: null) => true,
>  86 |         wrongArg_2: (list: number[]) => true,
      |                            ^^^^^ 
      |  Cannot call \`split\` with object literal bound to \`cases\` 
      |  because number [1] is incompatible with string [2] in array element of the
      |  first argument of property \`wrongArg_2\`.
      |  
   87 |       })
   88 |     })

   84 |         wrongResult: list => null,
   85 |         wrongArg_1: (list: null) => true,
>  86 |         wrongArg_2: (list: number[]) => true,
      |                            ^^^^^^ [1]
   87 |       })
   88 |     })

   80 | 
   81 |     test('split arguments no false-positive', () => {
>  82 |       const source: Event<string[]> = createEvent()
      |                           ^^^^^^ [2]
   83 |       split(source, {
   84 |         wrongResult: list => null,

  

  src/types/types.test.js
   95 | 
   96 |       const sample_ee_check1: Event<number> = c
>  97 |       const sample_ee_check2: Event<string> = c
      |                                               ^ 
      |  Cannot assign \`c\` to \`sample_ee_check2\` 
      |  because number [1] is incompatible with string [2] in type argument
      |  \`Payload\` [3].
      |  
   98 |     })
   99 |     test('event by event with handler', () => {

   90 |   describe('sample', () => {
   91 |     test('event by event', () => {
>  92 |       const a = createEvent<number>()
      |                             ^^^^^^ [1]
   93 |       const b = createEvent<boolean>()
   94 |       const c = sample(a, b)

   95 | 
   96 |       const sample_ee_check1: Event<number> = c
>  97 |       const sample_ee_check2: Event<string> = c
      |                                     ^^^^^^ [2]
   98 |     })
   99 |     test('event by event with handler', () => {

  packages/effector/index.js.flow
   42 | |}
   43 | 
>  44 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   45 |   (payload: Payload): Payload;
   46 |   +kind: kind;

  

  src/types/types.test.js
  103 | 
  104 |       const sample_eeh_check1: Event<{a: string, b: boolean}> = c
> 105 |       const sample_eeh_check2: Event<string> = c
      |                                                ^ 
      |  Cannot assign \`c\` to \`sample_eeh_check2\` 
      |  because object type [1] is incompatible with string [2] in type argument
      |  \`Payload\` [3].
      |  
  106 |     })
  107 | 

  102 |       const c = sample(a, b, (a, b) => ({a, b}))
  103 | 
> 104 |       const sample_eeh_check1: Event<{a: string, b: boolean}> = c
      |                                      ^^^^^^^^^^^^^^^^^^^^^^^ [1]
  105 |       const sample_eeh_check2: Event<string> = c
  106 |     })

  103 | 
  104 |       const sample_eeh_check1: Event<{a: string, b: boolean}> = c
> 105 |       const sample_eeh_check2: Event<string> = c
      |                                      ^^^^^^ [2]
  106 |     })
  107 | 

  packages/effector/index.js.flow
   42 | |}
   43 | 
>  44 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   45 |   (payload: Payload): Payload;
   46 |   +kind: kind;

  

  src/types/types.test.js
  112 | 
  113 |       const sample_se_check1: Event<number> = e
> 114 |       const sample_se_check2: Event<string> = e
      |                                               ^ 
      |  Cannot assign \`e\` to \`sample_se_check2\` 
      |  because number [1] is incompatible with string [2] in type argument
      |  \`Payload\` [3].
      |  
  115 |     })
  116 |     test('store by event with handler', () => {

  111 |       const e = sample(d, b)
  112 | 
> 113 |       const sample_se_check1: Event<number> = e
      |                                     ^^^^^^ [1]
  114 |       const sample_se_check2: Event<string> = e
  115 |     })

  112 | 
  113 |       const sample_se_check1: Event<number> = e
> 114 |       const sample_se_check2: Event<string> = e
      |                                     ^^^^^^ [2]
  115 |     })
  116 |     test('store by event with handler', () => {

  packages/effector/index.js.flow
   42 | |}
   43 | 
>  44 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   45 |   (payload: Payload): Payload;
   46 |   +kind: kind;

  

  src/types/types.test.js
  120 | 
  121 |       const sample_seh_check1: Event<{a: string, b: boolean}> = e
> 122 |       const sample_seh_check2: Event<string> = e
      |                                                ^ 
      |  Cannot assign \`e\` to \`sample_seh_check2\` 
      |  because object type [1] is incompatible with string [2] in type argument
      |  \`Payload\` [3].
      |  
  123 |     })
  124 | 

  119 |       const e = sample(d, b, (a, b) => ({a, b}))
  120 | 
> 121 |       const sample_seh_check1: Event<{a: string, b: boolean}> = e
      |                                      ^^^^^^^^^^^^^^^^^^^^^^^ [1]
  122 |       const sample_seh_check2: Event<string> = e
  123 |     })

  120 | 
  121 |       const sample_seh_check1: Event<{a: string, b: boolean}> = e
> 122 |       const sample_seh_check2: Event<string> = e
      |                                      ^^^^^^ [2]
  123 |     })
  124 | 

  packages/effector/index.js.flow
   42 | |}
   43 | 
>  44 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   45 |   (payload: Payload): Payload;
   46 |   +kind: kind;

  

  src/types/types.test.js
  129 | 
  130 |       const sample_efe_check1: Event<string> = g
> 131 |       const sample_efe_check2: Event<number> = g
      |                                                ^ 
      |  Cannot assign \`g\` to \`sample_efe_check2\` 
      |  because string [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
  132 |     })
  133 |     test('effect by event with handler', () => {

  124 | 
  125 |     test('effect by event', () => {
> 126 |       const f = createEffect<string, any, any>()
      |                              ^^^^^^ [1]
  127 |       const b = createEvent<boolean>()
  128 |       const g = sample(f, b)

  129 | 
  130 |       const sample_efe_check1: Event<string> = g
> 131 |       const sample_efe_check2: Event<number> = g
      |                                      ^^^^^^ [2]
  132 |     })
  133 |     test('effect by event with handler', () => {

  packages/effector/index.js.flow
   42 | |}
   43 | 
>  44 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   45 |   (payload: Payload): Payload;
   46 |   +kind: kind;

  

  src/types/types.test.js
  137 | 
  138 |       const sample_efeh_check1: Event<{a: string, b: boolean}> = g
> 139 |       const sample_efeh_check2: Event<number> = g
      |                                                 ^ 
      |  Cannot assign \`g\` to \`sample_efeh_check2\` 
      |  because object type [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
  140 |     })
  141 | 

  136 |       const g = sample(f, b, (a, b) => ({a, b}))
  137 | 
> 138 |       const sample_efeh_check1: Event<{a: string, b: boolean}> = g
      |                                       ^^^^^^^^^^^^^^^^^^^^^^^ [1]
  139 |       const sample_efeh_check2: Event<number> = g
  140 |     })

  137 | 
  138 |       const sample_efeh_check1: Event<{a: string, b: boolean}> = g
> 139 |       const sample_efeh_check2: Event<number> = g
      |                                       ^^^^^^ [2]
  140 |     })
  141 | 

  packages/effector/index.js.flow
   42 | |}
   43 | 
>  44 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   45 |   (payload: Payload): Payload;
   46 |   +kind: kind;

  

  src/types/types.test.js
  146 | 
  147 |       const sample_ss_check1: Store<boolean> = c
> 148 |       const sample_ss_check2: Store<string> = c
      |                                               ^ 
      |  Cannot assign \`c\` to \`sample_ss_check2\` 
      |  because boolean [1] is incompatible with string [2] in type
      |  argument \`State\` [3].
      |  
  149 |     })
  150 |     test('store by store with handler', () => {

  145 |       const c = sample(a, b)
  146 | 
> 147 |       const sample_ss_check1: Store<boolean> = c
      |                                     ^^^^^^^ [1]
  148 |       const sample_ss_check2: Store<string> = c
  149 |     })

  146 | 
  147 |       const sample_ss_check1: Store<boolean> = c
> 148 |       const sample_ss_check2: Store<string> = c
      |                                     ^^^^^^ [2]
  149 |     })
  150 |     test('store by store with handler', () => {

  packages/effector/index.js.flow
  103 | }
  104 | 
> 105 | declare export class Store<State> implements Unit<State> {
      |                            ^^^^^ [3]
  106 |   +kind: kind;
  107 |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
  154 | 
  155 |       const sample_ssh_check1: Store<{a: string, b: boolean}> = c
> 156 |       const sample_ssh_check2: Store<string> = c
      |                                                ^ 
      |  Cannot assign \`c\` to \`sample_ssh_check2\` 
      |  because object type [1] is incompatible with string [2] in type
      |  argument \`State\` [3].
      |  
  157 |     })
  158 |     describe('sample(Store<T>):Store<T>', () => {

  153 |       const c = sample(a, b, (a, b) => ({a, b}))
  154 | 
> 155 |       const sample_ssh_check1: Store<{a: string, b: boolean}> = c
      |                                      ^^^^^^^^^^^^^^^^^^^^^^^ [1]
  156 |       const sample_ssh_check2: Store<string> = c
  157 |     })

  154 | 
  155 |       const sample_ssh_check1: Store<{a: string, b: boolean}> = c
> 156 |       const sample_ssh_check2: Store<string> = c
      |                                      ^^^^^^ [2]
  157 |     })
  158 |     describe('sample(Store<T>):Store<T>', () => {

  packages/effector/index.js.flow
  103 | }
  104 | 
> 105 | declare export class Store<State> implements Unit<State> {
      |                            ^^^^^ [3]
  106 |   +kind: kind;
  107 |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
  163 |       test('incorrect case', () => {
  164 |         const a = createStore('')
> 165 |         const sample_s_incorrect: Store<number> = sample(a)
      |                                                   ^^^^^^^^ 
      |  Cannot assign \`sample(...)\` to \`sample_s_incorrect\` 
      |  because string [1] is incompatible with number [2] in type argument \`State\` [3].
      |  
  166 |       })
  167 |       describe('edge case', () => {

  162 |       })
  163 |       test('incorrect case', () => {
> 164 |         const a = createStore('')
      |                               ^^ [1]
  165 |         const sample_s_incorrect: Store<number> = sample(a)
  166 |       })

  163 |       test('incorrect case', () => {
  164 |         const a = createStore('')
> 165 |         const sample_s_incorrect: Store<number> = sample(a)
      |                                         ^^^^^^ [2]
  166 |       })
  167 |       describe('edge case', () => {

  packages/effector/index.js.flow
  103 | }
  104 | 
> 105 | declare export class Store<State> implements Unit<State> {
      |                            ^^^^^ [3]
  106 |   +kind: kind;
  107 |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
  174 |           const a = createStore('')
  175 |           const clock = createEvent()
> 176 |           const sample_s_edge_incorrect: Event<number> = sample(a, clock)
      |                                                          ^^^^^^^^^^^^^^^ 
      |  Cannot assign \`sample(...)\` to \`sample_s_edge_incorrect\` 
      |  because string [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
  177 |         })
  178 |       })

  172 |         })
  173 |         test('incorrect case', () => {
> 174 |           const a = createStore('')
      |                                 ^^ [1]
  175 |           const clock = createEvent()
  176 |           const sample_s_edge_incorrect: Event<number> = sample(a, clock)

  174 |           const a = createStore('')
  175 |           const clock = createEvent()
> 176 |           const sample_s_edge_incorrect: Event<number> = sample(a, clock)
      |                                                ^^^^^^ [2]
  177 |         })
  178 |       })

  packages/effector/index.js.flow
   42 | |}
   43 | 
>  44 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   45 |   (payload: Payload): Payload;
   46 |   +kind: kind;

  

  src/types/types.test.js
  207 | 
  208 |     //const check1: Event<string> = computed
> 209 |     const event_map_check2: Event<number> = computed
      |                                             ^^^^^^^ 
      |  Cannot assign \`computed\` to \`event_map_check2\` 
      |  because string [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
  210 |     event(2)
  211 |     computed('')

  204 |   test('#map', () => {
  205 |     const event: Event<number> = createEvent()
> 206 |     const computed = event.map(() => 'foo')
      |                                      ^^^^^ [1]
  207 | 
  208 |     //const check1: Event<string> = computed

  207 | 
  208 |     //const check1: Event<string> = computed
> 209 |     const event_map_check2: Event<number> = computed
      |                                   ^^^^^^ [2]
  210 |     event(2)
  211 |     computed('')

  packages/effector/index.js.flow
   42 | |}
   43 | 
>  44 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   45 |   (payload: Payload): Payload;
   46 |   +kind: kind;

  

  src/types/types.test.js
  207 | 
  208 |     //const check1: Event<string> = computed
> 209 |     const event_map_check2: Event<number> = computed
      |                                             ^^^^^^^ 
      |  Cannot assign \`computed\` to \`event_map_check2\` 
      |  because string [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
  210 |     event(2)
  211 |     computed('')

  209 |     const event_map_check2: Event<number> = computed
  210 |     event(2)
> 211 |     computed('')
      |              ^^ [1]
  212 |   })
  213 |   test('#watch', () => {

  207 | 
  208 |     //const check1: Event<string> = computed
> 209 |     const event_map_check2: Event<number> = computed
      |                                   ^^^^^^ [2]
  210 |     event(2)
  211 |     computed('')

  packages/effector/index.js.flow
   42 | |}
   43 | 
>  44 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   45 |   (payload: Payload): Payload;
   46 |   +kind: kind;

  

  src/types/types.test.js
  233 |       const event: Event<number> = createEvent()
  234 |       const filteredEvent_error: Event<number> = event.filter(n => {
> 235 |         if (n % 2) return n.toString()
      |                           ^^^^^^^^^^^ 
      |  Cannot assign \`event.filter(...)\` to \`filteredEvent_error\` 
      |  because string [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
  236 |       })
  237 |     })

   [LIB] core.js
> 158 |     toString(radix?: number): string;
      |                               ^^^^^^ [1]

  src/types/types.test.js
  232 |     test('#filter incorrect', () => {
  233 |       const event: Event<number> = createEvent()
> 234 |       const filteredEvent_error: Event<number> = event.filter(n => {
      |                                        ^^^^^^ [2]
  235 |         if (n % 2) return n.toString()
  236 |       })

  packages/effector/index.js.flow
   42 | |}
   43 | 
>  44 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   45 |   (payload: Payload): Payload;
   46 |   +kind: kind;

  

  src/types/types.test.js
  295 |       test('no false-positive (should be type error)', () => {
  296 |         const nestedEffect: Effect<string, string> = createEffect()
> 297 |         const parentEffect: Effect<number, number> = createEffect(
      |                                                      ^^^^^^^^^^^^
> 298 |           'should not throw',
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 299 |           {
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 300 |             handler: nestedEffect,
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 301 |           },
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 302 |         )
      | ^^^^^^^^^ 
      |  Cannot assign \`createEffect(...)\` to \`parentEffect\` 
      |  because number [1] is incompatible with string [2] in type
      |  argument \`Params\` [3].
      |  
  303 |       })
  304 |     })

  295 |       test('no false-positive (should be type error)', () => {
  296 |         const nestedEffect: Effect<string, string> = createEffect()
> 297 |         const parentEffect: Effect<number, number> = createEffect(
      |                                    ^^^^^^ [1]
  298 |           'should not throw',
  299 |           {

  294 |     describe('with handler', () => {
  295 |       test('no false-positive (should be type error)', () => {
> 296 |         const nestedEffect: Effect<string, string> = createEffect()
      |                                    ^^^^^^ [2]
  297 |         const parentEffect: Effect<number, number> = createEffect(
  298 |           'should not throw',

  packages/effector/index.js.flow
   64 | }
   65 | 
>  66 | declare export class Effect<Params, Done, Fail = Error>
      |                             ^^^^^^ [3]
   67 |   implements Unit<Params> {
   68 |   (payload: Params): Promise<Done>;

  

  src/types/types.test.js
  295 |       test('no false-positive (should be type error)', () => {
  296 |         const nestedEffect: Effect<string, string> = createEffect()
> 297 |         const parentEffect: Effect<number, number> = createEffect(
      |                                                      ^^^^^^^^^^^^
> 298 |           'should not throw',
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 299 |           {
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 300 |             handler: nestedEffect,
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 301 |           },
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 302 |         )
      | ^^^^^^^^^ 
      |  Cannot assign \`createEffect(...)\` to \`parentEffect\` 
      |  because string [1] is incompatible with number [2] in type argument \`Done\` [3].
      |  
  303 |       })
  304 |     })

  294 |     describe('with handler', () => {
  295 |       test('no false-positive (should be type error)', () => {
> 296 |         const nestedEffect: Effect<string, string> = createEffect()
      |                                            ^^^^^^ [1]
  297 |         const parentEffect: Effect<number, number> = createEffect(
  298 |           'should not throw',

  295 |       test('no false-positive (should be type error)', () => {
  296 |         const nestedEffect: Effect<string, string> = createEffect()
> 297 |         const parentEffect: Effect<number, number> = createEffect(
      |                                            ^^^^^^ [2]
  298 |           'should not throw',
  299 |           {

  packages/effector/index.js.flow
   64 | }
   65 | 
>  66 | declare export class Effect<Params, Done, Fail = Error>
      |                                     ^^^^ [3]
   67 |   implements Unit<Params> {
   68 |   (payload: Params): Promise<Done>;

  

  src/types/types.test.js
  310 |   test('createStore', () => {
  311 |     const createStore_store1: Store<number> = createStore(0)
> 312 |     const createStore_store2: Store<string> = createStore(0)
      |                                                           ^ 
      |  Cannot assign \`createStore(...)\` to \`createStore_store2\` 
      |  because number [1] is incompatible with string [2] in type argument \`State\` [3].
      |  
  313 |   })
  314 |   test('createStoreObject', () => {

  310 |   test('createStore', () => {
  311 |     const createStore_store1: Store<number> = createStore(0)
> 312 |     const createStore_store2: Store<string> = createStore(0)
      |                                                           ^^ [1]
  313 |   })
  314 |   test('createStoreObject', () => {

  310 |   test('createStore', () => {
  311 |     const createStore_store1: Store<number> = createStore(0)
> 312 |     const createStore_store2: Store<string> = createStore(0)
      |                                     ^^^^^^ [2]
  313 |   })
  314 |   test('createStoreObject', () => {

  packages/effector/index.js.flow
  103 | }
  104 | 
> 105 | declare export class Store<State> implements Unit<State> {
      |                            ^^^^^ [3]
  106 |   +kind: kind;
  107 |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
  333 |         event: (n, x: number) => x,
  334 |       })
> 335 |       const createApi_check2: Event<string> = event
      |                                               ^^^^ 
      |  Cannot assign \`event\` to \`createApi_check2\` 
      |  because string [1] is incompatible with number [2] in type argument
      |  \`Payload\` [3].
      |  
  336 |     }
  337 |     {

  333 |         event: (n, x: number) => x,
  334 |       })
> 335 |       const createApi_check2: Event<string> = event
      |                                     ^^^^^^ [1]
  336 |     }
  337 |     {

  331 |     {
  332 |       const {event} = createApi(store, {
> 333 |         event: (n, x: number) => x,
      |                       ^^^^^^ [2]
  334 |       })
  335 |       const createApi_check2: Event<string> = event

  packages/effector/index.js.flow
   42 | |}
   43 | 
>  44 | declare export class Event<Payload> implements Unit<Payload> {
      |                            ^^^^^^^ [3]
   45 |   (payload: Payload): Payload;
   46 |   +kind: kind;

  

  src/types/types.test.js
  337 |     {
  338 |       const {event} = createApi(store, {
> 339 |         event: (n, x) => x,
      |                          ^ 
      |  Cannot call \`createApi\` with object literal bound to \`api\` 
      |  because string [1] is incompatible with number [2] in the return value of
      |  property \`event\`.
      |  
  340 |       })
  341 |       const createApi_check3: Event<string> = event

  339 |         event: (n, x) => x,
  340 |       })
> 341 |       const createApi_check3: Event<string> = event
      |                                     ^^^^^^ [1]
  342 |     }
  343 |   })

  322 |   })
  323 |   test('createApi', () => {
> 324 |     const store: Store<number> = createStore(0)
      |                        ^^^^^^ [2]
  325 |     {
  326 |       const {event} = createApi(store, {

  

  src/types/types.test.js
  395 |     const map_check1: Store<string> = computed
  396 | 
> 397 |     const map_check2: Store<number> = computed
      |                                       ^^^^^^^ 
      |  Cannot assign \`computed\` to \`map_check2\` 
      |  because string [1] is incompatible with number [2] in type argument \`State\` [3].
      |  
  398 |   })
  399 | 

  393 |     const computed = store.map(() => 'hello')
  394 | 
> 395 |     const map_check1: Store<string> = computed
      |                             ^^^^^^ [1]
  396 | 
  397 |     const map_check2: Store<number> = computed

  395 |     const map_check1: Store<string> = computed
  396 | 
> 397 |     const map_check2: Store<number> = computed
      |                             ^^^^^^ [2]
  398 |   })
  399 | 

  packages/effector/index.js.flow
  103 | }
  104 | 
> 105 | declare export class Store<State> implements Unit<State> {
      |                            ^^^^^ [3]
  106 |   +kind: kind;
  107 |   reset(...triggers: Array<Unit<any>>): this;

  

  src/types/types.test.js
  477 |     const domain = createDomain()
  478 |     const domain2 = createDomain('hello')
> 479 |     const domain3 = createDomain(234)
      |                                  ^^ 
      |  Cannot call \`createDomain\` with \`234\` bound to \`domainName\` 
      |  because number [1] is incompatible with string [2].
      |  
  480 |     const domain4 = createDomain({foo: true})
  481 |   })

  477 |     const domain = createDomain()
  478 |     const domain2 = createDomain('hello')
> 479 |     const domain3 = createDomain(234)
      |                                  ^^^ [1]
  480 |     const domain4 = createDomain({foo: true})
  481 |   })

  packages/effector/index.js.flow
  355 |   <S>(field: Store<S> | S) => Store<S>,
  356 | >
> 357 | declare export function createDomain(domainName?: string): Domain
      |                                                   ^^^^^^ [2]
  358 | 
  359 | declare export function sample<A>(config: {|

  

  src/types/types.test.js
  478 |     const domain2 = createDomain('hello')
  479 |     const domain3 = createDomain(234)
> 480 |     const domain4 = createDomain({foo: true})
      |                                  ^^^^^^^^^^ 
      |  Cannot call \`createDomain\` with object literal bound to \`domainName\` 
      |  because object literal [1] is incompatible with string [2].
      |  
  481 |   })
  482 | 

  478 |     const domain2 = createDomain('hello')
  479 |     const domain3 = createDomain(234)
> 480 |     const domain4 = createDomain({foo: true})
      |                                  ^^^^^^^^^^^ [1]
  481 |   })
  482 | 

  packages/effector/index.js.flow
  355 |   <S>(field: Store<S> | S) => Store<S>,
  356 | >
> 357 | declare export function createDomain(domainName?: string): Domain
      |                                                   ^^^^^^ [2]
  358 | 
  359 | declare export function sample<A>(config: {|

  

  src/types/types.test.js
  494 |       },
  495 |     })
> 496 |     effect2(20)
      |             ^ 
      |  Cannot call \`effect2\` with \`20\` bound to \`payload\` 
      |  because number [1] is incompatible with string [2].
      |  
  497 |     const effect3 = domain.effect('', {
  498 |       handler: effect1,

  494 |       },
  495 |     })
> 496 |     effect2(20)
      |             ^^ [1]
  497 |     const effect3 = domain.effect('', {
  498 |       handler: effect1,

  490 |     const effect1: Effect<string, number, Error> = domain.effect()
  491 |     const effect2 = domain.effect('', {
> 492 |       handler(params: string) {
      |                       ^^^^^^ [2]
  493 |         return 256
  494 |       },

  

  src/types/types.test.js
  498 |       handler: effect1,
  499 |     })
> 500 |     effect3(20)
      |             ^ 
      |  Cannot call \`effect3\` with \`20\` bound to \`payload\` 
      |  because number [1] is incompatible with string [2].
      |  
  501 |   })
  502 | 

  498 |       handler: effect1,
  499 |     })
> 500 |     effect3(20)
      |             ^^ [1]
  501 |   })
  502 | 

  488 |   test('#effect', () => {
  489 |     const domain = createDomain()
> 490 |     const effect1: Effect<string, number, Error> = domain.effect()
      |                           ^^^^^^ [2]
  491 |     const effect2 = domain.effect('', {
  492 |       handler(params: string) {

  

  src/types/types.test.js
  584 |       ],
  585 |     })
> 586 |     launch(foo, '')
      |                 ^ 
      |  Cannot call \`launch\` with empty string bound to \`payload\` 
      |  because string [1] is incompatible with number [2].
      |  
  587 |     launch(foo, 0)
  588 |     launch(customNode, 100)

  584 |       ],
  585 |     })
> 586 |     launch(foo, '')
      |                 ^^ [1]
  587 |     launch(foo, 0)
  588 |     launch(customNode, 100)

  565 | 
  566 |   test('launch', () => {
> 567 |     const foo = createEvent<number>()
      |                             ^^^^^^ [2]
  568 |     const customNode = createNode({
  569 |       scope: {max: 100, lastValue: -1, add: 10},

  

  src/types/types.test.js
  616 |       (initialProps: {id: number}) => {
  617 |         const createComponent_initialProps_check1: number = initialProps.id
> 618 |         const createComponent_initialProps_check2: string = initialProps.id
      |                                                             ^^^^^^^^^^^^^^ 
      |  Cannot assign \`initialProps.id\` to \`createComponent_initialProps_check2\` 
      |  because number [1] is incompatible with string [2].
      |  
  619 |         const createComponent_initialProps_check3: string =
  620 |           initialProps.unknownProp

  614 |     }>({})
  615 |     const InitialProps = createComponent(
> 616 |       (initialProps: {id: number}) => {
      |                           ^^^^^^ [1]
  617 |         const createComponent_initialProps_check1: number = initialProps.id
  618 |         const createComponent_initialProps_check2: string = initialProps.id

  616 |       (initialProps: {id: number}) => {
  617 |         const createComponent_initialProps_check1: number = initialProps.id
> 618 |         const createComponent_initialProps_check2: string = initialProps.id
      |                                                    ^^^^^^ [2]
  619 |         const createComponent_initialProps_check3: string =
  620 |           initialProps.unknownProp

  

  src/types/types.test.js
  618 |         const createComponent_initialProps_check2: string = initialProps.id
  619 |         const createComponent_initialProps_check3: string =
> 620 |           initialProps.unknownProp
      |                        ^^^^^^^^^^ 
      |  Cannot get \`initialProps.unknownProp\` 
      |  because property \`unknownProp\` is missing in object type [1].
      |  
  621 |         return list.map(list => list[initialProps.id] || {text: 'Loading...'})
  622 |       },

  614 |     }>({})
  615 |     const InitialProps = createComponent(
> 616 |       (initialProps: {id: number}) => {
      |                      ^^^^^^^^^^^^ [1]
  617 |         const createComponent_initialProps_check1: number = initialProps.id
  618 |         const createComponent_initialProps_check2: string = initialProps.id

  

  src/types/types.test.js
  623 |       (_, state) => {
  624 |         const createComponent_initialProps_check4: string = state.text
> 625 |         const createComponent_initialProps_check5: number = state.text
      |                                                             ^^^^^^^^^ 
      |  Cannot assign \`state.text\` to \`createComponent_initialProps_check5\` 
      |  because string [1] is incompatible with number [2].
      |  
  626 |         return null
  627 |       },

  610 |     const list = createStore<{
  611 |       [key: number]: {
> 612 |         text: string,
      |               ^^^^^^ [1]
  613 |       },
  614 |     }>({})

  623 |       (_, state) => {
  624 |         const createComponent_initialProps_check4: string = state.text
> 625 |         const createComponent_initialProps_check5: number = state.text
      |                                                    ^^^^^^ [2]
  626 |         return null
  627 |       },

  

  src/types/types.test.js
  630 | 
  631 |   test('createGate', () => {
> 632 |     const Foo = createGate<number>('foo')
      |                            ^^^^^ 
      |  Cannot call \`createGate\` 
      |  because number [1] is incompatible with object type [2] in type
      |  argument \`Props\`.
      |  
  633 |     const Bar = createGate<{a: number}>('bar')
  634 |     const Baz = createGate<number | null>('baz', null)

  630 | 
  631 |   test('createGate', () => {
> 632 |     const Foo = createGate<number>('foo')
      |                            ^^^^^^ [1]
  633 |     const Bar = createGate<{a: number}>('bar')
  634 |     const Baz = createGate<number | null>('baz', null)

  packages/effector-react/index.js.flow
   57 | declare export function useGate<Props>(Gate: Gate<Props>, props?: Props): void
   58 | 
>  59 | declare export function createGate<Props: {}>(name?: string): Gate<Props>
      |                                           ^^ [2]
   60 | declare export function createGate<Props>(
   61 |   name: string,

  

  src/types/types.test.js
  636 |     const Component = () => {
  637 |       useGate(Foo, 1)
> 638 |       useGate(Bar, 1)
      |                    ^ 
      |  Cannot call \`useGate\` with \`1\` bound to \`props\` 
      |  because number [1] is incompatible with object type [2].
      |  
  639 |       useGate(Bar, {a: 1})
  640 |       useGate(Bar, {})

  636 |     const Component = () => {
  637 |       useGate(Foo, 1)
> 638 |       useGate(Bar, 1)
      |                    ^^ [1]
  639 |       useGate(Bar, {a: 1})
  640 |       useGate(Bar, {})

  631 |   test('createGate', () => {
  632 |     const Foo = createGate<number>('foo')
> 633 |     const Bar = createGate<{a: number}>('bar')
      |                            ^^^^^^^^^^^ [2]
  634 |     const Baz = createGate<number | null>('baz', null)
  635 | 

  "
`;

exports[`TypeScript: rejected 1`] = `
"Command failed: npx tsc -p src/types

types.test.ts(59,17): Type 'Event<string[]>' is not assignable to type 'Event<number>'.
  Type 'string[]' is not assignable to type 'number'.
types.test.ts(60,17): Type 'Event<string[]>' is not assignable to type 'null'.
types.test.ts(68,17): Type 'Event<string[]>' is not assignable to type 'Event<number>'.
types.test.ts(76,17): Type 'Event<string[]>' is not assignable to type 'null'.
types.test.ts(84,30): Type 'null' is not assignable to type 'boolean'.
types.test.ts(85,9): Type '(list: null) => true' is not assignable to type '(payload: string[]) => boolean'.
  Types of parameters 'list' and 'payload' are incompatible.
    Type 'string[]' is not assignable to type 'null'.
types.test.ts(86,9): Type '(list: number[]) => true' is not assignable to type '(payload: string[]) => boolean'.
  Types of parameters 'list' and 'payload' are incompatible.
    Type 'string[]' is not assignable to type 'number[]'.
      Type 'string' is not assignable to type 'number'.
types.test.ts(97,13): Type 'Event<number>' is not assignable to type 'Event<string>'.
types.test.ts(105,13): Type 'Event<{ a: string; b: boolean; }>' is not assignable to type 'Event<string>'.
  Type '{ a: string; b: boolean; }' is not assignable to type 'string'.
types.test.ts(114,13): Type 'Event<number>' is not assignable to type 'Event<string>'.
types.test.ts(122,13): Type 'Event<{ a: string; b: boolean; }>' is not assignable to type 'Event<string>'.
  Type '{ a: string; b: boolean; }' is not assignable to type 'string'.
types.test.ts(131,13): Type 'Event<string>' is not assignable to type 'Event<number>'.
types.test.ts(139,13): Type 'Event<{ a: string; b: boolean; }>' is not assignable to type 'Event<number>'.
  Type '{ a: string; b: boolean; }' is not assignable to type 'number'.
types.test.ts(148,13): Type 'Store<boolean>' is not assignable to type 'Store<string>'.
  Type 'boolean' is not assignable to type 'string'.
types.test.ts(156,13): Type 'Store<{ a: string; b: boolean; }>' is not assignable to type 'Store<string>'.
  Type '{ a: string; b: boolean; }' is not assignable to type 'string'.
types.test.ts(165,15): Type 'Store<string>' is not assignable to type 'Store<number>'.
types.test.ts(176,17): Type 'Event<string>' is not assignable to type 'Event<number>'.
types.test.ts(209,11): Type 'Event<string>' is not assignable to type 'Event<number>'.
  Type 'string' is not assignable to type 'number'.
types.test.ts(234,13): Type 'Event<string>' is not assignable to type 'Event<number>'.
types.test.ts(278,17): Argument of type 'Effect<number, string, any>' is not assignable to parameter of type '(params: {}) => {} | Promise<{}>'.
  Types of parameters 'payload' and 'params' are incompatible.
    Type '{}' is not assignable to type 'number'.
types.test.ts(285,7): Expected 1 arguments, but got 0.
types.test.ts(289,43): Argument of type '() => void' is not assignable to parameter of type '(params: {}) => {} | Promise<{}>'.
  Type 'void' is not assignable to type '{} | Promise<{}>'.
types.test.ts(297,15): Type 'Effect<string, string, Error>' is not assignable to type 'Effect<number, number, Error>'.
  Type 'string' is not assignable to type 'number'.
types.test.ts(312,11): Type 'Store<number>' is not assignable to type 'Store<string>'.
  Type 'number' is not assignable to type 'string'.
types.test.ts(335,13): Type 'Event<number>' is not assignable to type 'Event<string>'.
  Type 'number' is not assignable to type 'string'.
types.test.ts(341,13): Type 'Event<void>' is not assignable to type 'Event<string>'.
  Type 'void' is not assignable to type 'string'.
types.test.ts(397,11): Type 'Store<string>' is not assignable to type 'Store<number>'.
  Type 'string' is not assignable to type 'number'.
types.test.ts(479,34): Argument of type '234' is not assignable to parameter of type 'string | undefined'.
types.test.ts(480,34): Argument of type '{ foo: boolean; }' is not assignable to parameter of type 'string'.
types.test.ts(496,13): Argument of type '20' is not assignable to parameter of type 'string'.
types.test.ts(500,13): Argument of type '20' is not assignable to parameter of type 'string'.
types.test.ts(586,17): Argument of type '\\"\\"' is not assignable to parameter of type 'number'.
types.test.ts(618,15): Type 'number' is not assignable to type 'string'.
types.test.ts(620,24): Property 'unknownProp' does not exist on type '{ id: number; }'.
types.test.ts(625,15): Type 'string' is not assignable to type 'number'.
types.test.ts(632,28): Type 'number' does not satisfy the constraint 'object'.
types.test.ts(638,20): Argument of type '1' is not assignable to parameter of type '{ a: number; } | undefined'.
types.test.ts(640,20): Argument of type '{}' is not assignable to parameter of type '{ a: number; }'.
  Property 'a' is missing in type '{}' but required in type '{ a: number; }'.
useStoreMap.test.tsx(50,28): Tuple type 'readonly [number]' of length '1' has no element at index '1'.
useStoreMap.test.tsx(71,11): Type '[number, \\"username\\" | \\"email\\" | \\"bio\\"]' is not assignable to type '[number, number]'.
  Type '\\"username\\" | \\"email\\" | \\"bio\\"' is not assignable to type 'number'.
    Type '\\"username\\"' is not assignable to type 'number'.
useStoreMap.test.tsx(83,43): Element implicitly has an 'any' type because index expression is not of type 'number'.
"
`;
