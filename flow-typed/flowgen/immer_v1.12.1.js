/**
 * This is an autogenerated libdef stub for:
 *
 *   'immer'
 *
 * Fill this stub out by fixing all the errors.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */
declare module "immer" {
  /**
   * Object types that should never be mapped
   */
  declare type AtomicObject =
    | Function
    | Map<any, any>
    | WeakMap<any, any>
    | Set<any>
    | WeakSet<any>
    | Promise<any>
    | Date
    | RegExp
    | Boolean
    | Number
    | String;
  declare type ArrayMethod = Exclude<$Keys<[]>, number>;
  declare type Indices<T> = Exclude<$Keys<T>, ArrayMethod>;
  declare export type DraftArray<T: $ReadOnlyArray<any>> = Array<
    $ElementType<
      $ObjMapi<{ [k: Indices<T>]: any }, <P>(P) => Draft<$ElementType<T, P>>>,
      Indices<T>
    >
  >;
  declare export type DraftTuple<T: $ReadOnlyArray<any>> = $ObjMapi<
    T,
    <P>(P) => "There was Conditional Type, use $Call utility type"
  >;
  declare export type Draft<T> =
    "There was Conditional Type, use $Call utility type";
  declare export interface Patch {
    op: "replace" | "remove" | "add";
    path: (string | number)[];
    value?: any;
  }
  declare export type PatchListener = (
    patches: Patch[],
    inversePatches: Patch[]
  ) => void;
  declare type IsVoidLike<T> =
    "There was Conditional Type, use $Call utility type";

  /**
   * Converts `nothing` into `undefined`
   */
  declare type FromNothing<T> =
    "There was Conditional Type, use $Call utility type";

  /**
   * The inferred return type of `produce`
   */
  declare export type Produced<T, Return> =
    "There was Conditional Type, use $Call utility type";
  declare type ImmutableTuple<T: $ReadOnlyArray<any>> = $ObjMapi<
    T,
    <P>(P) => Immutable<$ElementType<T, P>>
  >;

  /**
   * Convert a mutable type into a readonly type
   */
  declare export type Immutable<T> =
    "There was Conditional Type, use $Call utility type";
  declare export interface IProduce {
    /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     * @param {any} base - the initial state
     * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */
    <T, Return, D>(
      base: T,
      recipe: (draft: D) => Return,
      listener?: PatchListener
    ): Produced<T, Return>;

    /**
     * Curried producer with a default value
     */
    <T, Rest: any[], Return, D>(
      recipe: (draft: D, ...rest: Rest) => Return,
      defaultBase: T
    ): (base: Immutable<D> | void, ...rest: Rest) => Produced<D, Return>;

    /**
     * Curried producer with no default value
     */
    <T, Rest: any[], Return>(
      recipe: (draft: Draft<T>, ...rest: Rest) => Return
    ): (base: Immutable<T>, ...rest: Rest) => Produced<T, Return>;
  }
  declare export var produce: IProduce;
  declare export default typeof produce;

  /**
   * Use a class type for `nothing` so its type is unique
   */
  declare class Nothing {}

  /**
   * The sentinel value returned by producers to replace the draft with undefined.
   */
  declare export var nothing: Nothing;

  /**
   * To let Immer treat your class instances as plain immutable objects
   * (albeit with a custom prototype), you must define either an instance property
   * or a static property on each of your custom classes.
   *
   * Otherwise, your class instance will never be drafted, which means it won't be
   * safe to mutate in a produce callback.
   */
  declare export var immerable: "NO PRINT IMPLEMENTED: TypeOperator UniqueKeyword";

  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is disabled in production.
   */
  declare export function setAutoFreeze(autoFreeze: boolean): void;

  /**
   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
   * always faster than using ES5 proxies.
   *
   * By default, feature detection is used, so calling this is rarely necessary.
   */
  declare export function setUseProxies(useProxies: boolean): void;

  /**
   * Apply an array of Immer patches to the first argument.
   *
   * This function is a producer, which means copy-on-write is in effect.
   */
  declare export function applyPatches<S>(base: S, patches: Patch[]): S;

  /**
   * Get the underlying object that is represented by the given draft
   */
  declare export function original<T>(value: T): T | void;

  /**
   * Returns true if the given value is an Immer draft
   */
  declare export function isDraft(value: any): boolean;

  /**
   * Returns true if the given value can be drafted by Immer
   */
  declare export function isDraftable(value: any): boolean;

  declare export class Immer {
    constructor(config: {
      useProxies?: boolean,
      autoFreeze?: boolean,
      onAssign?: (
        state: ImmerState,
        prop: string | number,
        value: mixed
      ) => void,
      onDelete?: (state: ImmerState, prop: string | number) => void,
      onCopy?: (state: ImmerState) => void
    }): this;

    /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     * @param {any} base - the initial state
     * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */
    produce: IProduce;

    /**
     * When true, `produce` will freeze the copies it creates.
     */
    autoFreeze: boolean;

    /**
     * When true, drafts are ES2015 proxies.
     */
    useProxies: boolean;

    /**
     * Pass true to automatically freeze all copies created by Immer.
     *
     * By default, auto-freezing is disabled in production.
     */
    setAutoFreeze(autoFreeze: boolean): void;

    /**
     * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
     * always faster than using ES5 proxies.
     *
     * By default, feature detection is used, so calling this is rarely necessary.
     */
    setUseProxies(useProxies: boolean): void;
  }
  declare export interface ImmerState<T> {
    parent?: ImmerState;
    base: T;
    copy: T;
    assigned: {
      [prop: string]: boolean,
      [index: number]: boolean
    };
  }
}

