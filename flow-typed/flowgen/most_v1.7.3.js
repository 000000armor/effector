/**
 * This is an autogenerated libdef stub for:
 *
 *   'most'
 *
 * Fill this stub out by fixing all the errors.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */
declare module "most" {
  declare type SeedValue<S, V> = {
    seed: S,
    value: V
  };
  declare type TimeValue<V> = {
    time: number,
    value: V
  };
  declare interface Generator<A, B, C> {}
  declare interface Iterable<A> {
    undefined(): IterableIterator<A>;
  }
  declare type CreateGenerator<A> = (
    ...args: Array<any>
  ) => Generator<A | Promise<A>, any, any>;
  declare export interface Sink<A> {
    event(time: number, value: A): void;
    end(time: number, value?: A): void;
    error(time: number, err: Error): void;
  }
  declare export interface Task {
    run(time: number): void;
    error(time: number, e: Error): void;
    dispose(): void;
  }
  declare export interface ScheduledTask {
    task: Task;
    run(): void;
    error(err: Error): void;
    dispose(): void;
  }
  declare export interface Scheduler {
    now(): number;
    asap(task: Task): ScheduledTask;
    delay(delay: number, task: Task): ScheduledTask;
    periodic(period: number, task: Task): ScheduledTask;
    schedule(delay: number, period: number, task: Task): ScheduledTask;
    cancel(task: Task): void;
    cancelAll(predicate: (task: Task) => boolean): void;
  }
  declare export interface Disposable<A> {
    dispose(): void | Promise<A>;
  }
  declare export interface Source<A> {
    run(sink: Sink<A>, scheduler: Scheduler): Disposable<A>;
  }
  declare export interface Observable<A> {
    subscribe(subscriber: Subscriber<A>): Subscription<A>;
  }
  declare export interface Subscriber<A> {
    next(value: A): void;
    error(err: Error): void;
    complete(value?: A): void;
  }
  declare export interface Subscription<A> {
    unsubscribe(): void;
  }
  declare export class Stream<A> {
    source: Source<A>;
    constructor(source: Source<A>): this;
  }
  declare interface DisposeFn {
    (): void | Promise<any>;
  }
  declare export function just<A>(a: A): Stream<A>;

  declare export function of<A>(a: A): Stream<A>;

  declare export function empty(): Stream<any>;

  declare export function never(): Stream<any>;

  declare export function from<A>(
    as: ArrayLike<A> | Iterable<A> | Observable<A>
  ): Stream<A>;

  declare export function periodic<A>(period: number, a?: A): Stream<A>;

  declare export function fromEvent<T: Event>(
    event: string,
    target: any,
    useCapture?: boolean
  ): Stream<T>;

  declare export function fromEvent<T>(event: string, target: any): Stream<T>;

  declare export function unfold<A, B, S>(
    f: (seed: S) => SeedValue<S, B | Promise<B>>,
    seed: S
  ): Stream<B>;

  declare export function iterate<A>(
    f: (a: A) => A | Promise<A>,
    a: A
  ): Stream<A>;

  declare export function generate<A>(
    g: CreateGenerator<A>,
    ...args: Array<any>
  ): Stream<A>;

  declare export function reduce<A, B>(
    f: (b: B, a: A) => B,
    b: B,
    s: Stream<A>
  ): Promise<B>;

  declare export function observe<A>(
    f: (a: A) => any,
    s: Stream<A>
  ): Promise<any>;

  declare export function forEach<A>(
    f: (a: A) => any,
    s: Stream<A>
  ): Promise<any>;

  declare export function drain<A>(s: Stream<A>): Promise<any>;

  declare export function subscribe<A>(
    subscriber: Subscriber<A>,
    s: Stream<A>
  ): Subscription<A>;

  declare export function constant<A, B>(b: B, s: Stream<A>): Stream<B>;

  declare export function map<A, B>(f: (a: A) => B, s: Stream<A>): Stream<B>;

  declare export function tap<A>(f: (a: A) => any, s: Stream<A>): Stream<A>;

  declare export function ap<A, B>(
    fs: Stream<(a: A) => B>,
    as: Stream<A>
  ): Stream<B>;

  declare export function chain<A, B>(
    f: (a: A) => Stream<B>,
    s: Stream<A>
  ): Stream<B>;

  declare export function flatMap<A, B>(
    f: (a: A) => Stream<B>,
    s: Stream<A>
  ): Stream<B>;

  declare export function join<A>(s: Stream<Stream<A>>): Stream<A>;

  declare export function switchLatest<A>(s: Stream<Stream<A>>): Stream<A>;

  declare export function continueWith<A>(
    f: (a: any) => Stream<A>,
    s: Stream<A>
  ): Stream<A>;

  declare export function concatMap<A, B>(
    f: (a: A) => Stream<B>,
    s: Stream<A>
  ): Stream<B>;

  declare export function mergeConcurrently<A>(
    concurrency: number,
    s: Stream<Stream<A>>
  ): Stream<A>;

  declare export function merge<A>(...ss: Array<Stream<A>>): Stream<A>;

  declare export function mergeArray<A>(streams: Array<Stream<A>>): Stream<A>;

  declare export function combine<A, B, R>(
    fn: (a: A, b: B) => R,
    a: Stream<A>,
    b: Stream<B>
  ): Stream<R>;

  declare export function combine<A, B, C, R>(
    fn: (a: A, b: B, c: C) => R,
    a: Stream<A>,
    b: Stream<B>,
    c: Stream<C>
  ): Stream<R>;

  declare export function combine<A, B, C, D, R>(
    fn: (a: A, b: B, c: C, d: D) => R,
    a: Stream<A>,
    b: Stream<B>,
    c: Stream<C>,
    d: Stream<D>
  ): Stream<R>;

  declare export function combine<A, B, C, D, E, R>(
    fn: (a: A, b: B, c: C, d: D, e: E) => R,
    a: Stream<A>,
    b: Stream<B>,
    c: Stream<C>,
    d: Stream<D>,
    e: Stream<E>
  ): Stream<R>;

  declare export function combineArray<A, B, R>(
    fn: (a: A, b: B) => R,
    streams: [Stream<A>, Stream<B>]
  ): Stream<R>;

  declare export function combineArray<A, B, C, R>(
    fn: (a: A, b: B, c: C) => R,
    streams: [Stream<A>, Stream<B>, Stream<C>]
  ): Stream<R>;

  declare export function combineArray<A, B, C, D, R>(
    fn: (a: A, b: B, c: C, d: D) => R,
    streams: [Stream<A>, Stream<B>, Stream<C>, Stream<D>]
  ): Stream<R>;

  declare export function combineArray<A, B, C, D, E, R>(
    fn: (a: A, b: B, c: C, d: D, e: E) => R,
    streams: [Stream<A>, Stream<B>, Stream<C>, Stream<D>, Stream<E>]
  ): Stream<R>;

  declare export function combineArray<V, R>(
    fn: (...items: V[]) => R,
    items: Stream<V>[]
  ): Stream<R>;

  declare export function scan<A, B>(
    f: (b: B, a: A) => B,
    b: B,
    s: Stream<A>
  ): Stream<B>;

  declare export function loop<A, B, S>(
    f: (seed: S, a: A) => SeedValue<S, B>,
    seed: S,
    s: Stream<A>
  ): Stream<B>;

  declare export function concat<A>(s1: Stream<A>, s2: Stream<A>): Stream<A>;

  declare export function startWith<A>(a: A, s: Stream<A>): Stream<A>;

  declare export function filter<A, B: A>(
    p: (val: A) => boolean,
    s: Stream<A>
  ): Stream<B>;

  declare export function filter<A>(
    p: (a: A) => boolean,
    s: Stream<A>
  ): Stream<A>;

  declare export function skipRepeats<A>(s: Stream<A>): Stream<A>;

  declare export function skipRepeatsWith<A>(
    eq: (a1: A, a2: A) => boolean,
    s: Stream<A>
  ): Stream<A>;

  declare export function take<A>(n: number, s: Stream<A>): Stream<A>;

  declare export function skip<A>(n: number, s: Stream<A>): Stream<A>;

  declare export function takeWhile<A>(
    p: (a: A) => boolean,
    s: Stream<A>
  ): Stream<A>;

  declare export function skipWhile<A>(
    p: (a: A) => boolean,
    s: Stream<A>
  ): Stream<A>;

  declare export function skipAfter<A>(
    p: (a: A) => boolean,
    s: Stream<A>
  ): Stream<A>;

  declare export function slice<A>(
    start: number,
    end: number,
    s: Stream<A>
  ): Stream<A>;

  declare export function until<A>(
    signal: Stream<any>,
    s: Stream<A>
  ): Stream<A>;

  declare export function takeUntil<A>(
    signal: Stream<any>,
    s: Stream<A>
  ): Stream<A>;

  declare export function since<A>(
    signal: Stream<any>,
    s: Stream<A>
  ): Stream<A>;

  declare export function skipUntil<A>(
    signal: Stream<any>,
    s: Stream<A>
  ): Stream<A>;

  declare export function during<A>(
    timeWindow: Stream<Stream<any>>,
    s: Stream<A>
  ): Stream<A>;

  declare export function throttle<A>(period: number, s: Stream<A>): Stream<A>;

  declare export function debounce<A>(period: number, s: Stream<A>): Stream<A>;

  declare export function timestamp<A>(s: Stream<A>): Stream<TimeValue<A>>;

  declare export function delay<A>(dt: number, s: Stream<A>): Stream<A>;

  declare export function fromPromise<A>(p: Promise<A>): Stream<A>;

  declare export function await<A>(s: Stream<Promise<A>>): Stream<A>;

  declare export function awaitPromises<A>(s: Stream<Promise<A>>): Stream<A>;

  declare export function sample<A, B, R>(
    fn: (a: A, b: B) => R,
    sampler: Stream<any>,
    a: Stream<A>,
    b: Stream<B>
  ): Stream<R>;

  declare export function sample<A, B, C, R>(
    fn: (a: A, b: B, c: C) => R,
    sampler: Stream<any>,
    a: Stream<A>,
    b: Stream<B>,
    c: Stream<C>
  ): Stream<R>;

  declare export function sample<A, B, C, D, R>(
    fn: (a: A, b: B, c: C, d: D) => R,
    sampler: Stream<any>,
    a: Stream<A>,
    b: Stream<B>,
    c: Stream<C>,
    d: Stream<D>
  ): Stream<R>;

  declare export function sample<A, B, C, D, E, R>(
    fn: (a: A, b: B, c: C, d: D, e: E) => R,
    sampler: Stream<any>,
    a: Stream<A>,
    b: Stream<B>,
    c: Stream<C>,
    d: Stream<D>,
    e: Stream<E>
  ): Stream<R>;

  declare export function sampleWith<A>(
    sampler: Stream<any>,
    s: Stream<A>
  ): Stream<A>;

  declare export function zip<A, B, R>(
    fn: (a: A, b: B) => R,
    a: Stream<A>,
    b: Stream<B>
  ): Stream<R>;

  declare export function zip<A, B, C, R>(
    fn: (a: A, b: B, c: C) => R,
    a: Stream<A>,
    b: Stream<B>,
    c: Stream<C>
  ): Stream<R>;

  declare export function zip<A, B, C, D, R>(
    fn: (a: A, b: B, c: C, d: D) => R,
    a: Stream<A>,
    b: Stream<B>,
    c: Stream<C>,
    d: Stream<D>
  ): Stream<R>;

  declare export function zip<A, B, C, D, E, R>(
    fn: (a: A, b: B, c: C, d: D, e: E) => R,
    a: Stream<A>,
    b: Stream<B>,
    c: Stream<C>,
    d: Stream<D>,
    e: Stream<E>
  ): Stream<R>;

  declare export function recoverWith<A, B>(
    p: (a: B) => Stream<A>,
    s: Stream<A>
  ): Stream<A>;

  declare export function throwError(e: Error): Stream<any>;

  declare export function multicast<A>(s: Stream<A>): Stream<A>;

  declare var defaultScheduler: Scheduler;
  declare export { defaultScheduler };

  declare export class PropagateTask<T> mixins Task {
    _run: (time: number, value: T, sink: Sink<T>) => any;
    value: T;
    sink: Sink<T>;
    active: boolean;
    constructor(
      run: (time: number, value: T, sink: Sink<T>) => any,
      value: T,
      sink: Sink<T>
    ): this;
    static event<T>(value: T, sink: Sink<T>): PropagateTask<T>;
    static error(error: Error, sink: Sink<any>): PropagateTask<any>;
    static end<T>(value: T, sink: Sink<T>): PropagateTask<T>;
    run(time: number): void;
    error(time: number, e: Error): void;
    dispose(): void;
  }
}

