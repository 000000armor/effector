/**
 * This is an autogenerated libdef stub for:
 *
 *   'jest'
 *
 * Fill this stub out by fixing all the errors.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */
declare module "jest" {
  declare var beforeAll: jest$jest$Lifecycle;
  declare var beforeEach: jest$jest$Lifecycle;
  declare var afterAll: jest$jest$Lifecycle;
  declare var afterEach: jest$jest$Lifecycle;
  declare var describe: jest$jest$Describe;
  declare var fdescribe: jest$jest$Describe;
  declare var xdescribe: jest$jest$Describe;
  declare var it: jest$jest$It;
  declare var fit: jest$jest$It;
  declare var xit: jest$jest$It;
  declare var test: jest$jest$It;
  declare var xtest: jest$jest$It;
  declare var expect: jest$jest$Expect;
  declare type ArgsType<T> =
    "There was Conditional Type, use $Call utility type";
  declare interface NodeRequire {
    /**
     * Returns the actual module instead of a mock, bypassing all checks on
     * whether the module should receive a mock implementation or not.
     * @deprecated Use `jest.requireActual` instead.
     */
    requireActual(moduleName: string): any;

    /**
     * Returns a mock module instead of the actual module, bypassing all checks
     * on whether the module should be required normally or not.
     * @deprecated Use `jest.requireMock`instead.
     */
    requireMock(moduleName: string): any;
  }

  declare var npm$namespace$jest: {
    addMatchers: typeof jest$addMatchers,
    autoMockOff: typeof jest$autoMockOff,
    autoMockOn: typeof jest$autoMockOn,
    clearAllMocks: typeof jest$clearAllMocks,
    resetAllMocks: typeof jest$resetAllMocks,
    restoreAllMocks: typeof jest$restoreAllMocks,
    clearAllTimers: typeof jest$clearAllTimers,
    deepUnmock: typeof jest$deepUnmock,
    disableAutomock: typeof jest$disableAutomock,
    doMock: typeof jest$doMock,
    dontMock: typeof jest$dontMock,
    enableAutomock: typeof jest$enableAutomock,
    fn: typeof jest$fn,
    genMockFromModule: typeof jest$genMockFromModule,
    isMockFunction: typeof jest$isMockFunction,
    mock: typeof jest$mock,
    requireActual: typeof jest$requireActual,
    requireMock: typeof jest$requireMock,
    resetModuleRegistry: typeof jest$resetModuleRegistry,
    resetModules: typeof jest$resetModules,
    runAllImmediates: typeof jest$runAllImmediates,
    runAllTicks: typeof jest$runAllTicks,
    runAllTimers: typeof jest$runAllTimers,
    runOnlyPendingTimers: typeof jest$runOnlyPendingTimers,
    runTimersToTime: typeof jest$runTimersToTime,
    advanceTimersByTime: typeof jest$advanceTimersByTime,
    setMock: typeof jest$setMock,
    setTimeout: typeof jest$setTimeout,
    spyOn: typeof jest$spyOn,
    unmock: typeof jest$unmock,
    useFakeTimers: typeof jest$useFakeTimers,
    useRealTimers: typeof jest$useRealTimers
  };

  /**
   * Provides a way to add Jasmine-compatible matchers into your Jest context.
   */
  declare function jest$addMatchers(
    matchers: jasmine$jasmine$CustomMatcherFactories
  ): typeof jest;

  /**
   * Disables automatic mocking in the module loader.
   */
  declare function jest$autoMockOff(): typeof jest;

  /**
   * Enables automatic mocking in the module loader.
   */
  declare function jest$autoMockOn(): typeof jest;

  /**
   * Clears the mock.calls and mock.instances properties of all mocks.
   * Equivalent to calling .mockClear() on every mocked function.
   */
  declare function jest$clearAllMocks(): typeof jest;

  /**
   * Resets the state of all mocks.
   * Equivalent to calling .mockReset() on every mocked function.
   */
  declare function jest$resetAllMocks(): typeof jest;

  /**
   * available since Jest 21.1.0
   * Restores all mocks back to their original value.
   * Equivalent to calling .mockRestore on every mocked function.
   * Beware that jest.restoreAllMocks() only works when mock was created with
   * jest.spyOn; other mocks will require you to manually restore them.
   */
  declare function jest$restoreAllMocks(): typeof jest;

  /**
   * Removes any pending timers from the timer system. If any timers have
   * been scheduled, they will be cleared and will never have the opportunity
   * to execute in the future.
   */
  declare function jest$clearAllTimers(): typeof jest;

  /**
   * Indicates that the module system should never return a mocked version
   * of the specified module, including all of the specificied module's dependencies.
   */
  declare function jest$deepUnmock(moduleName: string): typeof jest;

  /**
   * Disables automatic mocking in the module loader.
   */
  declare function jest$disableAutomock(): typeof jest;

  /**
   * Mocks a module with an auto-mocked version when it is being required.
   */
  declare function jest$doMock(
    moduleName: string,
    factory?: any,
    options?: jest$MockOptions
  ): typeof jest;

  /**
   * Indicates that the module system should never return a mocked version
   * of the specified module from require() (e.g. that it should always return the real module).
   */
  declare function jest$dontMock(moduleName: string): typeof jest;

  /**
   * Enables automatic mocking in the module loader.
   */
  declare function jest$enableAutomock(): typeof jest;

  /**
   * Creates a mock function. Optionally takes a mock implementation.
   */
  declare function jest$fn(): jest$Mock;

  /**
   * Creates a mock function. Optionally takes a mock implementation.
   */
  declare function jest$fn<T, Y: any[]>(
    implementation: (...args: Y) => T
  ): jest$Mock<T, Y>;

  /**
   * Use the automatic mocking system to generate a mocked version of the given module.
   */
  declare function jest$genMockFromModule<T>(moduleName: string): T;

  /**
   * Returns whether the given function is a mock function.
   */
  declare function jest$isMockFunction(jest$fn: any): boolean;

  /**
   * Mocks a module with an auto-mocked version when it is being required.
   */
  declare function jest$mock(
    moduleName: string,
    factory?: any,
    options?: jest$MockOptions
  ): typeof jest;

  /**
   * Returns the actual module instead of a mock, bypassing all checks on
   * whether the module should receive a mock implementation or not.
   */
  declare function jest$requireActual(moduleName: string): any;

  /**
   * Returns a mock module instead of the actual module, bypassing all checks
   * on whether the module should be required normally or not.
   */
  declare function jest$requireMock(moduleName: string): any;

  /**
   * Resets the module registry - the cache of all required modules. This is
   * useful to isolate modules where local state might conflict between tests.
   */
  declare function jest$resetModuleRegistry(): typeof jest;

  /**
   * Resets the module registry - the cache of all required modules. This is
   * useful to isolate modules where local state might conflict between tests.
   */
  declare function jest$resetModules(): typeof jest;

  /**
   * Exhausts tasks queued by setImmediate().
   */
  declare function jest$runAllImmediates(): typeof jest;

  /**
   * Exhausts the micro-task queue (usually interfaced in node via process.nextTick).
   */
  declare function jest$runAllTicks(): typeof jest;

  /**
   * Exhausts the macro-task queue (i.e., all tasks queued by setTimeout() and setInterval()).
   */
  declare function jest$runAllTimers(): typeof jest;

  /**
   * Executes only the macro-tasks that are currently pending (i.e., only the
   * tasks that have been queued by setTimeout() or setInterval() up to this point).
   * If any of the currently pending macro-tasks schedule new macro-tasks,
   * those new tasks will not be executed by this call.
   */
  declare function jest$runOnlyPendingTimers(): typeof jest;

  /**
   * (renamed to `advanceTimersByTime` in Jest 21.3.0+) Executes only the macro
   * task queue (i.e. all tasks queued by setTimeout() or setInterval() and setImmediate()).
   */
  declare function jest$runTimersToTime(msToRun: number): typeof jest;

  /**
   * Advances all timers by msToRun milliseconds. All pending "macro-tasks" that have been
   * queued via setTimeout() or setInterval(), and would be executed within this timeframe
   * will be executed.
   */
  declare function jest$advanceTimersByTime(msToRun: number): typeof jest;

  /**
   * Explicitly supplies the mock object that the module system should return
   * for the specified module.
   */
  declare function jest$setMock<T>(
    moduleName: string,
    moduleExports: T
  ): typeof jest;

  /**
   * Set the default timeout interval for tests and before/after hooks in milliseconds.
   * Note: The default timeout interval is 5 seconds if this method is not called.
   */
  declare function jest$setTimeout(timeout: number): typeof jest;

  /**
 * Creates a mock function similar to jest.fn but also tracks calls to `object[methodName]`
 * 
 * Note: By default, jest.spyOn also calls the spied method. This is different behavior from most
 * other test libraries.
 * @example const video = require('./video');

test('plays video', () => {
const spy = jest.spyOn(video, 'play');
const isPlaying = video.play();

expect(spy).toHaveBeenCalled();
expect(isPlaying).toBe(true);

spy.mockReset();
spy.mockRestore();
});
 */
  declare function jest$spyOn<T: {}, M: $Keys<T>>(
    object: T,
    method: M,
    accessType: "get"
  ): jest$SpyInstance<$ElementType<T, M>, []>;

  declare function jest$spyOn<T: {}, M: $Keys<T>>(
    object: T,
    method: M,
    accessType: "set"
  ): jest$SpyInstance<void, [$ElementType<T, M>]>;

  declare function jest$spyOn<T: {}, M: $Keys<T>>(
    object: T,
    method: M
  ): "There was Conditional Type, use $Call utility type";

  /**
   * Indicates that the module system should never return a mocked version of
   * the specified module from require() (e.g. that it should always return the real module).
   */
  declare function jest$unmock(moduleName: string): typeof jest;

  /**
   * Instructs Jest to use fake versions of the standard timer functions.
   */
  declare function jest$useFakeTimers(): typeof jest;

  /**
   * Instructs Jest to use the real versions of the standard timer functions.
   */
  declare function jest$useRealTimers(): typeof jest;

  declare interface jest$MockOptions {
    virtual?: boolean;
  }

  declare type jest$EmptyFunction = () => void;

  declare interface jest$DoneCallback {
    (...args: any[]): any;
    fail(
      error?:
        | string
        | {
            message: string
          }
    ): any;
  }

  declare type jest$ProvidesCallback = (cb: jest$DoneCallback) => any;

  declare type jest$Lifecycle = (
    jest$fn: jest$ProvidesCallback,
    timeout?: number
  ) => any;

  declare interface jest$FunctionLike {
    +name: string;
  }

  declare interface jest$Each {
    (cases: any[]): (name: string, jest$fn: (...args: any[]) => any) => void;
    (
      strings: TemplateStringsArray,
      ...placeholders: any[]
    ): (name: string, jest$fn: (arg: any) => any) => void;
  }

  /**
   * Creates a test closure
   */
  declare interface jest$It {
    /**
     * Creates a test closure.
     * @param name The name of your test
     * @param fn The function for your test
     * @param timeout The timeout for an async function test
     */
    (name: string, jest$fn?: jest$ProvidesCallback, timeout?: number): void;

    /**
     * Only runs this test in the current file.
     */
    only: jest$It;

    /**
     * Skips running this test in the current file.
     */
    skip: jest$It;

    /**
     * Sketch out which tests to write in the future.
     */
    todo: jest$It;

    /**
     * Experimental and should be avoided.
     */
    concurrent: jest$It;

    /**
 * Use if you keep duplicating the same test with different data. `.each` allows you to write the
 * test once and pass data in.
 * 
 * `.each` is available with two APIs:
 * 
 * #### 1  `test.each(table)(name, fn)`
 * 
 * - `table`: Array of Arrays with the arguments that are passed into the test fn for each row.
 * - `name`: String the title of the test block.
 * - `fn`: Function the test to be ran, this is the function that will receive the parameters in each row as function arguments.
 * 
 * 
 * #### 2  `test.each table(name, fn)`
 * 
 * - `table`: Tagged Template Literal
 * - `name`: String the title of the test, use `$variable` to inject test data into the test title from the tagged template expressions.
 * - `fn`: Function the test to be ran, this is the function that will receive the test data object..
 * @example // API 1
test.each([[1, 1, 2], [1, 2, 3], [2, 1, 3]])(
'.add(%i, %i)',
(a, b, expected) => {
expect(a + b).toBe(expected);
},
);

// API 2
test.each`
         * a    | b    | expected
         * ${1} | ${1} | ${2}
         * ${1} | ${2} | ${3}
         * ${2} | ${1} | ${3}
         * `('returns $expected when $a is added $b', ({a, b, expected}) => {
expect(a + b).toBe(expected);
});
 */
    each: jest$Each;
  }

  declare interface jest$Describe {
    (
      name: number | string | Function | jest$FunctionLike,
      jest$fn: jest$EmptyFunction
    ): void;

    /**
     * Only runs the tests inside this `describe` for the current file
     */
    only: jest$Describe;

    /**
     * Skips running the tests inside this `describe` for the current file
     */
    skip: jest$Describe;
    each: jest$Each;
  }

  declare interface jest$MatcherUtils {
    +expand: boolean;
    +isNot: boolean;
    utils: {
      +EXPECTED_COLOR: (text: string) => string,
      +RECEIVED_COLOR: (text: string) => string,
      ensureActualIsNumber(actual: any, matcherName?: string): void,
      ensureExpectedIsNumber(actual: any, matcherName?: string): void,
      ensureNoExpected(actual: any, matcherName?: string): void,
      ensureNumbers(actual: any, expected: any, matcherName?: string): void,

      /**
       * get the type of a value with handling of edge cases like `typeof []` and `typeof null`
       */
      getType(value: any): string,
      matcherHint(
        matcherName: string,
        received?: string,
        expected?: string,
        options?: {
          secondArgument?: string,
          isDirectExpectCall?: boolean
        }
      ): string,
      pluralize(word: string, count: number): string,
      printExpected(value: any): string,
      printReceived(value: any): string,
      printWithType(
        name: string,
        received: any,
        print: (value: any) => string
      ): string,
      stringify(object: {}, maxDepth?: number): string
    };

    /**
     * This is a deep-equality function that will return true if two objects have the same values (recursively).
     */
    equals(a: any, b: any): boolean;
  }

  declare interface jest$ExpectExtendMap {
    [key: string]: jasmine$CustomMatcher;
  }

  declare type jest$CustomMatcher = (
    received: any,
    ...actual: any[]
  ) => jasmine$CustomMatcherResult | Promise<jasmine$CustomMatcherResult>;

  declare interface jest$CustomMatcherResult {
    pass: boolean;
    message: string | (() => string);
    pass: boolean;
    message: string | (() => string);
  }

  declare interface jest$SnapshotSerializerOptions {
    callToJSON?: boolean;
    edgeSpacing?: string;
    spacing?: string;
    escapeRegex?: boolean;
    highlight?: boolean;
    indent?: number;
    maxDepth?: number;
    min?: boolean;
    plugins?: jest$SnapshotSerializerPlugin[];
    printFunctionName?: boolean;
    theme?: jest$SnapshotSerializerOptionsTheme;
  }

  declare interface jest$SnapshotSerializerOptionsTheme {
    comment?: string;
    content?: string;
    prop?: string;
    tag?: string;
    value?: string;
  }

  declare interface jest$SnapshotSerializerColor {
    close: string;
    open: string;
  }

  declare interface jest$SnapshotSerializerColors {
    comment: jest$SnapshotSerializerColor;
    content: jest$SnapshotSerializerColor;
    prop: jest$SnapshotSerializerColor;
    tag: jest$SnapshotSerializerColor;
    value: jest$SnapshotSerializerColor;
  }

  declare interface jest$SnapshotSerializerPlugin {
    print(
      val: any,
      serialize: (val: any) => string,
      indent: (str: string) => string,
      opts: jest$SnapshotSerializerOptions,
      colors: jest$SnapshotSerializerColors
    ): string;
    test(val: any): boolean;
  }

  declare interface jest$InverseAsymmetricMatchers {
    /**
     * `expect.not.arrayContaining(array)` matches a received array which
     * does not contain all of the elements in the expected array. That is,
     * the expected array is not a subset of the received array. It is the
     * inverse of `expect.arrayContaining`.
     */
    arrayContaining(arr: any[]): any;

    /**
     * `expect.not.objectContaining(object)` matches any received object
     * that does not recursively match the expected properties. That is, the
     * expected object is not a subset of the received object. Therefore,
     * it matches a received object which contains properties that are not
     * in the expected object. It is the inverse of `expect.objectContaining`.
     */
    objectContaining(obj: {}): any;

    /**
     * `expect.not.stringMatching(string | regexp)` matches the received
     * string that does not match the expected regexp. It is the inverse of
     * `expect.stringMatching`.
     */
    stringMatching(str: string | RegExp): any;

    /**
     * `expect.not.stringContaining(string)` matches the received string
     * that does not contain the exact expected string. It is the inverse of
     * `expect.stringContaining`.
     */
    stringContaining(str: string): any;
  }

  /**
   * The `expect` function is used every time you want to test a value.
   * You will rarely call `expect` by itself.
   */
  declare interface jest$Expect {
    /**
     * The `expect` function is used every time you want to test a value.
     * You will rarely call `expect` by itself.
     * @param actual The value to apply matchers against.
     */
    (actual: T): jest$Matchers<T>;

    /**
 * Matches anything but null or undefined. You can use it inside `toEqual` or `toBeCalledWith` instead
 * of a literal value. For example, if you want to check that a mock function is called with a
 * non-null argument:
 * @example test('map calls its argument with a non-null argument', () => {
const mock = jest.fn();
[1].map(x => mock(x));
expect(mock).toBeCalledWith(expect.anything());
});
 */
    anything(): any;

    /**
 * Matches anything that was created with the given constructor.
 * You can use it inside `toEqual` or `toBeCalledWith` instead of a literal value.
 * @example function randocall(fn) {
return fn(Math.floor(Math.random() * 6 + 1));
}

test('randocall calls its callback with a number', () => {
const mock = jest.fn();
randocall(mock);
expect(mock).toBeCalledWith(expect.any(Number));
});
 */
    any(classType: any): any;

    /**
     * Matches any array made up entirely of elements in the provided array.
     * You can use it inside `toEqual` or `toBeCalledWith` instead of a literal value.
     */
    arrayContaining(arr: any[]): any;

    /**
     * Verifies that a certain number of assertions are called during a test.
     * This is often useful when testing asynchronous code, in order to
     * make sure that assertions in a callback actually got called.
     */
    assertions(num: number): void;

    /**
     * Verifies that at least one assertion is called during a test.
     * This is often useful when testing asynchronous code, in order to
     * make sure that assertions in a callback actually got called.
     */
    hasAssertions(): void;

    /**
     * You can use `expect.extend` to add your own matchers to Jest.
     */
    extend(obj: jest$ExpectExtendMap): void;

    /**
     * Adds a module to format application-specific data structures for serialization.
     */
    addSnapshotSerializer(serializer: jest$SnapshotSerializerPlugin): void;

    /**
     * Matches any object that recursively matches the provided keys.
     * This is often handy in conjunction with other asymmetric matchers.
     */
    objectContaining(obj: {}): any;

    /**
     * Matches any string that contains the exact provided string
     */
    stringMatching(str: string | RegExp): any;

    /**
     * Matches any received string that contains the exact expected string
     */
    stringContaining(str: string): any;
    not: jest$InverseAsymmetricMatchers;
  }

  declare interface jest$Matchers<R> {
    /**
     * Ensures the last call to a mock function was provided specific args.
     */
    lastCalledWith(...args: any[]): R;

    /**
     * Ensure that the last call to a mock function has returned a specified value.
     */
    lastReturnedWith(value: any): R;

    /**
     * If you know how to test something, `.not` lets you test its opposite.
     */
    not: jest$Matchers<R>;

    /**
     * Ensure that a mock function is called with specific arguments on an Nth call.
     */
    nthCalledWith(nthCall: number, ...params: any[]): R;

    /**
     * Ensure that the nth call to a mock function has returned a specified value.
     */
    nthReturnedWith(n: number, value: any): R;

    /**
     * Use resolves to unwrap the value of a fulfilled promise so any other
     * matcher can be chained. If the promise is rejected the assertion fails.
     */
    resolves: jest$Matchers<Promise<R>>;

    /**
     * Unwraps the reason of a rejected promise so any other matcher can be chained.
     * If the promise is fulfilled the assertion fails.
     */
    rejects: jest$Matchers<Promise<R>>;

    /**
     * Checks that a value is what you expect. It uses `===` to check strict equality.
     * Don't use `toBe` with floating-point numbers.
     */
    toBe(expected: any): R;

    /**
     * Ensures that a mock function is called.
     */
    toBeCalled(): R;

    /**
     * Ensures that a mock function is called an exact number of times.
     */
    toBeCalledTimes(expected: number): R;

    /**
     * Ensure that a mock function is called with specific arguments.
     */
    toBeCalledWith(...args: any[]): R;

    /**
     * Using exact equality with floating point numbers is a bad idea.
     * Rounding means that intuitive things fail.
     * The default for numDigits is 2.
     */
    toBeCloseTo(expected: number, numDigits?: number): R;

    /**
     * Ensure that a variable is not undefined.
     */
    toBeDefined(): R;

    /**
     * When you don't care what a value is, you just want to
     * ensure a value is false in a boolean context.
     */
    toBeFalsy(): R;

    /**
     * For comparing floating point numbers.
     */
    toBeGreaterThan(expected: number): R;

    /**
     * For comparing floating point numbers.
     */
    toBeGreaterThanOrEqual(expected: number): R;

    /**
     * Ensure that an object is an instance of a class.
     * This matcher uses `instanceof` underneath.
     */
    toBeInstanceOf(expected: any): R;

    /**
     * For comparing floating point numbers.
     */
    toBeLessThan(expected: number): R;

    /**
     * For comparing floating point numbers.
     */
    toBeLessThanOrEqual(expected: number): R;

    /**
     * This is the same as `.toBe(null)` but the error messages are a bit nicer.
     * So use `.toBeNull()` when you want to check that something is null.
     */
    toBeNull(): R;

    /**
     * Use when you don't care what a value is, you just want to ensure a value
     * is true in a boolean context. In JavaScript, there are six falsy values:
     * `false`, `0`, `''`, `null`, `undefined`, and `NaN`. Everything else is truthy.
     */
    toBeTruthy(): R;

    /**
     * Used to check that a variable is undefined.
     */
    toBeUndefined(): R;

    /**
     * Used to check that a variable is NaN.
     */
    toBeNaN(): R;

    /**
     * Used when you want to check that an item is in a list.
     * For testing the items in the list, this uses `===`, a strict equality check.
     */
    toContain(expected: any): R;

    /**
     * Used when you want to check that an item is in a list.
     * For testing the items in the list, this  matcher recursively checks the
     * equality of all fields, rather than checking for object identity.
     */
    toContainEqual(expected: any): R;

    /**
     * Used when you want to check that two objects have the same value.
     * This matcher recursively checks the equality of all fields, rather than checking for object identity.
     */
    toEqual(expected: any): R;

    /**
     * Ensures that a mock function is called.
     */
    toHaveBeenCalled(): R;

    /**
     * Ensures that a mock function is called an exact number of times.
     */
    toHaveBeenCalledTimes(expected: number): R;

    /**
     * Ensure that a mock function is called with specific arguments.
     */
    toHaveBeenCalledWith(...params: any[]): R;

    /**
     * Ensure that a mock function is called with specific arguments on an Nth call.
     */
    toHaveBeenNthCalledWith(nthCall: number, ...params: any[]): R;

    /**
     * If you have a mock function, you can use `.toHaveBeenLastCalledWith`
     * to test what arguments it was last called with.
     */
    toHaveBeenLastCalledWith(...params: any[]): R;

    /**
     * Use to test the specific value that a mock function last returned.
     * If the last call to the mock function threw an error, then this matcher will fail
     * no matter what value you provided as the expected return value.
     */
    toHaveLastReturnedWith(expected: any): R;

    /**
     * Used to check that an object has a `.length` property
     * and it is set to a certain numeric value.
     */
    toHaveLength(expected: number): R;

    /**
     * Use to test the specific value that a mock function returned for the nth call.
     * If the nth call to the mock function threw an error, then this matcher will fail
     * no matter what value you provided as the expected return value.
     */
    toHaveNthReturnedWith(nthCall: number, expected: any): R;

    /**
     * Use to check if property at provided reference keyPath exists for an object.
     * For checking deeply nested properties in an object you may use dot notation or an array containing
     * the keyPath for deep references.
     *
     * Optionally, you can provide a value to check if it's equal to the value present at keyPath
     * on the target object. This matcher uses 'deep equality' (like `toEqual()`) and recursively checks
     * the equality of all fields.
     * @example expect(houseForSale).toHaveProperty('kitchen.area', 20);
     */
    toHaveProperty(propertyPath: string | any[], value?: any): R;

    /**
     * Use to test that the mock function successfully returned (i.e., did not throw an error) at least one time
     */
    toHaveReturned(): R;

    /**
     * Use to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times.
     * Any calls to the mock function that throw an error are not counted toward the number of times the function returned.
     */
    toHaveReturnedTimes(expected: number): R;

    /**
     * Use to ensure that a mock function returned a specific value.
     */
    toHaveReturnedWith(expected: any): R;

    /**
     * Check that a string matches a regular expression.
     */
    toMatch(expected: string | RegExp): R;

    /**
     * Used to check that a JavaScript object matches a subset of the properties of an object
     */
    toMatchObject(expected: {} | any[]): R;

    /**
     * This ensures that a value matches the most recent snapshot with property matchers.
     * Check out [the Snapshot Testing guide](http://facebook.github.io/jest/docs/snapshot-testing.html) for more information.
     */
    toMatchSnapshot<T: $ObjMapi<R, <P>(P) => any>>(
      propertyMatchers: $Shape<T>,
      snapshotName?: string
    ): R;

    /**
     * This ensures that a value matches the most recent snapshot.
     * Check out [the Snapshot Testing guide](http://facebook.github.io/jest/docs/snapshot-testing.html) for more information.
     */
    toMatchSnapshot(snapshotName?: string): R;

    /**
     * This ensures that a value matches the most recent snapshot with property matchers.
     * Instead of writing the snapshot value to a .snap file, it will be written into the source code automatically.
     * Check out [the Snapshot Testing guide](http://facebook.github.io/jest/docs/snapshot-testing.html) for more information.
     */
    toMatchInlineSnapshot<T: $ObjMapi<R, <P>(P) => any>>(
      propertyMatchers: $Shape<T>,
      snapshot?: string
    ): R;

    /**
     * This ensures that a value matches the most recent snapshot with property matchers.
     * Instead of writing the snapshot value to a .snap file, it will be written into the source code automatically.
     * Check out [the Snapshot Testing guide](http://facebook.github.io/jest/docs/snapshot-testing.html) for more information.
     */
    toMatchInlineSnapshot(snapshot?: string): R;

    /**
     * Ensure that a mock function has returned (as opposed to thrown) at least once.
     */
    toReturn(): R;

    /**
     * Ensure that a mock function has returned (as opposed to thrown) a specified number of times.
     */
    toReturnTimes(count: number): R;

    /**
     * Ensure that a mock function has returned a specified value at least once.
     */
    toReturnWith(value: any): R;

    /**
     * Use to test that objects have the same types as well as structure.
     */
    toStrictEqual(expected: {}): R;

    /**
     * Used to test that a function throws when it is called.
     */
    toThrow(error?: string | jest$Constructable | RegExp | Error): R;

    /**
     * If you want to test that a specific error is thrown inside a function.
     */
    toThrowError(error?: string | jest$Constructable | RegExp | Error): R;

    /**
     * Used to test that a function throws a error matching the most recent snapshot when it is called.
     */
    toThrowErrorMatchingSnapshot(): R;

    /**
     * Used to test that a function throws a error matching the most recent snapshot when it is called.
     * Instead of writing the snapshot value to a .snap file, it will be written into the source code automatically.
     */
    toThrowErrorMatchingInlineSnapshot(snapshot?: string): R;
  }

  declare interface jest$Constructable {
    new(...args: any[]): any;
  }

  declare type jest$Mock<T, Y: any[]> = {
    new(...args: Y): T,
    (...args: Y): T
  } & Function &
    jest$MockInstance<T, Y>;

  declare type jest$SpyInstance<T, Y: any[]> = {} & jest$MockInstance<T, Y>;

  /**
 * Wrap module with mock definitions
 * @example jest.mock("../api");
import { Api } from "../api";

const myApi: jest.Mocked<Api> = new Api() as any;
myApi.myApiMethod.mockImplementation(() => "test");
 */
  declare type jest$Mocked<T> = $ObjMapi<
    T,
    <P>(
      P
    ) => $ElementType<T, P> &
      jest$MockInstance<$ElementType<T, P>, ArgsType<$ElementType<T, P>>>
  > &
    T;

  declare interface jest$MockInstance<T, Y: any[]> {
    /**
     * Returns the mock name string set by calling `mockFn.mockName(value)`.
     */
    getMockName(): string;

    /**
     * Provides access to the mock's metadata
     */
    jest$mock: jest$MockContext<T, Y>;

    /**
     * Resets all information stored in the mockFn.mock.calls and mockFn.mock.instances arrays.
     *
     * Often this is useful when you want to clean up a mock's usage data between two assertions.
     *
     * Beware that `mockClear` will replace `mockFn.mock`, not just `mockFn.mock.calls` and `mockFn.mock.instances`.
     * You should therefore avoid assigning mockFn.mock to other variables, temporary or not, to make sure you
     * don't access stale data.
     */
    mockClear(): void;

    /**
     * Resets all information stored in the mock, including any initial implementation and mock name given.
     *
     * This is useful when you want to completely restore a mock back to its initial state.
     *
     * Beware that `mockReset` will replace `mockFn.mock`, not just `mockFn.mock.calls` and `mockFn.mock.instances`.
     * You should therefore avoid assigning mockFn.mock to other variables, temporary or not, to make sure you
     * don't access stale data.
     */
    mockReset(): void;

    /**
     * Does everything that `mockFn.mockReset()` does, and also restores the original (non-mocked) implementation.
     *
     * This is useful when you want to mock functions in certain test cases and restore the original implementation in others.
     *
     * Beware that `mockFn.mockRestore` only works when mock was created with `jest.spyOn`. Thus you have to take care of restoration
     * yourself when manually assigning `jest.fn()`.
     *
     * The [`restoreMocks`](https://jestjs.io/docs/en/configuration.html#restoremocks-boolean) configuration option is available
     * to restore mocks automatically between tests.
     */
    mockRestore(): void;

    /**
     * Accepts a function that should be used as the implementation of the mock. The mock itself will still record
     * all calls that go into and instances that come from itself – the only difference is that the implementation
     * will also be executed when the mock is called.
     *
     * Note: `jest.fn(implementation)` is a shorthand for `jest.fn().mockImplementation(implementation)`.
     */
    mockImplementation(jest$fn?: (...args: Y) => T): jest$Mock<T, Y>;

    /**
 * Accepts a function that will be used as an implementation of the mock for one call to the mocked function.
 * Can be chained so that multiple function calls produce different results.
 * @example const myMockFn = jest
.fn()
.mockImplementationOnce(cb => cb(null, true))
.mockImplementationOnce(cb => cb(null, false));

myMockFn((err, val) => console.log(val)); // true

myMockFn((err, val) => console.log(val)); // false
 */
    mockImplementationOnce(jest$fn: (...args: Y) => T): jest$Mock<T, Y>;

    /**
     * Sets the name of the mock`. *
     */
    mockName(name: string): jest$Mock<T, Y>;

    /**
 * Just a simple sugar function for:
 * @example jest.fn(function() {
return this;
});
 */
    mockReturnThis(): jest$Mock<T, Y>;

    /**
 * Accepts a value that will be returned whenever the mock function is called.
 * @example const mock = jest.fn();
mock.mockReturnValue(42);
mock(); // 42
mock.mockReturnValue(43);
mock(); // 43
 */
    mockReturnValue(value: T): jest$Mock<T, Y>;

    /**
 * Accepts a value that will be returned for one call to the mock function. Can be chained so that
 * successive calls to the mock function return different values. When there are no more
 * `mockReturnValueOnce` values to use, calls will return a value specified by `mockReturnValue`.
 * @example const myMockFn = jest.fn()
.mockReturnValue('default')
.mockReturnValueOnce('first call')
.mockReturnValueOnce('second call');

// 'first call', 'second call', 'default', 'default'
console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
 */
    mockReturnValueOnce(value: T): jest$Mock<T, Y>;

    /**
     * Simple sugar function for: `jest.fn().mockImplementation(() => Promise.resolve(value));`
     */
    mockResolvedValue(value: T | PromiseLike<T>): jest$Mock<Promise<T>, Y>;

    /**
 * Simple sugar function for: `jest.fn().mockImplementationOnce(() => Promise.resolve(value));`
 * @example test('async test', async () => {
const asyncMock = jest
.fn()
.mockResolvedValue('default')
.mockResolvedValueOnce('first call')
.mockResolvedValueOnce('second call');

await asyncMock(); // first call
await asyncMock(); // second call
await asyncMock(); // default
await asyncMock(); // default
});
 */
    mockResolvedValueOnce(value: T | PromiseLike<T>): jest$Mock<Promise<T>, Y>;

    /**
 * Simple sugar function for: `jest.fn().mockImplementation(() => Promise.reject(value));`
 * @example test('async test', async () => {
const asyncMock = jest.fn().mockRejectedValue(new Error('Async error'));

await asyncMock(); // throws "Async error"
});
 */
    mockRejectedValue(value: any): jest$Mock<Promise<T>, Y>;

    /**
 * Simple sugar function for: `jest.fn().mockImplementationOnce(() => Promise.reject(value));`
 * @example test('async test', async () => {
const asyncMock = jest
.fn()
.mockResolvedValueOnce('first call')
.mockRejectedValueOnce(new Error('Async error'));

await asyncMock(); // first call
await asyncMock(); // throws "Async error"
});
 */
    mockRejectedValueOnce(value: any): jest$Mock<Promise<T>, Y>;
  }

  /**
   * Represents the result of a single call to a mock function.
   */
  declare interface jest$MockResult {
    /**
     * True if the function threw.
     * False if the function returned.
     */
    isThrow: boolean;

    /**
     * The value that was either thrown or returned by the function.
     */
    value: any;
  }

  declare interface jest$MockContext<T, Y: any[]> {
    calls: Y[];
    instances: T[];
    invocationCallOrder: number[];

    /**
     * List of results of calls to the mock function.
     */
    results: jest$MockResult[];
  }

  declare type jest$Maybe<T> = void | null | void | T;

  declare type jest$TestResultsProcessor = (
    testResult: jest$AggregatedResult
  ) => jest$AggregatedResult;

  declare type jest$HasteResolver = any;

  declare type jest$ModuleMocker = any;

  declare type jest$ModuleMap = any;

  declare type jest$HasteFS = any;

  declare type jest$Runtime = any;

  declare type jest$Script = any;

  declare type jest$Path = string;

  declare type jest$Glob = string;

  declare interface jest$HasteConfig {
    defaultPlatform?: jest$Maybe<string>;
    hasteImplModulePath?: string;
    platforms?: string[];
    providesModuleNodeModules: string[];
  }

  declare type jest$ReporterConfig = [string, { [key: string]: any }];

  declare type jest$ConfigGlobals = { [key: string]: any };

  declare type jest$SnapshotUpdateState = "all" | "new" | "none";

  declare interface jest$DefaultOptions {
    automock: boolean;
    bail: boolean;
    browser: boolean;
    cache: boolean;
    cacheDirectory: jest$Path;
    changedFilesWithAncestor: boolean;
    clearMocks: boolean;
    collectCoverage: boolean;
    collectCoverageFrom: jest$Maybe<string[]>;
    coverageDirectory: jest$Maybe<string>;
    coveragePathIgnorePatterns: string[];
    coverageReporters: string[];
    coverageThreshold: jest$Maybe<{
      global: {
        [key: string]: number
      }
    }>;
    errorOnDeprecated: boolean;
    expand: boolean;
    filter: jest$Maybe<jest$Path>;
    forceCoverageMatch: jest$Glob[];
    globals: jest$ConfigGlobals;
    globalSetup: jest$Maybe<string>;
    globalTeardown: jest$Maybe<string>;
    haste: jest$HasteConfig;
    detectLeaks: boolean;
    detectOpenHandles: boolean;
    moduleDirectories: string[];
    moduleFileExtensions: string[];
    moduleNameMapper: {
      [key: string]: string
    };
    modulePathIgnorePatterns: string[];
    noStackTrace: boolean;
    notify: boolean;
    notifyMode: string;
    preset: jest$Maybe<string>;
    projects: jest$Maybe<Array<string | jest$ProjectConfig>>;
    resetMocks: boolean;
    jest$resetModules: boolean;
    resolver: jest$Maybe<jest$Path>;
    restoreMocks: boolean;
    rootDir: jest$Maybe<jest$Path>;
    roots: jest$Maybe<jest$Path[]>;
    runner: string;
    runTestsByPath: boolean;
    setupFiles: jest$Path[];
    setupTestFrameworkScriptFile: jest$Maybe<jest$Path>;
    skipFilter: boolean;
    snapshotSerializers: jest$Path[];
    testEnvironment: string;
    testEnvironmentOptions: { [key: string]: any };
    testFailureExitCode: string | number;
    testLocationInResults: boolean;
    testMatch: jest$Glob[];
    testPathIgnorePatterns: string[];
    testRegex: string;
    testResultsProcessor: jest$Maybe<string>;
    testRunner: jest$Maybe<string>;
    testURL: string;
    timers: "real" | "fake";
    transform: jest$Maybe<{
      [key: string]: string
    }>;
    transformIgnorePatterns: jest$Glob[];
    watchPathIgnorePatterns: string[];
    useStderr: boolean;
    verbose: jest$Maybe<boolean>;
    watch: boolean;
    watchman: boolean;
  }

  declare interface jest$InitialOptions {
    automock?: boolean;
    bail?: boolean;
    browser?: boolean;
    cache?: boolean;
    cacheDirectory?: jest$Path;
    clearMocks?: boolean;
    changedFilesWithAncestor?: boolean;
    changedSince?: string;
    collectCoverage?: boolean;
    collectCoverageFrom?: jest$Glob[];
    collectCoverageOnlyFrom?: {
      [key: string]: boolean
    };
    coverageDirectory?: string;
    coveragePathIgnorePatterns?: string[];
    coverageReporters?: string[];
    coverageThreshold?: {
      global: {
        [key: string]: number
      }
    };
    detectLeaks?: boolean;
    detectOpenHandles?: boolean;
    displayName?: string;
    expand?: boolean;
    filter?: jest$Path;
    findRelatedTests?: boolean;
    forceCoverageMatch?: jest$Glob[];
    forceExit?: boolean;
    json?: boolean;
    globals?: jest$ConfigGlobals;
    globalSetup?: jest$Maybe<string>;
    globalTeardown?: jest$Maybe<string>;
    haste?: jest$HasteConfig;
    reporters?: Array<jest$ReporterConfig | string>;
    logHeapUsage?: boolean;
    lastCommit?: boolean;
    listTests?: boolean;
    mapCoverage?: boolean;
    moduleDirectories?: string[];
    moduleFileExtensions?: string[];
    moduleLoader?: jest$Path;
    moduleNameMapper?: {
      [key: string]: string
    };
    modulePathIgnorePatterns?: string[];
    modulePaths?: string[];
    name?: string;
    noStackTrace?: boolean;
    notify?: boolean;
    notifyMode?: string;
    onlyChanged?: boolean;
    outputFile?: jest$Path;
    passWithNoTests?: boolean;
    preprocessorIgnorePatterns?: jest$Glob[];
    preset?: jest$Maybe<string>;
    projects?: jest$Glob[];
    replname?: jest$Maybe<string>;
    resetMocks?: boolean;
    jest$resetModules?: boolean;
    resolver?: jest$Maybe<jest$Path>;
    restoreMocks?: boolean;
    rootDir?: jest$Path;
    roots?: jest$Path[];
    runner?: string;
    runTestsByPath?: boolean;
    scriptPreprocessor?: string;
    setupFiles?: jest$Path[];
    setupTestFrameworkScriptFile?: jest$Path;
    silent?: boolean;
    skipFilter?: boolean;
    skipNodeResolution?: boolean;
    snapshotSerializers?: jest$Path[];
    errorOnDeprecated?: boolean;
    testEnvironment?: string;
    testEnvironmentOptions?: { [key: string]: any };
    testFailureExitCode?: string | number;
    testLocationInResults?: boolean;
    testMatch?: jest$Glob[];
    testNamePattern?: string;
    testPathDirs?: jest$Path[];
    testPathIgnorePatterns?: string[];
    testRegex?: string;
    testResultsProcessor?: jest$Maybe<string>;
    testRunner?: string;
    testURL?: string;
    timers?: "real" | "fake";
    transform?: {
      [key: string]: string
    };
    transformIgnorePatterns?: jest$Glob[];
    watchPathIgnorePatterns?: string[];
    unmockedModulePathPatterns?: string[];
    updateSnapshot?: boolean;
    useStderr?: boolean;
    verbose?: jest$Maybe<boolean>;
    watch?: boolean;
    watchAll?: boolean;
    watchman?: boolean;
    watchPlugins?: string[];
  }

  declare interface jest$GlobalConfig {
    bail: boolean;
    collectCoverage: boolean;
    collectCoverageFrom: jest$Glob[];
    collectCoverageOnlyFrom: jest$Maybe<{
      [key: string]: boolean
    }>;
    coverageDirectory: string;
    coverageReporters: string[];
    coverageThreshold: {
      global: {
        [key: string]: number
      }
    };
    expand: boolean;
    forceExit: boolean;
    logHeapUsage: boolean;
    mapCoverage: boolean;
    noStackTrace: boolean;
    notify: boolean;
    projects: jest$Glob[];
    replname: jest$Maybe<string>;
    reporters: jest$ReporterConfig[];
    rootDir: jest$Path;
    silent: boolean;
    testNamePattern: string;
    testPathPattern: string;
    testResultsProcessor: jest$Maybe<string>;
    updateSnapshot: jest$SnapshotUpdateState;
    useStderr: boolean;
    verbose: jest$Maybe<boolean>;
    watch: boolean;
    watchman: boolean;
  }

  declare interface jest$ProjectConfig {
    automock: boolean;
    browser: boolean;
    cache: boolean;
    cacheDirectory: jest$Path;
    clearMocks: boolean;
    coveragePathIgnorePatterns: string[];
    cwd: jest$Path;
    detectLeaks: boolean;
    displayName: jest$Maybe<string>;
    forceCoverageMatch: jest$Glob[];
    globals: jest$ConfigGlobals;
    haste: jest$HasteConfig;
    moduleDirectories: string[];
    moduleFileExtensions: string[];
    moduleLoader: jest$Path;
    moduleNameMapper: Array<[string, string]>;
    modulePathIgnorePatterns: string[];
    modulePaths: string[];
    name: string;
    resetMocks: boolean;
    jest$resetModules: boolean;
    resolver: jest$Maybe<jest$Path>;
    rootDir: jest$Path;
    roots: jest$Path[];
    runner: string;
    setupFiles: jest$Path[];
    setupTestFrameworkScriptFile: jest$Path;
    skipNodeResolution: boolean;
    snapshotSerializers: jest$Path[];
    testEnvironment: string;
    testEnvironmentOptions: { [key: string]: any };
    testLocationInResults: boolean;
    testMatch: jest$Glob[];
    testPathIgnorePatterns: string[];
    testRegex: string;
    testRunner: string;
    testURL: string;
    timers: "real" | "fake";
    transform: Array<[string, jest$Path]>;
    transformIgnorePatterns: jest$Glob[];
    unmockedModulePathPatterns: jest$Maybe<string[]>;
    watchPathIgnorePatterns: string[];
  }

  declare type jest$LogMessage = string;

  declare interface jest$LogEntry {
    message: jest$LogMessage;
    origin: string;
    type: jest$LogType;
  }

  declare type jest$LogType = "log" | "info" | "warn" | "error";

  declare type jest$ConsoleBuffer = jest$LogEntry[];

  declare interface jest$Context {
    config: jest$ProjectConfig;
    hasteFS: jest$HasteFS;
    moduleMap: jest$ModuleMap;
    resolver: jest$HasteResolver;
  }

  declare interface jest$FakeTimers {
    clearAllTimers(): void;
    runAllImmediates(): void;
    runAllTicks(): void;
    runAllTimers(): void;
    runTimersToTime(msToRun: number): void;
    advanceTimersByTime(msToRun: number): void;
    runOnlyPendingTimers(): void;
    runWithRealTimers(callback: any): void;
    useFakeTimers(): void;
    useRealTimers(): void;
  }

  declare interface jest$$JestEnvironment {
    global: jest$Global;
    fakeTimers: jest$FakeTimers;
    testFilePath: string;
    moduleMocker: jest$ModuleMocker;
    dispose(): void;
    runScript(script: jest$Script): any;
  }

  declare type jest$Environment = jest$$JestEnvironment;

  declare type jest$Global = { [key: string]: any };

  declare interface jest$ReporterOnStartOptions {
    estimatedTime: number;
    showStatus: boolean;
  }

  declare interface jest$RawFileCoverage {
    path: string;
    s: {
      [statementId: number]: number
    };
    b: {
      [branchId: number]: number
    };
    f: {
      [functionId: number]: number
    };
    l: {
      [lineId: number]: number
    };
    fnMap: {
      [functionId: number]: any
    };
    statementMap: {
      [statementId: number]: any
    };
    branchMap: {
      [branchId: number]: any
    };
    inputSourceMap?: { [key: string]: any };
  }

  declare interface jest$RawCoverage {
    [filePath: string]: jest$RawFileCoverage;
  }

  declare interface jest$FileCoverageTotal {
    total: number;
    covered: number;
    skipped: number;
    pct?: number;
  }

  declare interface jest$CoverageSummary {
    lines: jest$FileCoverageTotal;
    statements: jest$FileCoverageTotal;
    branches: jest$FileCoverageTotal;
    functions: jest$FileCoverageTotal;
  }

  declare interface jest$FileCoverage {
    getLineCoverage(): { [key: string]: any };
    getUncoveredLines(): number[];
    getBranchCoverageByLine(): { [key: string]: any };
    toJSON(): { [key: string]: any };
    merge(other: { [key: string]: any }): void;
    computeSimpleTotals(property: string): jest$FileCoverageTotal;
    computeBranchTotals(): jest$FileCoverageTotal;
    resetHits(): void;
    toSummary(): jest$CoverageSummary;
  }

  declare interface jest$CoverageMap {
    merge(data: { [key: string]: any }): void;
    getCoverageSummary(): jest$FileCoverage;
    data: jest$RawCoverage;
    addFileCoverage(fileCoverage: jest$RawFileCoverage): void;
    files(): string[];
    fileCoverageFor(file: string): jest$FileCoverage;
  }

  declare interface jest$SerializableError {
    code?: any;
    message: string;
    stack: jest$Maybe<string>;
    type?: string;
  }

  declare type jest$Status = "passed" | "failed" | "skipped" | "pending";

  declare type jest$Bytes = number;

  declare type jest$Milliseconds = number;

  declare interface jest$AssertionResult {
    ancestorTitles: string[];
    duration?: jest$Maybe<jest$Milliseconds>;
    failureMessages: string[];
    fullName: string;
    numPassingAsserts: number;
    status: jest$Status;
    title: string;
  }

  declare interface jest$AggregatedResult {
    coverageMap?: jest$Maybe<jest$CoverageMap>;
    numFailedTests: number;
    numFailedTestSuites: number;
    numPassedTests: number;
    numPassedTestSuites: number;
    numPendingTests: number;
    numPendingTestSuites: number;
    numRuntimeErrorTestSuites: number;
    numTotalTests: number;
    numTotalTestSuites: number;
    snapshot: jest$SnapshotSummary;
    startTime: number;
    success: boolean;
    testResults: jest$TestResult[];
    wasInterrupted: boolean;
  }

  declare interface jest$TestResult {
    console: jest$Maybe<jest$ConsoleBuffer>;
    coverage?: jest$RawCoverage;
    memoryUsage?: jest$Bytes;
    failureMessage: jest$Maybe<string>;
    numFailingTests: number;
    numPassingTests: number;
    numPendingTests: number;
    perfStats: {
      end: jest$Milliseconds,
      start: jest$Milliseconds
    };
    skipped: boolean;
    snapshot: {
      added: number,
      fileDeleted: boolean,
      matched: number,
      unchecked: number,
      unmatched: number,
      updated: number
    };
    sourceMaps: {
      [sourcePath: string]: string
    };
    testExecError?: jest$SerializableError;
    testFilePath: string;
    testResults: jest$AssertionResult[];
  }

  declare interface jest$SnapshotSummary {
    added: number;
    didUpdate: boolean;
    failure: boolean;
    filesAdded: number;
    filesRemoved: number;
    filesUnmatched: number;
    filesUpdated: number;
    matched: number;
    total: number;
    unchecked: number;
    unmatched: number;
    updated: number;
  }

  declare interface jest$Test {
    context: jest$Context;
    duration?: number;
    path: jest$Path;
  }

  declare interface jest$Set<T> {}

  declare interface jest$Reporter {
    onTestResult(
      test: jest$Test,
      testResult: jest$TestResult,
      aggregatedResult: jest$AggregatedResult
    ): void;
    onRunStart(
      results: jest$AggregatedResult,
      options: jest$ReporterOnStartOptions
    ): void;
    onTestStart(test: jest$Test): void;
    onRunComplete(
      contexts: jest$Set<jest$Context>,
      results: jest$AggregatedResult
    ): jest$Maybe<Promise<void>>;
    getLastError(): jest$Maybe<Error>;
  }

  declare type jest$TestFramework = (
    globalConfig: jest$GlobalConfig,
    config: jest$ProjectConfig,
    environment: jest$Environment,
    runtime: jest$Runtime,
    testPath: string
  ) => Promise<jest$TestResult>;

  declare interface jest$TransformedSource {
    code: string;
    map: jest$Maybe<{ [key: string]: any } | string>;
  }

  declare interface jest$TransformOptions {
    instrument: boolean;
  }

  declare interface jest$Transformer {
    canInstrument?: boolean;
    createTransformer(options: any): jest$Transformer;
    getCacheKey(
      fileData: string,
      filePath: jest$Path,
      configStr: string,
      options: jest$TransformOptions
    ): string;
    process(
      sourceText: string,
      sourcePath: jest$Path,
      config: jest$ProjectConfig,
      options?: jest$TransformOptions
    ): string | jest$TransformedSource;
  }
  declare function spyOn<T>(object: T, method: $Keys<T>): jasmine$jasmine$Spy;

  /**
   * If you call the function pending anywhere in the spec body,
   * no matter the expectations, the spec will be marked pending.
   */
  declare function pending(reason?: string): void;

  /**
   * Fails a test when called within one.
   */
  declare function fail(error?: any): empty;

  declare var npm$namespace$jasmine: {
    clock: typeof jasmine$clock,
    any: typeof jasmine$any,
    anything: typeof jasmine$anything,
    arrayContaining: typeof jasmine$arrayContaining,
    objectContaining: typeof jasmine$objectContaining,
    createSpy: typeof jasmine$createSpy,
    createSpyObj: typeof jasmine$createSpyObj,
    pp: typeof jasmine$pp,
    addCustomEqualityTester: typeof jasmine$addCustomEqualityTester,
    addMatchers: typeof jasmine$addMatchers,
    stringMatching: typeof jasmine$stringMatching,
    DEFAULT_TIMEOUT_INTERVAL: typeof jasmine$DEFAULT_TIMEOUT_INTERVAL
  };
  declare var jasmine$DEFAULT_TIMEOUT_INTERVAL: number;

  declare function jasmine$clock(): jasmine$Clock;

  declare function jasmine$any(aclass: any): jasmine$Any;

  declare function jasmine$anything(): jasmine$Any;

  declare function jasmine$arrayContaining(
    sample: any[]
  ): jasmine$ArrayContaining;

  declare function jasmine$objectContaining(
    sample: any
  ): jasmine$ObjectContaining;

  declare function jasmine$createSpy(
    name?: string,
    originalFn?: (...args: any[]) => any
  ): jasmine$Spy;

  declare function jasmine$createSpyObj(
    baseName: string,
    methodNames: any[]
  ): any;

  declare function jasmine$createSpyObj<T>(
    baseName: string,
    methodNames: any[]
  ): T;

  declare function jasmine$pp(value: any): string;

  declare function jasmine$addCustomEqualityTester(
    equalityTester: jasmine$CustomEqualityTester
  ): void;

  declare function jasmine$addMatchers(
    matchers: jasmine$CustomMatcherFactories
  ): void;

  declare function jasmine$stringMatching(value: string | RegExp): jasmine$Any;

  declare interface jasmine$Clock {
    install(): void;
    uninstall(): void;

    /**
     * Calls to any registered callback are triggered when the clock isticked forward
     * via the jasmine.clock().tick function, which takes a number of milliseconds.
     */
    tick(ms: number): void;
    mockDate(date?: Date): void;
  }

  declare interface jasmine$Any {
    new(expectedClass: any): any;
    jasmineMatches(other: any): boolean;
    jasmineToString(): string;
  }

  declare interface jasmine$ArrayContaining {
    new(sample: any[]): any;
    asymmetricMatch(other: any): boolean;
    jasmineToString(): string;
  }

  declare interface jasmine$ObjectContaining {
    new(sample: any): any;
    jasmineMatches(
      other: any,
      mismatchKeys: any[],
      mismatchValues: any[]
    ): boolean;
    jasmineToString(): string;
  }

  declare interface jasmine$Spy {
    (...params: any[]): any;
    identity: string;
    and: jasmine$SpyAnd;
    calls: jasmine$Calls;
    mostRecentCall: {
      args: any[]
    };
    argsForCall: any[];
    wasCalled: boolean;
  }

  declare interface jasmine$SpyAnd {
    /**
     * By chaining the spy with and.callThrough, the spy will still track all
     * calls to it but in addition it will delegate to the actual implementation.
     */
    callThrough(): jasmine$Spy;

    /**
     * By chaining the spy with and.returnValue, all calls to the function
     * will return a specific value.
     */
    returnValue(val: any): jasmine$Spy;

    /**
     * By chaining the spy with and.returnValues, all calls to the function
     * will return specific values in order until it reaches the end of the return values list.
     */
    returnValues(...values: any[]): jasmine$Spy;

    /**
     * By chaining the spy with and.callFake, all calls to the spy
     * will delegate to the supplied function.
     */
    callFake(jest$fn: (...args: any[]) => any): jasmine$Spy;

    /**
     * By chaining the spy with and.throwError, all calls to the spy
     * will throw the specified value.
     */
    throwError(msg: string): jasmine$Spy;

    /**
     * When a calling strategy is used for a spy, the original stubbing
     * behavior can be returned at any time with and.stub.
     */
    stub(): jasmine$Spy;
  }

  declare interface jasmine$Calls {
    /**
     * By chaining the spy with calls.any(),
     * will return false if the spy has not been called at all,
     * and then true once at least one call happens.
     */
    any(): boolean;

    /**
     * By chaining the spy with calls.count(),
     * will return the number of times the spy was called
     */
    count(): number;

    /**
     * By chaining the spy with calls.argsFor(),
     * will return the arguments passed to call number index
     */
    argsFor(index: number): any[];

    /**
     * By chaining the spy with calls.allArgs(),
     * will return the arguments to all calls
     */
    allArgs(): any[];

    /**
     * By chaining the spy with calls.all(), will return the
     * context (the this) and arguments passed all calls
     */
    all(): jasmine$CallInfo[];

    /**
     * By chaining the spy with calls.mostRecent(), will return the
     * context (the this) and arguments for the most recent call
     */
    mostRecent(): jasmine$CallInfo;

    /**
     * By chaining the spy with calls.first(), will return the
     * context (the this) and arguments for the first call
     */
    first(): jasmine$CallInfo;

    /**
     * By chaining the spy with calls.reset(), will clears all tracking for a spy
     */
    reset(): void;
  }

  declare interface jasmine$CallInfo {
    /**
     * The context (the this) for the call
     */
    object: any;

    /**
     * All arguments passed to the call
     */
    args: any[];

    /**
     * The return value of the call
     */
    returnValue: any;
  }

  declare interface jasmine$CustomMatcherFactories {
    [index: string]: jasmine$CustomMatcherFactory;
  }

  declare type jasmine$CustomMatcherFactory = (
    util: jasmine$MatchersUtil,
    customEqualityTesters: jasmine$CustomEqualityTester[]
  ) => jest$CustomMatcher;

  declare interface jasmine$MatchersUtil {
    equals(
      a: any,
      b: any,
      customTesters?: jasmine$CustomEqualityTester[]
    ): boolean;
    contains<T>(
      haystack: jasmine$ArrayLike<T> | string,
      needle: any,
      customTesters?: jasmine$CustomEqualityTester[]
    ): boolean;
    buildFailureMessage(
      matcherName: string,
      isNot: boolean,
      actual: any,
      ...expected: any[]
    ): string;
  }

  declare type jasmine$CustomEqualityTester = (
    first: any,
    second: any
  ) => boolean;

  declare type jasmine$CustomMatcher = (
    received: any,
    ...actual: any[]
  ) => jest$CustomMatcherResult | Promise<jest$CustomMatcherResult>;

  declare interface jasmine$CustomMatcherResult {
    pass: boolean;
    message: string | (() => string);
    pass: boolean;
    message: string | (() => string);
  }

  declare interface jasmine$ArrayLike<T> {
    length: number;
    [n: number]: T;
  }
}

