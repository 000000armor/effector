/**
 * This is an autogenerated libdef stub for:
 *
 *   'rollup'
 *
 * Fill this stub out by fixing all the errors.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */
declare module "rollup" {
  import typeof * as ESTree from "estree";

  import type { EventEmitter } from "events";

  declare export var VERSION: string;
  declare export interface IdMap {
    [key: string]: string;
  }
  declare export type RollupError = {
    stack?: string
  } & RollupLogProps;

  declare export type RollupWarning = {
    exporter?: string,
    exportName?: string,
    guess?: string,
    importer?: string,
    missing?: string,
    modules?: string[],
    names?: string[],
    reexporter?: string,
    source?: string,
    sources?: string[]
  } & RollupLogProps;

  declare export interface RollupLogProps {
    code?: string;
    frame?: string;
    hook?: string;
    id?: string;
    loc?: {
      file?: string,
      line: number,
      column: number
    };
    message: string;
    name?: string;
    plugin?: string;
    pluginCode?: string;
    pos?: number;
    url?: string;
  }
  declare export interface ExistingRawSourceMap {
    version: number;
    sources: string[];
    names: string[];
    sourceRoot?: string;
    sourcesContent?: string[];
    mappings: string;
    file?: string;
  }
  declare export type RawSourceMap =
    | {
        mappings: ""
      }
    | ExistingRawSourceMap;
  declare export interface SourceMap {
    version: string;
    file: string;
    sources: string[];
    sourcesContent: string[];
    names: string[];
    mappings: string;
    toString(): string;
    toUrl(): string;
  }
  declare export interface SourceDescription {
    code: string;
    map?: string | RawSourceMap;
  }
  declare export type TransformSourceDescription = {
    ast?: ESTree.Program,
    dependencies?: string[]
  } & SourceDescription;

  declare export interface ModuleJSON {
    id: string;
    dependencies: string[];
    transformDependencies: string[] | null;
    transformAssets: Asset[] | void;
    code: string;
    originalCode: string;
    originalSourcemap: RawSourceMap | void;
    ast: ESTree.Program;
    sourcemapChain: RawSourceMap[];
    resolvedIds: IdMap;
    customTransformCache: boolean;
  }
  declare export interface Asset {
    name: string;
    source: string | Buffer;
    fileName: string;
  }
  declare export interface PluginCache {
    has(id: string): boolean;
    get<T>(id: string): T;
    set<T>(id: string, value: T): void;
    delete(id: string): boolean;
  }
  declare export interface MinimalPluginContext {
    meta: PluginContextMeta;
  }
  declare export type PluginContext = {
    /**
     * @deprecated
     */
    watcher: EventEmitter,
    addWatchFile: (id: string) => void,
    cache: PluginCache,
    resolveId: ResolveIdHook,
    isExternal: IsExternal,
    parse: (input: string, options: any) => ESTree.Program,
    emitAsset(name: string, source?: string | Buffer): string,
    setAssetSource: (assetId: string, source: string | Buffer) => void,
    getAssetFileName: (assetId: string) => string,
    warn(
      warning: RollupWarning | string,
      pos?: {
        line: number,
        column: number
      }
    ): void,
    error(
      err: RollupError | string,
      pos?: {
        line: number,
        column: number
      }
    ): void,
    moduleIds: IterableIterator<string>,
    getModuleInfo: (
      moduleId: string
    ) => {
      id: string,
      isExternal: boolean,
      importedIds: string[]
    }
  } & MinimalPluginContext;

  declare export interface PluginContextMeta {
    rollupVersion: string;
  }
  declare export type ResolveIdHook = (
    id: string,
    parent: string
  ) => Promise<string | false | null> | string | false | void | null;
  declare export type IsExternal = (
    id: string,
    parentId: string,
    isResolved: boolean
  ) => boolean | void;
  declare export type LoadHook = (
    id: string
  ) =>
    | Promise<SourceDescription | string | null>
    | SourceDescription
    | string
    | null;
  declare export type TransformHook = (
    code: string,
    id: string
  ) =>
    | Promise<TransformSourceDescription | string | void>
    | TransformSourceDescription
    | string
    | void;
  declare export type TransformChunkHook = (
    code: string,
    options: OutputOptions
  ) =>
    | Promise<{
        code: string,
        map: RawSourceMap
      } | void>
    | {
        code: string,
        map: RawSourceMap
      }
    | void
    | null;
  declare export type RenderChunkHook = (
    code: string,
    chunk: RenderedChunk,
    options: OutputOptions
  ) =>
    | Promise<{
        code: string,
        map: RawSourceMap
      } | null>
    | {
        code: string,
        map: RawSourceMap
      }
    | string
    | null;
  declare export type ResolveDynamicImportHook = (
    specifier: string | ESTree.Node,
    parentId: string
  ) => Promise<string | void> | string | void;
  declare export type AddonHook = string | (() => string | Promise<string>);

  /**
   * use this type for plugin annotation
   * @example ```ts
   * interface Options {
   * ...
   * }
   * const myPlugin: PluginImpl<Options> = (options = {}) => { ... }
   * ```
   */
  declare export type PluginImpl<O: { [key: string]: any }> = (
    options?: O
  ) => Plugin;
  declare export interface OutputBundle {
    [fileName: string]: OutputAsset | OutputChunk;
  }
  declare export interface Plugin {
    banner?: AddonHook;
    buildEnd?: (err?: Error) => Promise<void> | void;
    buildStart?: (options: InputOptions) => Promise<void> | void;
    cacheKey?: string;
    footer?: AddonHook;
    generateBundle?: (
      options: OutputOptions,
      bundle: OutputBundle,
      isWrite: boolean
    ) => void | Promise<void>;
    writeBundle?: (bundle: OutputBundle) => void | Promise<void>;
    intro?: AddonHook;
    load?: LoadHook;
    name: string;

    /**
     * @deprecated
     */
    ongenerate?: (
      options: OutputOptions,
      chunk: OutputChunk
    ) => void | Promise<void>;

    /**
     * @deprecated
     */
    onwrite?: (
      options: OutputOptions,
      chunk: OutputChunk
    ) => void | Promise<void>;
    options?: (options: InputOptions) => InputOptions | void | null;
    outro?: AddonHook;
    renderChunk?: RenderChunkHook;
    renderError?: (err?: Error) => Promise<void> | void;
    renderStart?: () => Promise<void> | void;
    resolveDynamicImport?: ResolveDynamicImportHook;
    resolveId?: ResolveIdHook;
    transform?: TransformHook;

    /**
     * @deprecated
     */
    transformBundle?: TransformChunkHook;

    /**
     * @deprecated
     */
    transformChunk?: TransformChunkHook;
    watchChange?: (id: string) => void;
  }
  declare export interface TreeshakingOptions {
    propertyReadSideEffects: boolean;
    pureExternalModules: boolean;
  }
  declare export type ExternalOption = string[] | IsExternal;
  declare export type GlobalsOption =
    | {
        [name: string]: string
      }
    | ((name: string) => string);
  declare export type InputOption =
    | string
    | string[]
    | {
        [entryAlias: string]: string
      };
  declare export interface InputOptions {
    acorn?: any;
    acornInjectPlugins?: Function[];
    cache?: false | RollupCache;
    chunkGroupingSize?: number;
    context?: string;
    experimentalCacheExpiry?: number;
    experimentalOptimizeChunks?: boolean;
    experimentalTopLevelAwait?: boolean;
    external?: ExternalOption;
    inlineDynamicImports?: boolean;
    input: InputOption;
    manualChunks?: {
      [chunkAlias: string]: string[]
    };
    moduleContext?:
      | ((id: string) => string)
      | {
          [id: string]: string
        };
    onwarn?: WarningHandler;
    perf?: boolean;
    plugins?: Plugin[];
    preserveModules?: boolean;
    preserveSymlinks?: boolean;
    shimMissingExports?: boolean;
    treeshake?: boolean | TreeshakingOptions;
    watch?: WatcherOptions;
  }
  declare export type ModuleFormat =
    | "amd"
    | "cjs"
    | "system"
    | "es"
    | "esm"
    | "iife"
    | "umd";
  declare export type OptionsPaths =
    | Record<string, string>
    | ((id: string) => string);
  declare export interface OutputOptions {
    amd?: {
      id?: string,
      define?: string
    };
    assetFileNames?: string;
    banner?: string | (() => string | Promise<string>);
    chunkFileNames?: string;
    compact?: boolean;
    dir?: string;
    exports?: "default" | "named" | "none" | "auto";
    entryFileNames?: string;
    esModule?: boolean;
    extend?: boolean;
    file?: string;
    footer?: string | (() => string | Promise<string>);
    format?: ModuleFormat;
    freeze?: boolean;
    globals?: GlobalsOption;
    indent?: boolean;
    interop?: boolean;
    intro?: string | (() => string | Promise<string>);
    name?: string;
    namespaceToStringTag?: boolean;
    noConflict?: boolean;
    outro?: string | (() => string | Promise<string>);
    paths?: OptionsPaths;
    preferConst?: boolean;
    sourcemap?: boolean | "inline";
    sourcemapExcludeSources?: boolean;
    sourcemapFile?: string;
    sourcemapPathTransform?: (sourcePath: string) => string;
    strict?: boolean;
  }
  declare export type WarningHandler = (
    warning: string | RollupWarning
  ) => void;
  declare export interface SerializedTimings {
    [label: string]: [number, number, number];
  }
  declare export interface OutputAsset {
    isAsset: true;
    code?: void;
    fileName: string;
    source: string | Buffer;
  }
  declare export interface RenderedModule {
    renderedExports: string[];
    removedExports: string[];
    renderedLength: number;
    originalLength: number;
  }
  declare export interface RenderedChunk {
    dynamicImports: string[];
    exports: string[];
    facadeModuleId: string | null;
    fileName: string;
    imports: string[];
    isDynamicEntry: boolean;
    isEntry: boolean;
    modules: {
      [id: string]: RenderedModule
    };
    name: string;
  }
  declare export type OutputChunk = {
    code: string,
    map?: SourceMap
  } & RenderedChunk;

  declare export interface SerializablePluginCache {
    [key: string]: [number, any];
  }
  declare export interface RollupCache {
    modules?: ModuleJSON[];
    plugins?: Record<string, SerializablePluginCache>;
  }
  declare export interface RollupOutput {
    output: (OutputChunk | OutputAsset)[];
  }
  declare export interface RollupBuild {
    cache: RollupCache;
    watchFiles: string[];
    generate: (outputOptions: OutputOptions) => Promise<RollupOutput>;
    write: (options: OutputOptions) => Promise<RollupOutput>;
    getTimings?: () => SerializedTimings;
  }
  declare export type RollupOptions = {
    output?: OutputOptions
  } & InputOptions;

  declare export function rollup(options: RollupOptions): Promise<RollupBuild>;

  declare export interface WatchOptions {
    persistent?: boolean;
    ignored?: any;
    ignoreInitial?: boolean;
    followSymlinks?: boolean;
    cwd?: string;
    disableGlobbing?: boolean;
    usePolling?: boolean;
    useFsEvents?: boolean;
    alwaysStat?: boolean;
    depth?: number;
    interval?: number;
    binaryInterval?: number;
    ignorePermissionErrors?: boolean;
    atomic?: boolean | number;
    awaitWriteFinish?:
      | {
          stabilityThreshold?: number,
          pollInterval?: number
        }
      | boolean;
  }
  declare export interface WatcherOptions {
    chokidar?: boolean | WatchOptions;
    include?: string[];
    exclude?: string[];
    clearScreen?: boolean;
  }
  declare export type RollupWatchOptions = {
    output?: OutputOptions | OutputOptions[],
    watch?: WatcherOptions
  } & InputOptions;

  declare export type RollupWatcher = {
    close(): void
  } & EventEmitter;

  declare export function watch(configs: RollupWatchOptions[]): RollupWatcher;
}

