/**
 * Flowtype definitions for full
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v2.1.4
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'lit-html' {
  /**
   * A function type that creates a Template from a TemplateResult.
   *
   * This is a hook into the template-creation process for rendering that
   * requires some modification of templates before they're used, like ShadyCSS,
   * which must add classes to elements and remove styles.
   *
   * Templates should be cached as aggressively as possible, so that many
   * TemplateResults produced from the same expression only do the work of
   * creating the Template the first time.
   *
   * Templates are usually cached by TemplateResult.strings and
   * TemplateResult.type, but may be cached by other keys if this function
   * modifies the template.
   *
   * Note that currently TemplateFactories must not add, remove, or reorder
   * expressions, because there is no way to describe such a modification
   * to render() so that values are interpolated to the correct place in the
   * template instances.
   */
  declare export type TemplateFactory = (result: TemplateResult) => Template
  declare export interface RenderOptions {
    templateFactory: TemplateFactory;
    eventContext?: EventTarget;
  }

  /**
   * The Part interface represents a dynamic part of a template instance rendered
   * by lit-html.
   */
  declare export class Part {
    value: mixed;

    /**
     * Sets the current part value, but does not write it to the DOM.
     * @param value The value that will be committed.
     */
    setValue(value: mixed): void;

    /**
     * Commits the current part value, cause it to actually be written to the DOM.
     */
    commit(): void;
  }

  /**
   * A sentinel value that signals that a value was handled by a directive and
   * should not be written to the DOM.
   */
  declare export var noChange: {[key: string]: any}

  /**
   * A sentinel value that signals a NodePart to fully clear its content.
   */
  declare export var nothing: {}
  declare export type Primitive =
    | null
    | void
    | boolean
    | number
    | string
    | Symbol
    | number
  declare export var isPrimitive: (value: mixed) => boolean

  /**
   * Sets attribute values for AttributeParts, so that the value is only set once
   * even if there are multiple parts for an attribute.
   */
  declare export class AttributeCommitter {
    element: Element;
    name: string;
    strings: string[];
    parts: AttributePart[];
    dirty: boolean;
    constructor(element: Element, name: string, strings: string[]): this;

    /**
     * Creates a single part. Override this to create a differnt type of part.
     */
    _createPart(): AttributePart;
    _getValue(): mixed;
    commit(): void;
  }
  declare export class AttributePart mixins Part {
    committer: AttributeCommitter;
    value: mixed;
    constructor(comitter: AttributeCommitter): this;
    setValue(value: mixed): void;
    commit(): void;
  }
  declare export class NodePart mixins Part {
    options: RenderOptions;
    startNode: Node;
    endNode: Node;
    value: mixed;
    _pendingValue: mixed;
    constructor(options: RenderOptions): this;

    /**
     * Inserts this part into a container.
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    appendInto(container: Node): void;

    /**
     * Inserts this part between `ref` and `ref`'s next sibling. Both `ref` and
     * its next sibling must be static, unchanging nodes such as those that appear
     * in a literal section of a template.
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    insertAfterNode(ref: Node): void;

    /**
     * Appends this part into a parent part.
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    appendIntoPart(part: NodePart): void;

    /**
     * Appends this part after `ref`
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    insertAfterPart(ref: NodePart): void;
    setValue(value: mixed): void;
    commit(): void;
    clear(startNode?: Node): void;
  }

  /**
   * Implements a boolean attribute, roughly as defined in the HTML
   * specification.
   *
   * If the value is truthy, then the attribute is present with a value of
   * ''. If the value is falsey, the attribute is removed.
   */
  declare export class BooleanAttributePart mixins Part {
    element: Element;
    name: string;
    strings: string[];
    value: mixed;
    _pendingValue: mixed;
    constructor(element: Element, name: string, strings: string[]): this;
    setValue(value: mixed): void;
    commit(): void;
  }

  /**
   * Sets attribute values for PropertyParts, so that the value is only set once
   * even if there are multiple parts for a property.
   *
   * If an expression controls the whole property value, then the value is simply
   * assigned to the property under control. If there are string literals or
   * multiple expressions, then the strings are expressions are interpolated into
   * a string first.
   */
  declare export class PropertyCommitter mixins AttributeCommitter {
    single: boolean;
    constructor(element: Element, name: string, strings: string[]): this;
    _createPart(): PropertyPart;
    _getValue(): mixed;
    commit(): void;
  }
  declare export class PropertyPart mixins AttributePart {}
  declare export class EventPart mixins Part {
    element: Element;
    eventName: string;
    eventContext: EventTarget;
    constructor(
      element: Element,
      eventName: string,
      eventContext?: EventTarget,
    ): this;
    commit(): void;
    handleEvent(event: Event): void;
  }

  /**
   * An expression marker with embedded unique key to avoid collision with
   * possible text in templates.
   */
  declare export var marker: string

  /**
   * An expression marker used text-positions, multi-binding attributes, and
   * attributes with markup-like text values.
   */
  declare export var nodeMarker: string
  declare export var markerRegex: RegExp

  /**
   * Suffix appended to all bound attribute names.
   */
  declare export var boundAttributeSuffix: any // "$lit$";

  /**
   * An updateable Template that tracks the location of dynamic parts.
   */
  declare export class Template {
    parts: TemplatePart[];
    element: HTMLTemplateElement;
    constructor(result: TemplateResult, element: HTMLTemplateElement): this;
  }

  /**
   * A placeholder for a dynamic expression in an HTML template.
   *
   * There are two built-in part types: AttributePart and NodePart. NodeParts
   * always represent a single dynamic expression, while AttributeParts may
   * represent as many expressions are contained in the attribute.
   *
   * A Template's parts are mutable, so parts can be replaced or modified
   * (possibly to implement different template semantics). The contract is that
   * parts can only be replaced, not removed, added or reordered, and parts must
   * always consume the correct number of values in their `update()` method.
   *
   * TODO(justinfagnani): That requirement is a little fragile. A
   * TemplateInstance could instead be more careful about which values it gives
   * to Part.update().
   */
  declare export type TemplatePart =
    | {
        type: 'node',
        index: number,
      }
    | {
        type: 'attribute',
        index: number,
        name: string,
        strings: string[],
      }
  declare export var isTemplatePartActive: (part: TemplatePart) => boolean
  declare export var createMarker: () => Comment

  /**
   * This regex extracts the attribute name preceding an attribute-position
   * expression. It does this by matching the syntax allowed for attributes
   * against the string literal directly preceding the expression, assuming that
   * the expression is in an attribute-value position.
   *
   * See attributes in the HTML spec:
   * https://www.w3.org/TR/html5/syntax.html#attributes-0
   *
   * "\0-\x1F\x7F-\x9F" are Unicode control characters
   *
   * " \x09\x0a\x0c\x0d" are HTML space characters:
   * https://www.w3.org/TR/html5/infrastructure.html#space-character
   *
   * So an attribute is:
   *   * The name: any character except a control character, space character, ('),
   *     ("), ">", "=", or "/"
   *   * Followed by zero or more space characters
   *   * Followed by "="
   *   * Followed by zero or more space characters
   *   * Followed by:
   *     * Any character except space, ('), ("), "<", ">", "=", (`), or
   *    *    * (") then any non-("), or
   *    *    * (') then any non-(')
   *    *
   */
  declare export var lastAttributeNameRegex: RegExp
  declare export type KeyFn<T> = (item: T) => any
  declare export type ItemTemplate<T> = (item: T, index: number) => any
  declare export type DirectiveFn = (part: Part) => void
  declare export function repeat<T>(
    items: T[],
    keyFn: KeyFn<T>,
    template: ItemTemplate<T>,
  ): DirectiveFn<NodePart>

  declare export function repeat<T>(
    items: T[],
    template: ItemTemplate<T>,
  ): DirectiveFn<NodePart>

  declare export var parts: WeakMap<Node, NodePart>

  /**
   * The return type of `html`, which holds a Template and the values from
   * interpolated expressions.
   */
  declare export class TemplateResult {
    strings: string[];
    values: mixed[];
    type: string;

    /**
     * Returns a string of HTML used to create a `<template>` element.
     */
    getHTML(): string;
    getTemplateElement(): HTMLTemplateElement;
  }

  /**
   * A TemplateResult for SVG fragments.
   *
   * This class wraps HTMl in an `<svg>` tag in order to parse its contents in the
   * SVG namespace, then modifies the template to remove the `<svg>` tag so that
   * clones only container the original fragment.
   */
  declare export class SVGTemplateResult mixins TemplateResult {
    getHTML(): string;
    getTemplateElement(): HTMLTemplateElement;
  }

  /**
   * Renders a template to a container.
   *
   * To update a container with new values, reevaluate the template literal and
   * call `render` with the new result.
   * @param result a TemplateResult created by evaluating a template tag like
   * `html` or `svg`.
   * @param container A DOM parent to render to. The entire contents are either
   * replaced, or efficiently updated if the same result type was previous
   * rendered there.
   * @param options RenderOptions for the entire render tree rendered to this
   * container. Render options must *not* change between renders to the same
   * container, as those changes will not effect previously rendered DOM.
   */
  declare export var render: (
    result: TemplateResult,
    container: Element | DocumentFragment | null,
    options?: $Shape<RenderOptions> | void,
  ) => void

  /**
   * Interprets a template literal as an HTML template that can efficiently
   * render to and update a container.
   */
  declare export var html: (
    strings: string[],
    ...values: mixed[]
  ) => TemplateResult

  /**
   * Interprets a template literal as an SVG template that can efficiently
   * render to and update a container.
   */
  declare export var svg: (
    strings: string[],
    ...values: mixed[]
  ) => SVGTemplateResult
}
